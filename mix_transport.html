<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
  <meta http-equiv="X-UA-Compatible" content="IE=9"/>
  <meta name="generator" content="Doxygen 1.9.5"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>MoFEM: COR-0: Mixed formulation and integration on skeleton (h-adaptivity)</title>
  <link href="tabs.css" rel="stylesheet" type="text/css"/>
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
  <script type="text/javascript " src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML "></script>
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        extensions: ["AMSmath.js"],
        TeX: { equationNumbers: { autoNumber: ["all"],
                                  useLabelIds: true
        } 
        }
    });
    </script>
  <link href="customdoxygen.css" rel="stylesheet" type="text/css" />
  <link href="extra_style.css" rel="stylesheet" type="text/css"/>
  <link rel="apple-touch-icon" sizes="57x57" href="apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192"  href="android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.png">
  <link rel="shortcut icon" type="image/png" href="favicon-32x32.png"/>
  <link rel="Bookmark" type="image/png" href="favicon-32x32.png"/>
  <link rel="manifest" href="manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div style="background-color:#011A40" id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 30px;">
  <td id="projectlogo"><img alt="Logo" src="MoFEMLogo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <td style="padding-left: 0.5em;" bgcolor="#011A40"
   <div id="projectbrief"><font color="#FFFFFF">v0.14.0</font></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!--Google analytics tags-->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-65236130-1', 'auto');
  ga('send', 'pageview');
</script>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-2J9RE2P3H5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-2J9RE2P3H5');
</script><!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>  </ul>
</div>
</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">COR-0: Mixed formulation and integration on skeleton (h-adaptivity) </div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#mix_mesh_refinement">Explaining mesh BitRefLevel</a></li>
<li class="level1"><a href="#mix_reading_mesh">Setting up problem</a></li>
<li class="level1"><a href="#um_solving_problem">Solving problem and calculating matrices and vectors</a><ul><li class="level2"><a href="#mixtransport_add_fields">Adding fields to the database (ufe.addFields)</a></li>
<li class="level2"><a href="#mixtransport_add_elements">Adding elements to the database (ufe.addFiniteElements)</a></li>
<li class="level2"><a href="#mixtransport_add_bc_elements">Adding boundary elements to the database (ufe.addBoundaryElements)</a></li>
<li class="level2"><a href="#mixtransport_build_problem">Declaring and building problem (ufe.buildProblem)</a></li>
<li class="level2"><a href="#mixtransport_create_matrices">Create vectors and matrices (ufe.createMatrices)</a></li>
</ul>
</li>
<li class="level1"><a href="#mixtransport_assemble_and_solve">Assemble and solve</a><ul><li class="level2"><a href="#mixtransport_finite_element_instances">Finite element instances</a></li>
<li class="level2"><a href="#mixtransport_solve_problem">Solve problem (ufe.solveLinearProblem)</a></li>
</ul>
</li>
<li class="level1"><a href="#mixtransport_implementation">Implementation of user operator</a><ul><li class="level2"><a href="#mixtransport_assmble_matrix">Assembling matrix</a></li>
<li class="level2"><a href="#mixtransport_assmble_vector">Assembling vector</a></li>
</ul>
</li>
<li class="level1"><a href="#mixtransport_error">Evaluate error</a><ul><li class="level2"><a href="#mixtransport_refinemnt_sequence">Calculate error and refine mesh</a></li>
<li class="level2"><a href="#mixtransport_jump">Calculate jump on the skeleton</a></li>
<li class="level2"><a href="#mixtransport_calculate_error">Calculate residual error estimator</a></li>
</ul>
</li>
<li class="level1"><a href="#mixtransport_meshrefinement">Mesh refinement</a></li>
<li class="level1"><a href="#mixtransport_future_work">Future work and contribution</a></li>
</ul>
</div>
<div class="textblock"><p >Set by step example how to implement mix finite element and do hp-adaptivity.</p>
<p >Here we present general procedure applied to h-adaptivity of mix problem. <a class="el" href="namespace_mo_f_e_m.html" title="implementation of Data Operators for Forces and Sources">MoFEM</a> is generic finite element code capable of solving problems from magnetics, mechanics of fluids and solids, and as a result of this operates on necessary complex data structures able to carry abstract problems. If you master this example, applying the same approach, you will be able to implement in similar way other problems, for instance, Discontinuous Galerkin Method, or thermo-mechanical coupled problem.</p>
<p >In this tutorial, we show how to implement h-adaptivity for mix transport formulation for stationary transport/heat-conduction problem (The <a class="el" href="struct_poisson.html">Poisson</a> equation). We focus on h-adaptivity, however, this implementation allows running problem with the arbitrary order of approximation and extension to p-/hp-adativity is possible.</p>
<p >Code relevant to this tutorial could be found in <a class="el" href="group__mofem__mix__transport__elem.html">Mix transport element</a> module. Plane source code for main program is available under link <a class="el" href="h__adaptive__transport_8cpp.html">h_adaptive_transport.cpp</a>, whereas main class implementation of finite element and finite element operators is available here <a class="el" href="_mix_transport_element_8hpp.html">MixTransportElement.hpp</a>.</p>
<p ><a class="el" href="namespace_mo_f_e_m.html" title="implementation of Data Operators for Forces and Sources">MoFEM</a> is built on three pillars, PETSc library which manages abstraction related to the algebraic system of equations and delivers interface to several solvers, mesh-oriented database (MoAB) which manages complexities related to mesh topology and delivers various format readers and Boost library which through multi-indices manages access to containers with <a class="el" href="namespace_mo_f_e_m.html" title="implementation of Data Operators for Forces and Sources">MoFEM</a> data structures.</p>
<p ><a class="el" href="namespace_mo_f_e_m.html" title="implementation of Data Operators for Forces and Sources">MoFEM</a> handles complexities related to finite element method, degrees of freedom, approximation spaces and base functions. It provides tools and structures for implementation classical and nonclassical finite element codes and can handle linear, nonlinear and time dependent problems.</p>
<p >Here we are considering a problem  </p><p class="formulaDsp">
\[
A_{ij} \sigma_j + u_{,i} = 0 \; \textrm{on} \; \Omega \\
\sigma_{i,i} = f \; \textrm{on} \; \Omega
\]
</p>
<p> where first equation is a physical (constitutive) equation and tensor \(A_{ij}\) express material properties, for example, if \(A_{ij}\) is a diagonal matrix with single constant on diagonal we have an isotropic material. The second equation is conservation equation, which expresses law that mass or energy can ot be created or destroyed (close system).</p>
<p >Multiplying the constitutive equation by a test field \(\tau\) and integrating by parts over \(\Omega\) (taking into account the inhomogeneous Dirichlet boundary condition), we obtain  </p><p class="formulaDsp">
\[
\int_\Omega A_{ij}\sigma_j \tau_i \textrm{d}x - \int_\Omega u \tau_{i,i} \textrm{d}x =
\int_{\Gamma_\textrm{u}} \overline{u} \tau_{i} n_i \textrm{d}\Gamma
,\quad \forall \boldsymbol\tau \in H(\textrm{div},\Omega)
\]
</p>
<p> while from the equilibrium equation by multiplying by test field \(v\) we obtain  </p><p class="formulaDsp">
\[
\int_\Omega \sigma_{i,i}v \textrm{d}x = \int_\Omega f v \textrm{d}x, \quad \forall v \in L^2(\Omega).
\]
</p>
<p >Before we look into implementation details, you can run simple example </p><div class="fragment"><div class="line">cd basic_finite_elements/mix_transport</div>
<div class="line">mpirun -np 2 ./h_adaptive_transport \</div>
<div class="line">-my_file <a class="code hl_variable" href="matrix__function_8cpp.html#a510d8658904ea5f9e62ae641c8122e49">l</a>-shape.msh -meshsets_config bc.cfg  \</div>
<div class="line">-my_order 1 -<a class="code hl_variable" href="level__set_8cpp.html#a4a62410a15dcd5a702a26f8bff4ae683">nb_levels</a> 5 2&gt;&amp;1 | tee log_order1</div>
<div class="ttc" id="alevel__set_8cpp_html_a4a62410a15dcd5a702a26f8bff4ae683"><div class="ttname"><a href="level__set_8cpp.html#a4a62410a15dcd5a702a26f8bff4ae683">nb_levels</a></div><div class="ttdeci">constexpr int nb_levels</div><div class="ttdef"><b>Definition:</b> <a href="level__set_8cpp_source.html#l00041">level_set.cpp:41</a></div></div>
<div class="ttc" id="amatrix__function_8cpp_html_a510d8658904ea5f9e62ae641c8122e49"><div class="ttname"><a href="matrix__function_8cpp.html#a510d8658904ea5f9e62ae641c8122e49">l</a></div><div class="ttdeci">FTensor::Index&lt; 'l', 3 &gt; l</div><div class="ttdef"><b>Definition:</b> <a href="matrix__function_8cpp_source.html#l00021">matrix_function.cpp:21</a></div></div>
</div><!-- fragment --><p> where</p><ul>
<li><em>-np</em> <b>2</b> indicate number of processors</li>
<li><em>-my_file</em> <b><a class="el" href="l-shape_8msh.html">l-shape.msh</a></b> name of the mesh file</li>
<li><em>-meshsets_config</em> <b>bc.cfg</b> name of file with boundary conditions</li>
<li><em>-my_order</em> <b>1</b> set approximation order (0,1,2,..)</li>
<li><em>-nb_levels</em> <b>5</b> set number of mesh refinement level driven by approximation error</li>
</ul>
<p >Above code produces output files, <b>out_0.h5m</b>, <b>out_1.h5m</b>, ... where number of files is dependent on number of refinement levels. You can convert those files to VTK format running script </p><div class="fragment"><div class="line">../nonlinear_elasticity/do_vtk.sh out_*.h5m</div>
</div><!-- fragment --><p> and post-process results in ParaView <a href="http://www.paraview.org">http://www.paraview.org</a>.</p>
<p >As result of post-processing in ParaView we have created following output </p><div class="image">
<img src="l-shape-adaptivity.gif" alt="" width="800px"/>
<div class="caption">
h-adaptivity</div></div>
 <div class="image">
<img src="l-shape-adaptivity_singularity.gif" alt="" width="800px"/>
<div class="caption">
Flux singularity</div></div>
 <div class="image">
<img src="l-shape-convergence.png" alt="" width="800px"/>
<div class="caption">
Convergence plot</div></div>
<p >You can note that subsequent mesh refinement reduces error and make it more uniformly distributed through the mesh. You can also observe that mesh is getting denser at the corner where singularity is located.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000074">Todo:</a></b></dt><dd>Should be implemented and tested problem from this article <a class="el" href="citelist.html#CITEREF_demkowicz2011analysis">[20]</a>. In this paper analytical solution is available, allowing to tested efficiency of evaluated error. You are very welcome to improve that documentation.</dd></dl>
<h1><a class="anchor" id="mix_mesh_refinement"></a>
Explaining mesh BitRefLevel</h1>
<p ><a class="el" href="namespace_mo_f_e_m_1_1_types.html#aa9495b406c5326b7bca937846ec421c5">MoFEM::BitRefLevel</a> is a generic tool which allows working on several overlapping meshes, partially sharing entities and topology. In the context of this problem, we would use it to create and work with a hierarchy of mesh refinement.</p>
<p >For each entity in a database (vertex, edge, triangle, quad, ..., tetrahedra, brick, prism, ...) we attach bit tag, i.e. <a class="el" href="namespace_mo_f_e_m_1_1_types.html#aa9495b406c5326b7bca937846ec421c5">MoFEM::BitRefLevel</a>. Using that tag we can make selections of entities and other operations on meshes.</p>
<p >It will be easier to understand if you look at the figure below </p><div class="image">
<img src="mesh_bit_levels.png" alt="" width="800px"/>
<div class="caption">
Mesh bit refinement levels (Example)</div></div>
<p >Imagine that we load the mesh with the topology like in the top-left figure. We seed the mesh (<a class="el" href="struct_mo_f_e_m_1_1_deprecated_core_interface.html#a99746b844704e78167482954bb5e52b0">MoFEM::Interface::seed_ref_level</a>) by tagging each entity with the first bit on, i.e. <em>001</em>.</p>
<p >Next, we refine by splitting one of the edges, see middle-left figure. You can understand that as edge-splitting-mesh refinement, see <a class="el" href="citelist.html#CITEREF_ruprecht1998scheme">[43]</a>. As the result of this mesh refinement, new vertex in the middle of the edge is created, four new edges and four triangles. The remaining of mesh entities is part of old and new mesh level. As a consequence, entities which are shared between the second mesh and first mesh have two bites on, i.e. <em>011</em>, since those are coexisting on two meshes. New entities have the only second bit on, i.e. <em>010</em>.</p>
<p >In the next step, we made third mesh refinement. The procedure repeats, we have some new entities which have the only third bit on, i.e. <em>100</em>, some entities are shared between refinement second and third, those have third and a second bit on, i.e. 110, and some entities are shared between all refinement levels, i.e. <em>111</em>. In current implementation, we assume that user would not have more than 32 refinement levels. However bit squashing and bit level deletion allows form deep (more than 32) mesh refinements.</p>
<p >Physically all three meshes overlap, we do not delete overlapped entities or create new whole mesh each time. It is the reason behind that since we like to transfer data between different refinement levels without the redundancy and unnecessary copying and communication between processors if the mesh is distributed.</p>
<p >Now we present examples of mesh selections; you can practically do everything that you do with bits, see <a href="https://en.wikipedia.org/wiki/Bitwise_operation#Bit_shifts">https://en.wikipedia.org/wiki/Bitwise_operation#Bit_shifts</a>. For example;</p>
<ul>
<li>Setting bit <em>100</em> and mask <em>110</em> we can select all entities which were created during second and third refinement level, see top-right figure.</li>
<li>Setting bit <em>010</em> and mask <em>111</em> we can get entities only which belong to the second refinement, see middle-right figure.</li>
<li>Setting bit <em>001</em> and mask <em>111</em> we can get entities only which are belong initial mesh, see the figure in the bottom right corner.</li>
</ul>
<p >That allows to project data between meshes, do calculations on the part of the mesh, to introduce cracks, make topological changes like face flipping. Note that problem below is defined for particular bit levels. See link <a class="el" href="group__mofem__ref__ents.html">Get entities and adjacencies</a> for details how to get entities and adjacent by bit refinement levels.</p>
<h1><a class="anchor" id="mix_reading_mesh"></a>
Setting up problem</h1>
<p >We consider the problem which potentially can have complex geometry and a non-trivial set of boundary conditions. Here we use Gmsh (see <a href="http://gmsh.info">http://gmsh.info</a>) to generate the mesh. In this section, we focus attention on how to read mesh file and how to apply some arbitrary boundary conditions on that mesh.</p>
<p >The first step is to create mesh database, where information about the problem is stored. We create MoAB (see <a href="http://ftp.mcs.anl.gov/pub/fathom/moab-docs/">http://ftp.mcs.anl.gov/pub/fathom/moab-docs/</a>) instance and interface to it </p><div class="fragment"><div class="line">moab::Core mb_instance;               <span class="comment">///&lt; Create database</span></div>
<div class="line">moab::Interface&amp; moab = mb_instance;  <span class="comment">///&lt; Create interface to database</span></div>
</div><!-- fragment --><p >Once we have created mesh database, we get from command line name of file which we like to load </p><div class="fragment"><div class="line">PetscBool flg = PETSC_TRUE;   <span class="comment">///&lt; Is true of option is set in line command</span></div>
<div class="line"><span class="keywordtype">char</span> <a class="code hl_variable" href="mesh__smoothing_8cpp.html#ae20b66af13b03d8e8a4593186c23cd07">mesh_file_name</a>[255];     <span class="comment">///&lt; File name</span></div>
<div class="line"><a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> PetscOptionsGetString(PETSC_NULL,PETSC_NULL,<span class="stringliteral">&quot;-my_file&quot;</span>,<a class="code hl_variable" href="mesh__smoothing_8cpp.html#ae20b66af13b03d8e8a4593186c23cd07">mesh_file_name</a>,255,&amp;flg); </div>
<div class="ttc" id="adefinitions_8h_html_add80e5ef5f847b2d4b637029f0f671c3"><div class="ttname"><a href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a></div><div class="ttdeci">#define CHKERR</div><div class="ttdoc">Inline error check.</div><div class="ttdef"><b>Definition:</b> <a href="definitions_8h_source.html#l00535">definitions.h:535</a></div></div>
<div class="ttc" id="amesh__smoothing_8cpp_html_ae20b66af13b03d8e8a4593186c23cd07"><div class="ttname"><a href="mesh__smoothing_8cpp.html#ae20b66af13b03d8e8a4593186c23cd07">mesh_file_name</a></div><div class="ttdeci">char mesh_file_name[255]</div><div class="ttdef"><b>Definition:</b> <a href="mesh__smoothing_8cpp_source.html#l00023">mesh_smoothing.cpp:23</a></div></div>
</div><!-- fragment --><p> where here we are using PETSc function to do that, see <a href="http://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/Sys/PetscOptionsGetString.html">http://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/Sys/PetscOptionsGetString.html</a> for more details. Having mesh file name, we can load mesh, created in Gmsh, to database </p><div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span> *option;</div>
<div class="line">option = <span class="stringliteral">&quot;&quot;</span>;</div>
<div class="line"><a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> moab.load_file(<a class="code hl_variable" href="mesh__smoothing_8cpp.html#ae20b66af13b03d8e8a4593186c23cd07">mesh_file_name</a>, 0, option); </div>
</div><!-- fragment --><p ><a class="el" href="namespace_mo_f_e_m.html" title="implementation of Data Operators for Forces and Sources">MoFEM</a> can read various file format in this example we are using mesh from Gmsh, where example file geometry is stored in file <a class="el" href="l-shape_8geo.html">l-shape.geo</a> and mesh is in <a class="el" href="l-shape_8msh.html">l-shape.msh</a>. For more details about file formats please look into MoAB documentation.</p>
<p >Creating <a class="el" href="namespace_mo_f_e_m.html" title="implementation of Data Operators for Forces and Sources">MoFEM</a> database to store information about fields, finite elements and problem, we link it to MOAB database and create interface to manage data </p><div class="fragment"><div class="line"><a class="code hl_struct" href="struct_mo_f_e_m_1_1_core_tmp_3_010_01_4.html">MoFEM::Core</a> core(moab);             <span class="comment">///&lt; Create database</span></div>
<div class="line"><a class="code hl_struct" href="struct_mo_f_e_m_1_1_deprecated_core_interface.html">MoFEM::Interface</a>&amp; m_field = core;   <span class="comment">///&lt; Create interface to database</span></div>
<div class="ttc" id="astruct_mo_f_e_m_1_1_core_tmp_3_010_01_4_html"><div class="ttname"><a href="struct_mo_f_e_m_1_1_core_tmp_3_010_01_4.html">MoFEM::CoreTmp&lt; 0 &gt;</a></div><div class="ttdoc">Core (interface) class.</div><div class="ttdef"><b>Definition:</b> <a href="_core_8hpp_source.html#l00082">Core.hpp:82</a></div></div>
<div class="ttc" id="astruct_mo_f_e_m_1_1_deprecated_core_interface_html"><div class="ttname"><a href="struct_mo_f_e_m_1_1_deprecated_core_interface.html">MoFEM::DeprecatedCoreInterface</a></div><div class="ttdoc">Deprecated interface functions.</div><div class="ttdef"><b>Definition:</b> <a href="_deprecated_core_interface_8hpp_source.html#l00016">DeprecatedCoreInterface.hpp:16</a></div></div>
</div><!-- fragment --><p >In file \erf <a class="el" href="l-shape_8msh.html">l-shape.msh</a> following geometry and mesh is described </p><div class="image">
<img src="gmesh_blocksets.png" alt="" width="800px"/>
<div class="caption">
Blocksets and GMesh mesh</div></div>
<p> where as result of reading of that mesh into <a class="el" href="namespace_mo_f_e_m.html" title="implementation of Data Operators for Forces and Sources">MoFEM</a> database, following information is printed on the screen </p><pre class="fragment">read cubit meshset 12682136550675316737 type BLOCKSET msId 2
read cubit meshset 12682136550675316738 type BLOCKSET msId 3
read cubit meshset 12682136550675316741 type BLOCKSET msId 1
</pre><p> The output to the screen indicates that three <em>BLOCKSETs</em> are available. Those <em>BOLCKSETs</em> are interpreted as <em>Physical</em> Volume and <em>Physical</em> Surfaces which were created in Gmsh. User can create more sophisticated geometry or use more complex set of boundary conditions. Interpretation of BLOCKSETs is a matter of separate config file, which describes problem specific types of boundary conditions.</p>
<p >The interpretation of <em>BLOCKSETs</em> is done by the meshset config file <b>bc.cfg</b>, </p><div class="fragment"></div><!-- fragment --><p> According to that file, <em>BLOCKSET</em> 3 is set to be <em>NODESET</em> 1001 where temperature is applied \(u=0\, x \in \partial \Omega_u\) and <em>BLOCKSET</em> 2 is set to be SIDESET 1002 where flux is applied \(n_i\sigma_i = 1\, x \in \partial \Omega_\sigma\). On <em>BLOCKSET</em> 1 is the domain \(\Omega\) where problem is defined.</p>
<p >In the above example, temperature type, heat flux type and temperature volume are used. This is a matter of interpretation as well, we are using this convention to be consistent with other meshing programs like CUBIT where boundary conditions like that can be set directly. However, <a class="el" href="namespace_mo_f_e_m.html" title="implementation of Data Operators for Forces and Sources">MoFEM</a> user can set own types and attach own interpretation if needed.</p>
<p >Boundary condition meshsets are managed in <a class="el" href="namespace_mo_f_e_m.html" title="implementation of Data Operators for Forces and Sources">MoFEM</a> by <a class="el" href="struct_mo_f_e_m_1_1_meshsets_manager.html">MoFEM::MeshsetsManager</a> interface. Using that interface user can access information about boundary conditions and add a new one. All modules and software components using that interface can easily share information through it. To get access to interface, user needs to query <a class="el" href="namespace_mo_f_e_m.html" title="implementation of Data Operators for Forces and Sources">MoFEM</a> for it, as follows </p><div class="fragment"><div class="line"><a class="code hl_struct" href="struct_mo_f_e_m_1_1_meshsets_manager.html">MoFEM::MeshsetsManager</a> *meshsets_manager_ptr; <span class="comment">//&lt; Click on class to see more details</span></div>
<div class="line"><a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> m_field.<a class="code hl_function" href="struct_mo_f_e_m_1_1_unknown_interface.html#a7ab248ec45fca778800dcd92e5171beb">getInterface</a>(meshsets_manager_ptr); </div>
<div class="ttc" id="astruct_mo_f_e_m_1_1_meshsets_manager_html"><div class="ttname"><a href="struct_mo_f_e_m_1_1_meshsets_manager.html">MoFEM::MeshsetsManager</a></div><div class="ttdoc">Interface for managing meshsets containing materials and boundary conditions.</div><div class="ttdef"><b>Definition:</b> <a href="_meshsets_manager_8hpp_source.html#l00104">MeshsetsManager.hpp:104</a></div></div>
<div class="ttc" id="astruct_mo_f_e_m_1_1_unknown_interface_html_a7ab248ec45fca778800dcd92e5171beb"><div class="ttname"><a href="struct_mo_f_e_m_1_1_unknown_interface.html#a7ab248ec45fca778800dcd92e5171beb">MoFEM::UnknownInterface::getInterface</a></div><div class="ttdeci">MoFEMErrorCode getInterface(IFACE *&amp;iface) const</div><div class="ttdoc">Get interface refernce to pointer of interface.</div><div class="ttdef"><b>Definition:</b> <a href="_unknown_interface_8hpp_source.html#l00093">UnknownInterface.hpp:93</a></div></div>
</div><!-- fragment --><p> using interface we can read file <b>bc.cfg</b>, parse it and add boundary conditions. All this is automatized for user convenience and done with single interface method </p><div class="fragment"><div class="line"><a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> meshsets_manager_ptr-&gt;<a class="code hl_function" href="struct_mo_f_e_m_1_1_meshsets_manager.html#a977350c3bd94798931618d026d6eb06d">setMeshsetFromFile</a>();   <span class="comment">//&lt;- Click on function to see more details</span></div>
<div class="ttc" id="astruct_mo_f_e_m_1_1_meshsets_manager_html_a977350c3bd94798931618d026d6eb06d"><div class="ttname"><a href="struct_mo_f_e_m_1_1_meshsets_manager.html#a977350c3bd94798931618d026d6eb06d">MoFEM::MeshsetsManager::setMeshsetFromFile</a></div><div class="ttdeci">MoFEMErrorCode setMeshsetFromFile(const string file_name, const bool clean_file_options=true)</div><div class="ttdoc">add blocksets reading config file</div><div class="ttdef"><b>Definition:</b> <a href="_meshsets_manager_8cpp_source.html#l00725">MeshsetsManager.cpp:725</a></div></div>
</div><!-- fragment --><p >In general, user can query about range of interfaces giving access to specific tools. In this example we are using two types of interfaces, one to manage <em>BLOCKSETs</em>, i.e. <a class="el" href="struct_mo_f_e_m_1_1_meshsets_manager.html">MoFEM::MeshsetsManager</a> and another for refining meshes, i.e. <a class="el" href="struct_mo_f_e_m_1_1_mesh_refinement.html" title="Mesh refinement interface.">MoFEM::MeshRefinement</a>.</p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="namespace_mo_f_e_m.html" title="implementation of Data Operators for Forces and Sources">MoFEM</a> uses interfaces to do particular tasks, could have one or more interfaces for the same task, which differs in complexity, one is simple to do basic operation while another can be for advanced users. It can have different versions of the interface. We design <a class="el" href="namespace_mo_f_e_m.html" title="implementation of Data Operators for Forces and Sources">MoFEM</a> like that to have a structure which can adapt in time to new technologies and programmers need.</dd>
<dd>
Note that all commands return an error code and after each function, an error code is checked, in a case of the error, appropriate information is printed during execution time. It is important to follow that rule, of checking the error code, it simplifies code debugging and bug reporting.</dd></dl>
<h1><a class="anchor" id="um_solving_problem"></a>
Solving problem and calculating matrices and vectors</h1>
<p >We start with calculating initial problem on mesh created with Gmsh. The problem is broken down into several stages, implementation of a mix transport problem is in ExampleMix which is derived from <a class="el" href="struct_mix_transport_1_1_mix_transport_element.html" title="Mix transport problem.">MixTransport::MixTransportElement</a>.</p>
<dl class="section note"><dt>Note</dt><dd>We have the hierarchy of classes (structures), some of them are generic thus are part of <a class="el" href="namespace_mo_f_e_m.html" title="implementation of Data Operators for Forces and Sources">MoFEM</a> namespace and are implemented in the core library. Others are generic for a particular problem, for example, mix transport formulation (<a class="el" href="struct_mix_transport_1_1_mix_transport_element.html" title="Mix transport problem.">MixTransport::MixTransportElement</a>) is implemented in user modules. And finally, some classes (ExampleMix) are for very specific example, where some close solution is needed.</dd></dl>
<p>In class <a class="el" href="struct_mix_transport_1_1_mix_transport_element.html" title="Mix transport problem.">MixTransport::MixTransportElement</a> all operators for evaluating matrices, the right-hand side vector, error evaluation are implemented. Moreover methods for declaring and defining fields, finite elements and problems are added. This class could be used by other users, solving similar problems.</p>
<p >In derived class ExampleMix, particular functions for given transport problem with h-adaptivity are implemented. The method handles specific boundary conditions for this example.</p>
<p >The general procedure to solve problem looks like follows </p><div class="fragment"><div class="line"><a class="code hl_typedef" href="h__adaptive__transport_8cpp.html#a2fa8d92dd99a1c48dc7a66f12b436b13">BcFluxMap</a> bc_flux_map;</div>
<div class="line">ExampleMix ufe(m_field,bc_flux_map);</div>
<div class="line"><span class="comment">// Initially calculate problem on coarse mesh</span></div>
<div class="line"><a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> ufe.addFields(<span class="stringliteral">&quot;VALUES&quot;</span>,<span class="stringliteral">&quot;FLUXES&quot;</span>,<a class="code hl_variable" href="dg__projection_8cpp.html#ad7eceded84ace5678d9df3e44f47d475">order</a>); </div>
<div class="line"><a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> ufe.addFiniteElements(<span class="stringliteral">&quot;FLUXES&quot;</span>,<span class="stringliteral">&quot;VALUES&quot;</span>); </div>
<div class="line"><span class="comment">// Set boundary conditions</span></div>
<div class="line"><a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> ufe.addBoundaryElements(ref_level);</div>
<div class="line"><a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> ufe.buildProblem(ref_level); </div>
<div class="line"><a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> ufe.createMatrices(); </div>
<div class="line"><a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> ufe.solveLinearProblem(); </div>
<div class="line"><a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> ufe.calculateResidual(); </div>
<div class="line"><a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> ufe.evaluateError(); </div>
<div class="line"><a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> ufe.destroyMatrices(); </div>
<div class="line"><a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> ufe.postProc(<span class="stringliteral">&quot;out_0.h5m&quot;</span>); </div>
<div class="ttc" id="adg__projection_8cpp_html_ad7eceded84ace5678d9df3e44f47d475"><div class="ttname"><a href="dg__projection_8cpp.html#ad7eceded84ace5678d9df3e44f47d475">order</a></div><div class="ttdeci">constexpr int order</div><div class="ttdef"><b>Definition:</b> <a href="dg__projection_8cpp_source.html#l00018">dg_projection.cpp:18</a></div></div>
<div class="ttc" id="ah__adaptive__transport_8cpp_html_a2fa8d92dd99a1c48dc7a66f12b436b13"><div class="ttname"><a href="h__adaptive__transport_8cpp.html#a2fa8d92dd99a1c48dc7a66f12b436b13">BcFluxMap</a></div><div class="ttdeci">map&lt; int, BcFluxData &gt; BcFluxMap</div><div class="ttdef"><b>Definition:</b> <a href="h__adaptive__transport_8cpp_source.html#l00034">h_adaptive_transport.cpp:34</a></div></div>
</div><!-- fragment --><p> such procedure will look very similar to other problems, where we set-up problem, apply boundary conditions, solve problem and postprocess results.</p>
<p >Some <a class="el" href="namespace_mo_f_e_m.html" title="implementation of Data Operators for Forces and Sources">MoFEM</a> functions and philosophy of building problem are explained in minimal_surface_equation, please look into that document for further explanation.</p>
<h2><a class="anchor" id="mixtransport_add_fields"></a>
Adding fields to the database (ufe.addFields)</h2>
<p >In <a class="el" href="struct_mix_transport_1_1_mix_transport_element.html#ab0d84b9fc47b6ae62dad8f4ada3757cd">MixTransport::MixTransportElement::addFields</a>, we declare and define fields and add entities to those on which given field is spanning.</p>
<div class="fragment"><div class="line">MoFEMErrorCode <a class="code hl_function" href="struct_mix_transport_1_1_mix_transport_element.html#ab0d84b9fc47b6ae62dad8f4ada3757cd">MixTransport::MixTransportElement::addFields</a>(<span class="keyword">const</span> std::string &amp;values,<span class="keyword">const</span> std::string &amp;fluxes,<span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code hl_variable" href="dg__projection_8cpp.html#ad7eceded84ace5678d9df3e44f47d475">order</a>) {</div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#a6c0b52978f1abc88bf8a1ba70b7308e3">MoFEMFunctionBegin</a>;</div>
<div class="line">  <span class="comment">//Fields</span></div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element.html#a68f344cfbf6b208f5930951ca427f8f7">mField</a>.<a class="code hl_function" href="struct_mo_f_e_m_1_1_core_interface.html#ad0ad06f9662a225c2d5b5570e15d083d">add_field</a>(fluxes,<a class="code hl_enumvalue" href="definitions_8h.html#a5ed4cb303bab8cd0673ae12e5bc73c12ab360a65247d7fe5efc6f3a533d47e5c8">HDIV</a>,<a class="code hl_enumvalue" href="definitions_8h.html#a2ed4ed94b56d2843840bb7c55adcf0c5a9b4f9fbc1a88eda9b2cde0df10ca23bf">DEMKOWICZ_JACOBI_BASE</a>,1); </div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element.html#a68f344cfbf6b208f5930951ca427f8f7">mField</a>.<a class="code hl_function" href="struct_mo_f_e_m_1_1_core_interface.html#ad0ad06f9662a225c2d5b5570e15d083d">add_field</a>(values,<a class="code hl_enumvalue" href="definitions_8h.html#a5ed4cb303bab8cd0673ae12e5bc73c12a0adffb24dae0c41be5b803f4d444f066">L2</a>,<a class="code hl_enumvalue" href="definitions_8h.html#a2ed4ed94b56d2843840bb7c55adcf0c5a54a26843865f4712f50a74fa4f8d025d">AINSWORTH_LEGENDRE_BASE</a>,1); </div>
<div class="line">  <span class="comment">//meshset consisting all entities in mesh</span></div>
<div class="line">  <a class="code hl_class" href="class_entity_handle.html">EntityHandle</a> root_set = <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element.html#a68f344cfbf6b208f5930951ca427f8f7">mField</a>.<a class="code hl_function" href="struct_mo_f_e_m_1_1_core_interface.html#a174e70b67f4f235d096d3c45d865645b">get_moab</a>().get_root_set();</div>
<div class="line">  <span class="comment">//add entities to field</span></div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element.html#a68f344cfbf6b208f5930951ca427f8f7">mField</a>.<a class="code hl_function" href="group__mofem__field.html#gaa584a5c9cc28f5ae0a7088d130683be8">add_ents_to_field_by_type</a>(root_set,MBTET,fluxes); </div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element.html#a68f344cfbf6b208f5930951ca427f8f7">mField</a>.<a class="code hl_function" href="group__mofem__field.html#gaa584a5c9cc28f5ae0a7088d130683be8">add_ents_to_field_by_type</a>(root_set,MBTET,values); </div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element.html#a68f344cfbf6b208f5930951ca427f8f7">mField</a>.<a class="code hl_function" href="group__mofem__field.html#ga86f0c16b69cc30dabc5d7dd292299b07">set_field_order</a>(root_set,MBTET,fluxes,<a class="code hl_variable" href="dg__projection_8cpp.html#ad7eceded84ace5678d9df3e44f47d475">order</a>+1); </div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element.html#a68f344cfbf6b208f5930951ca427f8f7">mField</a>.<a class="code hl_function" href="group__mofem__field.html#ga86f0c16b69cc30dabc5d7dd292299b07">set_field_order</a>(root_set,MBTRI,fluxes,<a class="code hl_variable" href="dg__projection_8cpp.html#ad7eceded84ace5678d9df3e44f47d475">order</a>+1); </div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element.html#a68f344cfbf6b208f5930951ca427f8f7">mField</a>.<a class="code hl_function" href="group__mofem__field.html#ga86f0c16b69cc30dabc5d7dd292299b07">set_field_order</a>(root_set,MBTET,values,<a class="code hl_variable" href="dg__projection_8cpp.html#ad7eceded84ace5678d9df3e44f47d475">order</a>); </div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#acb0a46d159695a01bf667313b7788b45">MoFEMFunctionReturn</a>(0);</div>
<div class="line">}</div>
<div class="ttc" id="aclass_entity_handle_html"><div class="ttname"><a href="class_entity_handle.html">EntityHandle</a></div></div>
<div class="ttc" id="adefinitions_8h_html_a2ed4ed94b56d2843840bb7c55adcf0c5a54a26843865f4712f50a74fa4f8d025d"><div class="ttname"><a href="definitions_8h.html#a2ed4ed94b56d2843840bb7c55adcf0c5a54a26843865f4712f50a74fa4f8d025d">AINSWORTH_LEGENDRE_BASE</a></div><div class="ttdeci">@ AINSWORTH_LEGENDRE_BASE</div><div class="ttdoc">Ainsworth Cole (Legendre) approx. base .</div><div class="ttdef"><b>Definition:</b> <a href="definitions_8h_source.html#l00061">definitions.h:60</a></div></div>
<div class="ttc" id="adefinitions_8h_html_a2ed4ed94b56d2843840bb7c55adcf0c5a9b4f9fbc1a88eda9b2cde0df10ca23bf"><div class="ttname"><a href="definitions_8h.html#a2ed4ed94b56d2843840bb7c55adcf0c5a9b4f9fbc1a88eda9b2cde0df10ca23bf">DEMKOWICZ_JACOBI_BASE</a></div><div class="ttdeci">@ DEMKOWICZ_JACOBI_BASE</div><div class="ttdef"><b>Definition:</b> <a href="definitions_8h_source.html#l00067">definitions.h:66</a></div></div>
<div class="ttc" id="adefinitions_8h_html_a5ed4cb303bab8cd0673ae12e5bc73c12a0adffb24dae0c41be5b803f4d444f066"><div class="ttname"><a href="definitions_8h.html#a5ed4cb303bab8cd0673ae12e5bc73c12a0adffb24dae0c41be5b803f4d444f066">L2</a></div><div class="ttdeci">@ L2</div><div class="ttdoc">field with C-1 continuity</div><div class="ttdef"><b>Definition:</b> <a href="definitions_8h_source.html#l00088">definitions.h:88</a></div></div>
<div class="ttc" id="adefinitions_8h_html_a5ed4cb303bab8cd0673ae12e5bc73c12ab360a65247d7fe5efc6f3a533d47e5c8"><div class="ttname"><a href="definitions_8h.html#a5ed4cb303bab8cd0673ae12e5bc73c12ab360a65247d7fe5efc6f3a533d47e5c8">HDIV</a></div><div class="ttdeci">@ HDIV</div><div class="ttdoc">field with continuous normal traction</div><div class="ttdef"><b>Definition:</b> <a href="definitions_8h_source.html#l00087">definitions.h:87</a></div></div>
<div class="ttc" id="adefinitions_8h_html_a6c0b52978f1abc88bf8a1ba70b7308e3"><div class="ttname"><a href="definitions_8h.html#a6c0b52978f1abc88bf8a1ba70b7308e3">MoFEMFunctionBegin</a></div><div class="ttdeci">#define MoFEMFunctionBegin</div><div class="ttdoc">First executable line of each MoFEM function, used for error handling. Final line of MoFEM functions ...</div><div class="ttdef"><b>Definition:</b> <a href="definitions_8h_source.html#l00346">definitions.h:346</a></div></div>
<div class="ttc" id="adefinitions_8h_html_acb0a46d159695a01bf667313b7788b45"><div class="ttname"><a href="definitions_8h.html#acb0a46d159695a01bf667313b7788b45">MoFEMFunctionReturn</a></div><div class="ttdeci">#define MoFEMFunctionReturn(a)</div><div class="ttdoc">Last executable line of each PETSc function used for error handling. Replaces return()</div><div class="ttdef"><b>Definition:</b> <a href="definitions_8h_source.html#l00416">definitions.h:416</a></div></div>
<div class="ttc" id="agroup__mofem__field_html_ga86f0c16b69cc30dabc5d7dd292299b07"><div class="ttname"><a href="group__mofem__field.html#ga86f0c16b69cc30dabc5d7dd292299b07">MoFEM::CoreInterface::set_field_order</a></div><div class="ttdeci">virtual MoFEMErrorCode set_field_order(const EntityHandle meshset, const EntityType type, const std::string &amp;name, const ApproximationOrder order, int verb=DEFAULT_VERBOSITY)=0</div><div class="ttdoc">Set order approximation of the entities in the field.</div></div>
<div class="ttc" id="agroup__mofem__field_html_gaa584a5c9cc28f5ae0a7088d130683be8"><div class="ttname"><a href="group__mofem__field.html#gaa584a5c9cc28f5ae0a7088d130683be8">MoFEM::CoreInterface::add_ents_to_field_by_type</a></div><div class="ttdeci">virtual MoFEMErrorCode add_ents_to_field_by_type(const Range &amp;ents, const EntityType type, const std::string &amp;name, int verb=DEFAULT_VERBOSITY)=0</div><div class="ttdoc">Add entities to field meshset.</div></div>
<div class="ttc" id="astruct_mix_transport_1_1_mix_transport_element_html_a68f344cfbf6b208f5930951ca427f8f7"><div class="ttname"><a href="struct_mix_transport_1_1_mix_transport_element.html#a68f344cfbf6b208f5930951ca427f8f7">MixTransport::MixTransportElement::mField</a></div><div class="ttdeci">MoFEM::Interface &amp; mField</div><div class="ttdef"><b>Definition:</b> <a href="_mix_transport_element_8hpp_source.html#l00031">MixTransportElement.hpp:31</a></div></div>
<div class="ttc" id="astruct_mix_transport_1_1_mix_transport_element_html_ab0d84b9fc47b6ae62dad8f4ada3757cd"><div class="ttname"><a href="struct_mix_transport_1_1_mix_transport_element.html#ab0d84b9fc47b6ae62dad8f4ada3757cd">MixTransport::MixTransportElement::addFields</a></div><div class="ttdeci">MoFEMErrorCode addFields(const std::string &amp;values, const std::string &amp;fluxes, const int order)</div><div class="ttdoc">Add fields to database.</div><div class="ttdef"><b>Definition:</b> <a href="_mix_transport_element_8hpp_source.html#l00189">MixTransportElement.hpp:189</a></div></div>
<div class="ttc" id="astruct_mo_f_e_m_1_1_core_interface_html_a174e70b67f4f235d096d3c45d865645b"><div class="ttname"><a href="struct_mo_f_e_m_1_1_core_interface.html#a174e70b67f4f235d096d3c45d865645b">MoFEM::CoreInterface::get_moab</a></div><div class="ttdeci">virtual moab::Interface &amp; get_moab()=0</div></div>
<div class="ttc" id="astruct_mo_f_e_m_1_1_core_interface_html_ad0ad06f9662a225c2d5b5570e15d083d"><div class="ttname"><a href="struct_mo_f_e_m_1_1_core_interface.html#ad0ad06f9662a225c2d5b5570e15d083d">MoFEM::CoreInterface::add_field</a></div><div class="ttdeci">virtual MoFEMErrorCode add_field(const std::string &amp;name, const FieldSpace space, const FieldApproximationBase base, const FieldCoefficientsNumber nb_of_coefficients, const TagType tag_type=MB_TAG_SPARSE, const enum MoFEMTypes bh=MF_EXCL, int verb=DEFAULT_VERBOSITY)=0</div><div class="ttdoc">Add field.</div></div>
</div><!-- fragment --><p >Note that in the first two lines we declare two fields <em>FLUXES</em> and <em>VALUES</em>. We define fields, by setting space to HDIV and L2, respectively. The fourth argument in functions <a class="el" href="struct_mo_f_e_m_1_1_core_interface.html#ad0ad06f9662a225c2d5b5570e15d083d" title="Add field.">MoFEM::Interface::add_field</a> sets number of coefficients. Since we have vector and scalar field, number of coefficients is 1. If for example we would like to have second rank field for HDIV space and vector field for L2 space, number of coefficients would be three. Note that in general case you can set the field on part of the mesh and on some part it could be 3d field, 2d or 1d.</p>
<p >Function MoFEM::Interface::add_ents_to_field_by_TETs adds entities to a field, in this case, we like to solve the problem on whole mesh, so all entities from root meshset are added. Since we span that field on tetrahedra and all lower entities field is in 3d. The dimension of field is dictated by a dimension of entities.</p>
<h2><a class="anchor" id="mixtransport_add_elements"></a>
Adding elements to the database (ufe.addFiniteElements)</h2>
<p >In the following part of the code we declare finite elements, implementation of elements is done separately. By definition of finite elements, we are simply telling code on what fields given finite element operates. Domain of elements, i.e. entities on which elements integrate operators could be declared on the part of the mesh where the field is given. If you declare element on entities on which fields is no spanning, that element will have zero number of degrees of freedom.</p>
<p >In this example, we have four kinds of finite elements <em>MIX</em>, <em>MIX_SKELETON</em>, <em>MIX_BCVALUE</em> and <em>MIX_BCFLUX</em>.</p>
<ul>
<li><em>MIX</em> finite element is used to integrate over volume; it allows us to calculate stiffness matrix and the right-hand side vector.</li>
<li><em>MIX_SKELETON</em> finite element is used to integrate over the skeleton, i.e. faces between elements. We are using it to calculate jumps of the values to evaluate the solution error.</li>
<li><em>MIX_BCVALUE</em> finite element is used to integrate over faces where Dirichlet (natural) boundary conditions are declared. The values integrated on that element are assembled into the right-hand side vector.</li>
<li><em>MIX_BCFLUX</em> is the finite element to calculate degrees of freedom where flux boundary conditions are declared. This element works on faces. Note that in mix transport formulation Neumann boundary conditions are essential.</li>
</ul>
<div class="fragment"><div class="line">MoFEMErrorCode <a class="code hl_function" href="struct_mix_transport_1_1_mix_transport_element.html#a89ea626d7665b79ea49f078e2c129e4f">MixTransport::MixTransportElement::addFiniteElements</a>(</div>
<div class="line">  <span class="keyword">const</span> std::string &amp;fluxes_name,</div>
<div class="line">  <span class="keyword">const</span> std::string &amp;values_name</div>
<div class="line">) {</div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#a6c0b52978f1abc88bf8a1ba70b7308e3">MoFEMFunctionBegin</a>;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Set up volume element operators. Operators are used to calculate components</span></div>
<div class="line">  <span class="comment">// of stiffness matrix &amp; right hand side, in essence are used to do volume integrals over</span></div>
<div class="line">  <span class="comment">// tetrahedral in this case.</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Declare element &quot;MIX&quot;. Note that this element will work with fluxes_name and</span></div>
<div class="line">  <span class="comment">// values_name. This reflect bilinear form for the problem</span></div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element.html#a68f344cfbf6b208f5930951ca427f8f7">mField</a>.<a class="code hl_function" href="group__mofem__fe.html#ga4a5b822f605f1a4faa668595a3f2a5ae">add_finite_element</a>(<span class="stringliteral">&quot;MIX&quot;</span>,<a class="code hl_enumvalue" href="definitions_8h.html#a2c740dc34f8edf00c432912eaa5484c1a0bb920c38e835e0fbae45b0c0c029264">MF_ZERO</a>); </div>
<div class="line">  <span class="comment">// Define element</span></div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element.html#a68f344cfbf6b208f5930951ca427f8f7">mField</a>.<a class="code hl_function" href="group__mofem__fe.html#gad29d66fc5706d3b20e4acd02eac81c9d">modify_finite_element_add_field_row</a>(<span class="stringliteral">&quot;MIX&quot;</span>,fluxes_name); </div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element.html#a68f344cfbf6b208f5930951ca427f8f7">mField</a>.<a class="code hl_function" href="group__mofem__fe.html#ga8a9935d6f31d07ed365e6cc76bd041d2">modify_finite_element_add_field_col</a>(<span class="stringliteral">&quot;MIX&quot;</span>,fluxes_name); </div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element.html#a68f344cfbf6b208f5930951ca427f8f7">mField</a>.<a class="code hl_function" href="group__mofem__fe.html#gad29d66fc5706d3b20e4acd02eac81c9d">modify_finite_element_add_field_row</a>(<span class="stringliteral">&quot;MIX&quot;</span>,values_name); </div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element.html#a68f344cfbf6b208f5930951ca427f8f7">mField</a>.<a class="code hl_function" href="group__mofem__fe.html#ga8a9935d6f31d07ed365e6cc76bd041d2">modify_finite_element_add_field_col</a>(<span class="stringliteral">&quot;MIX&quot;</span>,values_name); </div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element.html#a68f344cfbf6b208f5930951ca427f8f7">mField</a>.<a class="code hl_function" href="group__mofem__fe.html#gaa2337ef6cebd2ecb83e4c3eb5e5e1090">modify_finite_element_add_field_data</a>(<span class="stringliteral">&quot;MIX&quot;</span>,fluxes_name); </div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element.html#a68f344cfbf6b208f5930951ca427f8f7">mField</a>.<a class="code hl_function" href="group__mofem__fe.html#gaa2337ef6cebd2ecb83e4c3eb5e5e1090">modify_finite_element_add_field_data</a>(<span class="stringliteral">&quot;MIX&quot;</span>,values_name); </div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Declare finite element to integrate over skeleton, we need that to evaluate error</span></div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element.html#a68f344cfbf6b208f5930951ca427f8f7">mField</a>.<a class="code hl_function" href="group__mofem__fe.html#ga4a5b822f605f1a4faa668595a3f2a5ae">add_finite_element</a>(<span class="stringliteral">&quot;MIX_SKELETON&quot;</span>,<a class="code hl_enumvalue" href="definitions_8h.html#a2c740dc34f8edf00c432912eaa5484c1a0bb920c38e835e0fbae45b0c0c029264">MF_ZERO</a>); </div>
<div class="line">  <span class="comment">// Define element</span></div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element.html#a68f344cfbf6b208f5930951ca427f8f7">mField</a>.<a class="code hl_function" href="group__mofem__fe.html#gad29d66fc5706d3b20e4acd02eac81c9d">modify_finite_element_add_field_row</a>(<span class="stringliteral">&quot;MIX_SKELETON&quot;</span>,fluxes_name); </div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element.html#a68f344cfbf6b208f5930951ca427f8f7">mField</a>.<a class="code hl_function" href="group__mofem__fe.html#ga8a9935d6f31d07ed365e6cc76bd041d2">modify_finite_element_add_field_col</a>(<span class="stringliteral">&quot;MIX_SKELETON&quot;</span>,fluxes_name); </div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element.html#a68f344cfbf6b208f5930951ca427f8f7">mField</a>.<a class="code hl_function" href="group__mofem__fe.html#gaa2337ef6cebd2ecb83e4c3eb5e5e1090">modify_finite_element_add_field_data</a>(<span class="stringliteral">&quot;MIX_SKELETON&quot;</span>,fluxes_name); </div>
<div class="line"> </div>
<div class="line">  <span class="comment">// In some cases you like to use HO geometry to describe shape of the body, curved edges and faces, for</span></div>
<div class="line">  <span class="comment">// example body is a sphere. HO geometry is approximated by a field,  which can be hierarchical, so shape of</span></div>
<div class="line">  <span class="comment">// the edges could be given by polynomial of arbitrary order.</span></div>
<div class="line">  <span class="comment">//</span></div>
<div class="line">  <span class="comment">// Check if field &quot;mesh_nodals_positions&quot; is declared, and if it is add that field to data of finite</span></div>
<div class="line">  <span class="comment">// element. MoFEM will use that that to calculate Jacobian as result that geometry in nonlinear.</span></div>
<div class="line">  <span class="keywordflow">if</span>(<a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element.html#a68f344cfbf6b208f5930951ca427f8f7">mField</a>.<a class="code hl_function" href="group__mofem__field.html#gad43a6631f7d465ad31403cbb1d1896ba">check_field</a>(mesh_nodals_positions)) {</div>
<div class="line">    <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element.html#a68f344cfbf6b208f5930951ca427f8f7">mField</a>.<a class="code hl_function" href="group__mofem__fe.html#gaa2337ef6cebd2ecb83e4c3eb5e5e1090">modify_finite_element_add_field_data</a>(<span class="stringliteral">&quot;MIX&quot;</span>,mesh_nodals_positions); </div>
<div class="line">    <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element.html#a68f344cfbf6b208f5930951ca427f8f7">mField</a>.<a class="code hl_function" href="group__mofem__fe.html#gaa2337ef6cebd2ecb83e4c3eb5e5e1090">modify_finite_element_add_field_data</a>(<span class="stringliteral">&quot;MIX_SKELETON&quot;</span>,mesh_nodals_positions); </div>
<div class="line">  }</div>
<div class="line">  <span class="comment">// Look for all BLOCKSET which are MAT_THERMALSET, takes entities from those BLOCKSETS</span></div>
<div class="line">  <span class="comment">// and add them to &quot;MIX&quot; finite element. In addition get data from that meshset</span></div>
<div class="line">  <span class="comment">// and set cOnductivity which is used to calculate fluxes from gradients of concentration</span></div>
<div class="line">  <span class="comment">// or gradient of temperature, depending how you interpret variables.</span></div>
<div class="line">  <span class="keywordflow">for</span>(<a class="code hl_define" href="group__mofem__meshset__mng.html#ga6bd6335f024a22cde370ee807d9185ce">_IT_CUBITMESHSETS_BY_BCDATA_TYPE_FOR_LOOP_</a>(<a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element.html#a68f344cfbf6b208f5930951ca427f8f7">mField</a>,<a class="code hl_enumvalue" href="definitions_8h.html#a82340fd7aca566defb002f93cc299efcac77b6cdcfb446c668fd1d7c66cfd15ab">BLOCKSET</a>|<a class="code hl_enumvalue" href="definitions_8h.html#a82340fd7aca566defb002f93cc299efcab252879df2031e9811d4134fdc98342f">MAT_THERMALSET</a>,it)) {</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// cerr &lt;&lt; *it &lt;&lt; endl;</span></div>
<div class="line"> </div>
<div class="line">    Mat_Thermal temp_data;</div>
<div class="line">    <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> it-&gt;getAttributeDataStructure(temp_data); </div>
<div class="line">    <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element.html#ad15e79dabce530573193673e2ab3ecd7">setOfBlocks</a>[it-&gt;getMeshsetId()].cOnductivity = temp_data.data.Conductivity;</div>
<div class="line">    <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element.html#ad15e79dabce530573193673e2ab3ecd7">setOfBlocks</a>[it-&gt;getMeshsetId()].cApacity = temp_data.data.HeatCapacity;</div>
<div class="line">    <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element.html#a68f344cfbf6b208f5930951ca427f8f7">mField</a>.<a class="code hl_function" href="struct_mo_f_e_m_1_1_core_interface.html#a174e70b67f4f235d096d3c45d865645b">get_moab</a>().get_entities_by_type(</div>
<div class="line">      it-&gt;meshset,MBTET,<a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element.html#ad15e79dabce530573193673e2ab3ecd7">setOfBlocks</a>[it-&gt;getMeshsetId()].tEts,<span class="keyword">true</span></div>
<div class="line">    ); </div>
<div class="line">    <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element.html#a68f344cfbf6b208f5930951ca427f8f7">mField</a>.add_ents_to_finite_element_by_TETs(</div>
<div class="line">      <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element.html#ad15e79dabce530573193673e2ab3ecd7">setOfBlocks</a>[it-&gt;getMeshsetId()].tEts,<span class="stringliteral">&quot;MIX&quot;</span></div>
<div class="line">    ); </div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="class_range.html">Range</a> skeleton;</div>
<div class="line">    <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element.html#a68f344cfbf6b208f5930951ca427f8f7">mField</a>.<a class="code hl_function" href="struct_mo_f_e_m_1_1_core_interface.html#a174e70b67f4f235d096d3c45d865645b">get_moab</a>().get_adjacencies(</div>
<div class="line">      <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element.html#ad15e79dabce530573193673e2ab3ecd7">setOfBlocks</a>[it-&gt;getMeshsetId()].tEts,2,<span class="keyword">false</span>,skeleton,moab::Interface::UNION</div>
<div class="line">    );</div>
<div class="line">    <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element.html#a68f344cfbf6b208f5930951ca427f8f7">mField</a>.<a class="code hl_function" href="group__mofem__fe.html#ga8b068eced1fd720631edcaea59289a15">add_ents_to_finite_element_by_type</a>(</div>
<div class="line">      skeleton,MBTRI,<span class="stringliteral">&quot;MIX_SKELETON&quot;</span></div>
<div class="line">    ); </div>
<div class="line"> </div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Declare element to integrate natural boundary conditions, i.e. set values.</span></div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element.html#a68f344cfbf6b208f5930951ca427f8f7">mField</a>.<a class="code hl_function" href="group__mofem__fe.html#ga4a5b822f605f1a4faa668595a3f2a5ae">add_finite_element</a>(<span class="stringliteral">&quot;MIX_BCVALUE&quot;</span>,<a class="code hl_enumvalue" href="definitions_8h.html#a2c740dc34f8edf00c432912eaa5484c1a0bb920c38e835e0fbae45b0c0c029264">MF_ZERO</a>); </div>
<div class="line">  <span class="comment">// Define element</span></div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element.html#a68f344cfbf6b208f5930951ca427f8f7">mField</a>.<a class="code hl_function" href="group__mofem__fe.html#gad29d66fc5706d3b20e4acd02eac81c9d">modify_finite_element_add_field_row</a>(<span class="stringliteral">&quot;MIX_BCVALUE&quot;</span>,fluxes_name); </div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element.html#a68f344cfbf6b208f5930951ca427f8f7">mField</a>.<a class="code hl_function" href="group__mofem__fe.html#ga8a9935d6f31d07ed365e6cc76bd041d2">modify_finite_element_add_field_col</a>(<span class="stringliteral">&quot;MIX_BCVALUE&quot;</span>,fluxes_name); </div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element.html#a68f344cfbf6b208f5930951ca427f8f7">mField</a>.<a class="code hl_function" href="group__mofem__fe.html#gaa2337ef6cebd2ecb83e4c3eb5e5e1090">modify_finite_element_add_field_data</a>(<span class="stringliteral">&quot;MIX_BCVALUE&quot;</span>,fluxes_name); </div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element.html#a68f344cfbf6b208f5930951ca427f8f7">mField</a>.<a class="code hl_function" href="group__mofem__fe.html#gaa2337ef6cebd2ecb83e4c3eb5e5e1090">modify_finite_element_add_field_data</a>(<span class="stringliteral">&quot;MIX_BCVALUE&quot;</span>,values_name); </div>
<div class="line">  <span class="keywordflow">if</span>(<a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element.html#a68f344cfbf6b208f5930951ca427f8f7">mField</a>.<a class="code hl_function" href="group__mofem__field.html#gad43a6631f7d465ad31403cbb1d1896ba">check_field</a>(mesh_nodals_positions)) {</div>
<div class="line">    <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element.html#a68f344cfbf6b208f5930951ca427f8f7">mField</a>.<a class="code hl_function" href="group__mofem__fe.html#gaa2337ef6cebd2ecb83e4c3eb5e5e1090">modify_finite_element_add_field_data</a>(<span class="stringliteral">&quot;MIX_BCVALUE&quot;</span>,mesh_nodals_positions); </div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Declare element to apply essential boundary conditions.</span></div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element.html#a68f344cfbf6b208f5930951ca427f8f7">mField</a>.<a class="code hl_function" href="group__mofem__fe.html#ga4a5b822f605f1a4faa668595a3f2a5ae">add_finite_element</a>(<span class="stringliteral">&quot;MIX_BCFLUX&quot;</span>,<a class="code hl_enumvalue" href="definitions_8h.html#a2c740dc34f8edf00c432912eaa5484c1a0bb920c38e835e0fbae45b0c0c029264">MF_ZERO</a>); </div>
<div class="line">  <span class="comment">// Define element</span></div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element.html#a68f344cfbf6b208f5930951ca427f8f7">mField</a>.<a class="code hl_function" href="group__mofem__fe.html#gad29d66fc5706d3b20e4acd02eac81c9d">modify_finite_element_add_field_row</a>(<span class="stringliteral">&quot;MIX_BCFLUX&quot;</span>,fluxes_name); </div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element.html#a68f344cfbf6b208f5930951ca427f8f7">mField</a>.<a class="code hl_function" href="group__mofem__fe.html#ga8a9935d6f31d07ed365e6cc76bd041d2">modify_finite_element_add_field_col</a>(<span class="stringliteral">&quot;MIX_BCFLUX&quot;</span>,fluxes_name); </div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element.html#a68f344cfbf6b208f5930951ca427f8f7">mField</a>.<a class="code hl_function" href="group__mofem__fe.html#gaa2337ef6cebd2ecb83e4c3eb5e5e1090">modify_finite_element_add_field_data</a>(<span class="stringliteral">&quot;MIX_BCFLUX&quot;</span>,fluxes_name); </div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element.html#a68f344cfbf6b208f5930951ca427f8f7">mField</a>.<a class="code hl_function" href="group__mofem__fe.html#gaa2337ef6cebd2ecb83e4c3eb5e5e1090">modify_finite_element_add_field_data</a>(<span class="stringliteral">&quot;MIX_BCFLUX&quot;</span>,values_name); </div>
<div class="line">  <span class="keywordflow">if</span>(<a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element.html#a68f344cfbf6b208f5930951ca427f8f7">mField</a>.<a class="code hl_function" href="group__mofem__field.html#gad43a6631f7d465ad31403cbb1d1896ba">check_field</a>(mesh_nodals_positions)) {</div>
<div class="line">    <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element.html#a68f344cfbf6b208f5930951ca427f8f7">mField</a>.<a class="code hl_function" href="group__mofem__fe.html#gaa2337ef6cebd2ecb83e4c3eb5e5e1090">modify_finite_element_add_field_data</a>(<span class="stringliteral">&quot;MIX_BCFLUX&quot;</span>,mesh_nodals_positions); </div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#acb0a46d159695a01bf667313b7788b45">MoFEMFunctionReturn</a>(0);</div>
<div class="line">}</div>
<div class="ttc" id="aclass_range_html"><div class="ttname"><a href="class_range.html">Range</a></div></div>
<div class="ttc" id="adefinitions_8h_html_a2c740dc34f8edf00c432912eaa5484c1a0bb920c38e835e0fbae45b0c0c029264"><div class="ttname"><a href="definitions_8h.html#a2c740dc34f8edf00c432912eaa5484c1a0bb920c38e835e0fbae45b0c0c029264">MF_ZERO</a></div><div class="ttdeci">@ MF_ZERO</div><div class="ttdef"><b>Definition:</b> <a href="definitions_8h_source.html#l00098">definitions.h:98</a></div></div>
<div class="ttc" id="adefinitions_8h_html_a82340fd7aca566defb002f93cc299efcab252879df2031e9811d4134fdc98342f"><div class="ttname"><a href="definitions_8h.html#a82340fd7aca566defb002f93cc299efcab252879df2031e9811d4134fdc98342f">MAT_THERMALSET</a></div><div class="ttdeci">@ MAT_THERMALSET</div><div class="ttdoc">block name is &quot;MAT_THERMAL&quot;</div><div class="ttdef"><b>Definition:</b> <a href="definitions_8h_source.html#l00161">definitions.h:161</a></div></div>
<div class="ttc" id="adefinitions_8h_html_a82340fd7aca566defb002f93cc299efcac77b6cdcfb446c668fd1d7c66cfd15ab"><div class="ttname"><a href="definitions_8h.html#a82340fd7aca566defb002f93cc299efcac77b6cdcfb446c668fd1d7c66cfd15ab">BLOCKSET</a></div><div class="ttdeci">@ BLOCKSET</div><div class="ttdef"><b>Definition:</b> <a href="definitions_8h_source.html#l00148">definitions.h:148</a></div></div>
<div class="ttc" id="agroup__mofem__fe_html_ga4a5b822f605f1a4faa668595a3f2a5ae"><div class="ttname"><a href="group__mofem__fe.html#ga4a5b822f605f1a4faa668595a3f2a5ae">MoFEM::CoreInterface::add_finite_element</a></div><div class="ttdeci">virtual MoFEMErrorCode add_finite_element(const std::string &amp;fe_name, enum MoFEMTypes bh=MF_EXCL, int verb=DEFAULT_VERBOSITY)=0</div><div class="ttdoc">add finite element</div></div>
<div class="ttc" id="agroup__mofem__fe_html_ga8a9935d6f31d07ed365e6cc76bd041d2"><div class="ttname"><a href="group__mofem__fe.html#ga8a9935d6f31d07ed365e6cc76bd041d2">MoFEM::CoreInterface::modify_finite_element_add_field_col</a></div><div class="ttdeci">virtual MoFEMErrorCode modify_finite_element_add_field_col(const std::string &amp;fe_name, const std::string name_row)=0</div><div class="ttdoc">set field col which finite element use</div></div>
<div class="ttc" id="agroup__mofem__fe_html_ga8b068eced1fd720631edcaea59289a15"><div class="ttname"><a href="group__mofem__fe.html#ga8b068eced1fd720631edcaea59289a15">MoFEM::CoreInterface::add_ents_to_finite_element_by_type</a></div><div class="ttdeci">virtual MoFEMErrorCode add_ents_to_finite_element_by_type(const EntityHandle entities, const EntityType type, const std::string &amp;name, const bool recursive=true)=0</div><div class="ttdoc">add entities to finite element</div></div>
<div class="ttc" id="agroup__mofem__fe_html_gaa2337ef6cebd2ecb83e4c3eb5e5e1090"><div class="ttname"><a href="group__mofem__fe.html#gaa2337ef6cebd2ecb83e4c3eb5e5e1090">MoFEM::CoreInterface::modify_finite_element_add_field_data</a></div><div class="ttdeci">virtual MoFEMErrorCode modify_finite_element_add_field_data(const std::string &amp;fe_name, const std::string name_filed)=0</div><div class="ttdoc">set finite element field data</div></div>
<div class="ttc" id="agroup__mofem__fe_html_gad29d66fc5706d3b20e4acd02eac81c9d"><div class="ttname"><a href="group__mofem__fe.html#gad29d66fc5706d3b20e4acd02eac81c9d">MoFEM::CoreInterface::modify_finite_element_add_field_row</a></div><div class="ttdeci">virtual MoFEMErrorCode modify_finite_element_add_field_row(const std::string &amp;fe_name, const std::string name_row)=0</div><div class="ttdoc">set field row which finite element use</div></div>
<div class="ttc" id="agroup__mofem__field_html_gad43a6631f7d465ad31403cbb1d1896ba"><div class="ttname"><a href="group__mofem__field.html#gad43a6631f7d465ad31403cbb1d1896ba">MoFEM::CoreInterface::check_field</a></div><div class="ttdeci">virtual bool check_field(const std::string &amp;name) const =0</div><div class="ttdoc">check if field is in database</div></div>
<div class="ttc" id="agroup__mofem__meshset__mng_html_ga6bd6335f024a22cde370ee807d9185ce"><div class="ttname"><a href="group__mofem__meshset__mng.html#ga6bd6335f024a22cde370ee807d9185ce">_IT_CUBITMESHSETS_BY_BCDATA_TYPE_FOR_LOOP_</a></div><div class="ttdeci">#define _IT_CUBITMESHSETS_BY_BCDATA_TYPE_FOR_LOOP_(MESHSET_MANAGER, CUBITBCTYPE, IT)</div><div class="ttdoc">Iterator that loops over a specific Cubit MeshSet in a moFEM field.</div><div class="ttdef"><b>Definition:</b> <a href="_meshsets_manager_8hpp_source.html#l00049">MeshsetsManager.hpp:49</a></div></div>
<div class="ttc" id="astruct_mix_transport_1_1_mix_transport_element_html_a89ea626d7665b79ea49f078e2c129e4f"><div class="ttname"><a href="struct_mix_transport_1_1_mix_transport_element.html#a89ea626d7665b79ea49f078e2c129e4f">MixTransport::MixTransportElement::addFiniteElements</a></div><div class="ttdeci">MoFEMErrorCode addFiniteElements(const std::string &amp;fluxes_name, const std::string &amp;values_name)</div><div class="ttdoc">add finite elements</div><div class="ttdef"><b>Definition:</b> <a href="_mix_transport_element_8hpp_source.html#l00208">MixTransportElement.hpp:208</a></div></div>
<div class="ttc" id="astruct_mix_transport_1_1_mix_transport_element_html_ad15e79dabce530573193673e2ab3ecd7"><div class="ttname"><a href="struct_mix_transport_1_1_mix_transport_element.html#ad15e79dabce530573193673e2ab3ecd7">MixTransport::MixTransportElement::setOfBlocks</a></div><div class="ttdeci">std::map&lt; int, BlockData &gt; setOfBlocks</div><div class="ttdoc">maps block set id with appropriate BlockData</div><div class="ttdef"><b>Definition:</b> <a href="_mix_transport_element_8hpp_source.html#l00180">MixTransportElement.hpp:180</a></div></div>
</div><!-- fragment --><p >Function <a class="el" href="group__mofem__fe.html#ga4a5b822f605f1a4faa668595a3f2a5ae" title="add finite element">MoFEM::Interface::add_finite_element</a> adds the element of given name to the database, the second argument indicates that if the element of such name already exists do not throw the error. When the second argument is not given default behaviour is that error is thrown if the element already exists.</p>
<p >Function <a class="el" href="group__mofem__fe.html#gad29d66fc5706d3b20e4acd02eac81c9d" title="set field row which finite element use">MoFEM::Interface::modify_finite_element_add_field_row</a>, <a class="el" href="group__mofem__fe.html#ga8a9935d6f31d07ed365e6cc76bd041d2" title="set field col which finite element use">MoFEM::Interface::modify_finite_element_add_field_col</a> and <a class="el" href="group__mofem__fe.html#gaa2337ef6cebd2ecb83e4c3eb5e5e1090" title="set finite element field data">MoFEM::Interface::modify_finite_element_add_field_data</a> define on what fields given element operates. You can think that this corresponds how you define the bilinear form for your operator, what is the first and second argument. Also, you specify data, for example, permeability could be given as a separate field which needs to be evaluated at integration points to assemble matrix. In that case you add that information using <a class="el" href="group__mofem__fe.html#gaa2337ef6cebd2ecb83e4c3eb5e5e1090" title="set finite element field data">MoFEM::Interface::modify_finite_element_add_field_data</a>.</p>
<p >Function <a class="el" href="group__mofem__fe.html#ga8b068eced1fd720631edcaea59289a15" title="add entities to finite element">MoFEM::Interface::add_ents_to_finite_element_by_type</a> adds tetrahedral and triangles to given element respectively. You can think about tetrahedral and triangles as domains on which you perform the integration. Note that field can be spanned on tetrahedral (3d entities) but you can integrate on triangles, then on such element trace of field on the triangle is available from that element.</p>
<p >Note part of the code </p><div class="fragment"><div class="line"><span class="keywordflow">for</span>(<a class="code hl_define" href="group__mofem__meshset__mng.html#ga6bd6335f024a22cde370ee807d9185ce">_IT_CUBITMESHSETS_BY_BCDATA_TYPE_FOR_LOOP_</a>(mField,<a class="code hl_enumvalue" href="definitions_8h.html#a82340fd7aca566defb002f93cc299efcac77b6cdcfb446c668fd1d7c66cfd15ab">BLOCKSET</a>|<a class="code hl_enumvalue" href="definitions_8h.html#a82340fd7aca566defb002f93cc299efcab252879df2031e9811d4134fdc98342f">MAT_THERMALSET</a>,it)) {</div>
<div class="line"> </div>
<div class="line">}</div>
</div><!-- fragment --><p> which iterates over all BLOCKSETs on which MAT_THERMALSET is defined, then it gets information about material parameters and range of tetrahedral entities in that block. Next, it adds those tetrahedral to <em>MIX</em> finite element. In addition, it takes all adjacent triangles to tetrahedra and adds those entities to <em>MIX_SKELETON</em> finite element.</p>
<p >Adding elements to <em>MIX_BCVALUE</em> and <em>MIX_BCFLUX</em> is implemented in the next section. In above code, those finite elements are only declared and defined, but not yet implemented. Declaration, definition and implementation are independent of each other. You can use two different implementations of the same element.</p>
<h2><a class="anchor" id="mixtransport_add_bc_elements"></a>
Adding boundary elements to the database (ufe.addBoundaryElements)</h2>
<p >In ExampleMix::addBoundaryElements, loop over boundary BLOCKSETs is made to get triangles in that BLOCKSET. Then appropriate triangles are added to <em>MIX_BCVALUE</em> and <em>MIX_BCFLUX</em> </p><div class="fragment"><div class="line">MoFEMErrorCode ExampleMix::addBoundaryElements(BitRefLevel &amp;ref_level) {</div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#a6c0b52978f1abc88bf8a1ba70b7308e3">MoFEMFunctionBegin</a>;</div>
<div class="line">  <a class="code hl_class" href="class_range.html">Range</a> tets;</div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> mField.getInterface&lt;BitRefManager&gt;()-&gt;getEntitiesByTypeAndRefLevel(ref_level,BitRefLevel().set(),MBTET,tets);</div>
<div class="line">  Skinner skin(&amp;mField.get_moab());</div>
<div class="line">  <a class="code hl_class" href="class_range.html">Range</a> skin_faces; <span class="comment">// skin faces from 3d ents</span></div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> skin.find_skin(0,tets,<span class="keyword">false</span>,skin_faces); </div>
<div class="line">  <span class="comment">// note: what is essential (dirichlet) is natural (neumann) for mix-FE compared to classical FE</span></div>
<div class="line">  <a class="code hl_class" href="class_range.html">Range</a> natural_bc;</div>
<div class="line">  <span class="keywordflow">for</span>(<a class="code hl_define" href="group__mofem__meshset__mng.html#ga6bd6335f024a22cde370ee807d9185ce">_IT_CUBITMESHSETS_BY_BCDATA_TYPE_FOR_LOOP_</a>(mField,<a class="code hl_enumvalue" href="definitions_8h.html#a82340fd7aca566defb002f93cc299efca7b4c0e5ae1385e1224a6e59abf47ecc0">NODESET</a>|<a class="code hl_enumvalue" href="definitions_8h.html#a82340fd7aca566defb002f93cc299efca038eddfea9b8bcaa794e146b1bbf96ca">TEMPERATURESET</a>,it)) {</div>
<div class="line">    <a class="code hl_class" href="class_range.html">Range</a> tris;</div>
<div class="line">    <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> it-&gt;getMeshsetIdEntitiesByDimension(mField.get_moab(),2,tris,<span class="keyword">true</span>); </div>
<div class="line">    natural_bc.insert(tris.begin(),tris.end());</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">for</span>(<a class="code hl_define" href="group__mofem__meshset__mng.html#ga6bd6335f024a22cde370ee807d9185ce">_IT_CUBITMESHSETS_BY_BCDATA_TYPE_FOR_LOOP_</a>(mField,<a class="code hl_enumvalue" href="definitions_8h.html#a82340fd7aca566defb002f93cc299efca86c05035d6a2fbc5762f39215d6a8a22">SIDESET</a>|<a class="code hl_enumvalue" href="definitions_8h.html#a82340fd7aca566defb002f93cc299efca595e67af5c8ddafbb244182e13d67d67">HEATFLUXSET</a>,it)) {</div>
<div class="line">    HeatFluxCubitBcData mydata;</div>
<div class="line">    <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> it-&gt;getBcDataStructure(mydata); </div>
<div class="line">    <span class="keywordflow">if</span>(mydata.data.flag1==1) {</div>
<div class="line">      <a class="code hl_class" href="class_range.html">Range</a> tris;</div>
<div class="line">      <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> it-&gt;getMeshsetIdEntitiesByDimension(mField.get_moab(),2,tris,<span class="keyword">true</span>); </div>
<div class="line">      bcFluxMap[it-&gt;getMeshsetId()].eNts = tris;</div>
<div class="line">      bcFluxMap[it-&gt;getMeshsetId()].fLux = mydata.data.value1;</div>
<div class="line">      <span class="comment">// cerr &lt;&lt; bcFluxMap[it-&gt;getMeshsetId()].eNts &lt;&lt; endl;</span></div>
<div class="line">      <span class="comment">// cerr &lt;&lt; bcFluxMap[it-&gt;getMeshsetId()].fLux &lt;&lt; endl;</span></div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">  <a class="code hl_class" href="class_range.html">Range</a> essential_bc = subtract(skin_faces,natural_bc);</div>
<div class="line">  <a class="code hl_class" href="class_range.html">Range</a> bit_tris;</div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> mField.getInterface&lt;BitRefManager&gt;()-&gt;getEntitiesByTypeAndRefLevel(ref_level,<a class="code hl_typedef" href="namespace_mo_f_e_m_1_1_types.html#aa9495b406c5326b7bca937846ec421c5">BitRefLevel</a>().set(),MBTRI,bit_tris);</div>
<div class="line">  essential_bc = intersect(bit_tris,essential_bc);</div>
<div class="line">  natural_bc = intersect(bit_tris,natural_bc);</div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> mField.add_ents_to_finite_element_by_type(essential_bc,MBTRI,<span class="stringliteral">&quot;MIX_BCFLUX&quot;</span>); </div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> mField.add_ents_to_finite_element_by_type(natural_bc,MBTRI,<span class="stringliteral">&quot;MIX_BCVALUE&quot;</span>); </div>
<div class="line">  <span class="comment">// CHKERR mField.add_ents_to_finite_element_by_type(skin_faces,MBTRI,&quot;MIX_BCVALUE&quot;); </span></div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#acb0a46d159695a01bf667313b7788b45">MoFEMFunctionReturn</a>(0);</div>
<div class="line">}</div>
<div class="ttc" id="adefinitions_8h_html_a82340fd7aca566defb002f93cc299efca038eddfea9b8bcaa794e146b1bbf96ca"><div class="ttname"><a href="definitions_8h.html#a82340fd7aca566defb002f93cc299efca038eddfea9b8bcaa794e146b1bbf96ca">TEMPERATURESET</a></div><div class="ttdeci">@ TEMPERATURESET</div><div class="ttdef"><b>Definition:</b> <a href="definitions_8h_source.html#l00155">definitions.h:155</a></div></div>
<div class="ttc" id="adefinitions_8h_html_a82340fd7aca566defb002f93cc299efca595e67af5c8ddafbb244182e13d67d67"><div class="ttname"><a href="definitions_8h.html#a82340fd7aca566defb002f93cc299efca595e67af5c8ddafbb244182e13d67d67">HEATFLUXSET</a></div><div class="ttdeci">@ HEATFLUXSET</div><div class="ttdef"><b>Definition:</b> <a href="definitions_8h_source.html#l00156">definitions.h:156</a></div></div>
<div class="ttc" id="adefinitions_8h_html_a82340fd7aca566defb002f93cc299efca7b4c0e5ae1385e1224a6e59abf47ecc0"><div class="ttname"><a href="definitions_8h.html#a82340fd7aca566defb002f93cc299efca7b4c0e5ae1385e1224a6e59abf47ecc0">NODESET</a></div><div class="ttdeci">@ NODESET</div><div class="ttdef"><b>Definition:</b> <a href="definitions_8h_source.html#l00146">definitions.h:146</a></div></div>
<div class="ttc" id="adefinitions_8h_html_a82340fd7aca566defb002f93cc299efca86c05035d6a2fbc5762f39215d6a8a22"><div class="ttname"><a href="definitions_8h.html#a82340fd7aca566defb002f93cc299efca86c05035d6a2fbc5762f39215d6a8a22">SIDESET</a></div><div class="ttdeci">@ SIDESET</div><div class="ttdef"><b>Definition:</b> <a href="definitions_8h_source.html#l00147">definitions.h:147</a></div></div>
<div class="ttc" id="anamespace_mo_f_e_m_1_1_types_html_aa9495b406c5326b7bca937846ec421c5"><div class="ttname"><a href="namespace_mo_f_e_m_1_1_types.html#aa9495b406c5326b7bca937846ec421c5">MoFEM::Types::BitRefLevel</a></div><div class="ttdeci">std::bitset&lt; BITREFLEVEL_SIZE &gt; BitRefLevel</div><div class="ttdoc">Bit structure attached to each entity identifying to what mesh entity is attached.</div><div class="ttdef"><b>Definition:</b> <a href="_types_8hpp_source.html#l00040">Types.hpp:40</a></div></div>
</div><!-- fragment --><p >Note that, at the end of the above code, the skin from full mesh is taken, i.e. triangle elements on boundary of meshet. Then, triangles on the boundary (skin) on which values or fluxes are not set are used to set zero-flux boundary condition.</p>
<dl class="section note"><dt>Note</dt><dd>For standard finite element formulation, boundary condition on fluxes is natural, so if you have zero flux on the boundary, you have zero value for DOFs on the right-hand side vector. In essence, you do nothing to enforce zero flux. This is not the case here.</dd></dl>
<p>In addition, function </p><div class="fragment"><div class="line">MoFEMErrorCode ExampleMix::getBcOnValues(</div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="class_entity_handle.html">EntityHandle</a> ent,</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> x,<span class="keyword">const</span> <span class="keywordtype">double</span> y,<span class="keyword">const</span> <span class="keywordtype">double</span> z,</div>
<div class="line">  <span class="keywordtype">double</span> &amp;value) {</div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#aee32377dce975c9a64ed73bd3a003404">MoFEMFunctionBeginHot</a>;</div>
<div class="line">  value = 0;</div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#a59cd650c2f6d3e0dc1ad1c29821e8692">MoFEMFunctionReturnHot</a>(0);</div>
<div class="line">}</div>
<div class="ttc" id="adefinitions_8h_html_a59cd650c2f6d3e0dc1ad1c29821e8692"><div class="ttname"><a href="definitions_8h.html#a59cd650c2f6d3e0dc1ad1c29821e8692">MoFEMFunctionReturnHot</a></div><div class="ttdeci">#define MoFEMFunctionReturnHot(a)</div><div class="ttdoc">Last executable line of each PETSc function used for error handling. Replaces return()</div><div class="ttdef"><b>Definition:</b> <a href="definitions_8h_source.html#l00447">definitions.h:447</a></div></div>
<div class="ttc" id="adefinitions_8h_html_aee32377dce975c9a64ed73bd3a003404"><div class="ttname"><a href="definitions_8h.html#aee32377dce975c9a64ed73bd3a003404">MoFEMFunctionBeginHot</a></div><div class="ttdeci">#define MoFEMFunctionBeginHot</div><div class="ttdoc">First executable line of each MoFEM function, used for error handling. Final line of MoFEM functions ...</div><div class="ttdef"><b>Definition:</b> <a href="definitions_8h_source.html#l00440">definitions.h:440</a></div></div>
</div><!-- fragment --><p> and </p><div class="fragment"><div class="line">MoFEMErrorCode ExampleMix::getBcOnFluxes(</div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="class_entity_handle.html">EntityHandle</a> ent,</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> x,<span class="keyword">const</span> <span class="keywordtype">double</span> y,<span class="keyword">const</span> <span class="keywordtype">double</span> z,</div>
<div class="line">  <span class="keywordtype">double</span> &amp;flux) {</div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#a6c0b52978f1abc88bf8a1ba70b7308e3">MoFEMFunctionBegin</a>;</div>
<div class="line">  <span class="keywordflow">if</span>(lastEnt==ent) {</div>
<div class="line">    flux = lastFlux;</div>
<div class="line">  } <span class="keywordflow">else</span> {</div>
<div class="line">    flux = 0;</div>
<div class="line">    <span class="keywordflow">for</span>(BcFluxMap::iterator mit = bcFluxMap.begin();mit!=bcFluxMap.end();mit++) {</div>
<div class="line">      <a class="code hl_class" href="class_range.html">Range</a> &amp;tris = mit-&gt;second.eNts;</div>
<div class="line">      <span class="keywordflow">if</span>(tris.find(ent)!=tris.end()) {</div>
<div class="line">        flux = mit-&gt;second.fLux;</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">    lastEnt = ent;</div>
<div class="line">    lastFlux = flux;</div>
<div class="line">  }</div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#acb0a46d159695a01bf667313b7788b45">MoFEMFunctionReturn</a>(0);</div>
<div class="line">}</div>
</div><!-- fragment --><p> are implemented. Those functions are used to evaluate values and boundary conditions at integration points. For more details how those functions are used look into <a class="el" href="struct_mix_transport_1_1_mix_transport_element_1_1_op_rhs_bc_on_values.html" title="calculate">MixTransport::MixTransportElement::OpRhsBcOnValues</a> and <a class="el" href="struct_mix_transport_1_1_mix_transport_element_1_1_op_evaluate_bc_on_fluxes.html" title="Evaluate boundary conditions on fluxes.">MixTransport::MixTransportElement::OpEvaluateBcOnFluxes</a>, those classes are implementations of operations on particular elements which are later explained.</p>
<h2><a class="anchor" id="mixtransport_build_problem"></a>
Declaring and building problem (ufe.buildProblem)</h2>
<p >Once fields and finite elements are declared and defined, we build/rebuild data structures carrying information needed to do the analysis. Note that function below is general, takes into account that problem could be built on several refinement levels, and if only the necessary part of structures if rebuild in subsequent mesh refinements.</p>
<p >The mesh <a class="el" href="namespace_mo_f_e_m_1_1_types.html#aa9495b406c5326b7bca937846ec421c5" title="Bit structure attached to each entity identifying to what mesh entity is attached.">MoFEM::BitRefLevel</a> and related details with mesh refinement are described in the following sections. Here we focus only on declaring, building and partitioning problem for parallelized calculations.</p>
<p ><a class="el" href="namespace_mo_f_e_m.html" title="implementation of Data Operators for Forces and Sources">MoFEM</a> can work on partitioned meshes and parallel algebra and calculations. However, here we assume that mesh is the same on all processors, only calculations, matrices and vectors are distributed.</p>
<div class="fragment"><div class="line">MoFEMErrorCode <a class="code hl_function" href="struct_mix_transport_1_1_mix_transport_element.html#afc104c3d8a2a02abae3987fec24af4a6">MixTransport::MixTransportElement::buildProblem</a>(BitRefLevel &amp;ref_level) {</div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#a6c0b52978f1abc88bf8a1ba70b7308e3">MoFEMFunctionBegin</a>;</div>
<div class="line">  <span class="comment">//build field</span></div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element.html#a68f344cfbf6b208f5930951ca427f8f7">mField</a>.<a class="code hl_function" href="group__mofem__field.html#ga126ea0bb04802f9d1946435279c3da56">build_fields</a>(); </div>
<div class="line">  <span class="comment">// get tetrahedrons which has been build previously and now in so called garbage bit level</span></div>
<div class="line">  <a class="code hl_class" href="class_range.html">Range</a> done_tets;</div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element.html#a68f344cfbf6b208f5930951ca427f8f7">mField</a>.<a class="code hl_function" href="struct_mo_f_e_m_1_1_unknown_interface.html#a7ab248ec45fca778800dcd92e5171beb">getInterface</a>&lt;BitRefManager&gt;()-&gt;getEntitiesByTypeAndRefLevel(</div>
<div class="line">    BitRefLevel().set(0),BitRefLevel().set(),MBTET,done_tets</div>
<div class="line">  ); </div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element.html#a68f344cfbf6b208f5930951ca427f8f7">mField</a>.<a class="code hl_function" href="struct_mo_f_e_m_1_1_unknown_interface.html#a7ab248ec45fca778800dcd92e5171beb">getInterface</a>&lt;BitRefManager&gt;()-&gt;getEntitiesByTypeAndRefLevel(</div>
<div class="line">    BitRefLevel().set(<a class="code hl_define" href="definitions_8h.html#a3b43531d53059927f420c79cf954561a">BITREFLEVEL_SIZE</a>-1),BitRefLevel().set(),MBTET,done_tets</div>
<div class="line">  ); </div>
<div class="line">  <span class="comment">// get tetrahedrons which belong to problem bit level</span></div>
<div class="line">  <a class="code hl_class" href="class_range.html">Range</a> ref_tets;</div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element.html#a68f344cfbf6b208f5930951ca427f8f7">mField</a>.<a class="code hl_function" href="struct_mo_f_e_m_1_1_unknown_interface.html#a7ab248ec45fca778800dcd92e5171beb">getInterface</a>&lt;BitRefManager&gt;()-&gt;getEntitiesByTypeAndRefLevel(</div>
<div class="line">    ref_level,BitRefLevel().set(),MBTET,ref_tets</div>
<div class="line">  ); </div>
<div class="line">  ref_tets = subtract(ref_tets,done_tets);</div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element.html#a68f344cfbf6b208f5930951ca427f8f7">mField</a>.<a class="code hl_function" href="group__mofem__fe.html#ga735f920686a9c958073ec14ea0dc1da0">build_finite_elements</a>(<span class="stringliteral">&quot;MIX&quot;</span>,&amp;ref_tets,2); </div>
<div class="line">  <span class="comment">// get triangles which has been build previously and now in so called garbage bit level</span></div>
<div class="line">  <a class="code hl_class" href="class_range.html">Range</a> done_faces;</div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element.html#a68f344cfbf6b208f5930951ca427f8f7">mField</a>.<a class="code hl_function" href="struct_mo_f_e_m_1_1_unknown_interface.html#a7ab248ec45fca778800dcd92e5171beb">getInterface</a>&lt;BitRefManager&gt;()-&gt;getEntitiesByTypeAndRefLevel(</div>
<div class="line">    BitRefLevel().set(0),BitRefLevel().set(),MBTRI,done_faces</div>
<div class="line">  ); </div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element.html#a68f344cfbf6b208f5930951ca427f8f7">mField</a>.<a class="code hl_function" href="struct_mo_f_e_m_1_1_unknown_interface.html#a7ab248ec45fca778800dcd92e5171beb">getInterface</a>&lt;BitRefManager&gt;()-&gt;getEntitiesByTypeAndRefLevel(</div>
<div class="line">    BitRefLevel().set(<a class="code hl_define" href="definitions_8h.html#a3b43531d53059927f420c79cf954561a">BITREFLEVEL_SIZE</a>-1),BitRefLevel().set(),MBTRI,done_faces</div>
<div class="line">  ); </div>
<div class="line">  <span class="comment">// get triangles which belong to problem bit level</span></div>
<div class="line">  <a class="code hl_class" href="class_range.html">Range</a> ref_faces;</div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element.html#a68f344cfbf6b208f5930951ca427f8f7">mField</a>.<a class="code hl_function" href="struct_mo_f_e_m_1_1_unknown_interface.html#a7ab248ec45fca778800dcd92e5171beb">getInterface</a>&lt;BitRefManager&gt;()-&gt;getEntitiesByTypeAndRefLevel(</div>
<div class="line">    ref_level,BitRefLevel().set(),MBTRI,ref_faces</div>
<div class="line">  ); </div>
<div class="line">  ref_faces = subtract(ref_faces,done_faces);</div>
<div class="line">  <span class="comment">//build finite elements structures</span></div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element.html#a68f344cfbf6b208f5930951ca427f8f7">mField</a>.<a class="code hl_function" href="group__mofem__fe.html#ga735f920686a9c958073ec14ea0dc1da0">build_finite_elements</a>(<span class="stringliteral">&quot;MIX_BCFLUX&quot;</span>,&amp;ref_faces,2); </div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element.html#a68f344cfbf6b208f5930951ca427f8f7">mField</a>.<a class="code hl_function" href="group__mofem__fe.html#ga735f920686a9c958073ec14ea0dc1da0">build_finite_elements</a>(<span class="stringliteral">&quot;MIX_BCVALUE&quot;</span>,&amp;ref_faces,2); </div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element.html#a68f344cfbf6b208f5930951ca427f8f7">mField</a>.<a class="code hl_function" href="group__mofem__fe.html#ga735f920686a9c958073ec14ea0dc1da0">build_finite_elements</a>(<span class="stringliteral">&quot;MIX_SKELETON&quot;</span>,&amp;ref_faces,2); </div>
<div class="line">  <span class="comment">//Build adjacencies of degrees of freedom and elements</span></div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element.html#a68f344cfbf6b208f5930951ca427f8f7">mField</a>.<a class="code hl_function" href="struct_mo_f_e_m_1_1_core_interface.html#a727653d1367e758daf2a74cb65d4dfa5">build_adjacencies</a>(ref_level); </div>
<div class="line">  <span class="comment">//Declare problem</span></div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element.html#a68f344cfbf6b208f5930951ca427f8f7">mField</a>.<a class="code hl_function" href="group__mofem__problems.html#ga6afc6820fa64d4ceb733bd778adb925a">add_problem</a>(<span class="stringliteral">&quot;MIX&quot;</span>,<a class="code hl_enumvalue" href="definitions_8h.html#a2c740dc34f8edf00c432912eaa5484c1a0bb920c38e835e0fbae45b0c0c029264">MF_ZERO</a>); </div>
<div class="line">  <span class="comment">//set refinement level for problem</span></div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element.html#a68f344cfbf6b208f5930951ca427f8f7">mField</a>.<a class="code hl_function" href="group__mofem__problems.html#gade85bdcb72d29202b60f6994fd6a8e8f">modify_problem_ref_level_set_bit</a>(<span class="stringliteral">&quot;MIX&quot;</span>,ref_level); </div>
<div class="line">  <span class="comment">// Add element to problem</span></div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element.html#a68f344cfbf6b208f5930951ca427f8f7">mField</a>.<a class="code hl_function" href="group__mofem__problems.html#gaf165948ec92b5fcfbe5ec19ea1918ba1">modify_problem_add_finite_element</a>(<span class="stringliteral">&quot;MIX&quot;</span>,<span class="stringliteral">&quot;MIX&quot;</span>); </div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element.html#a68f344cfbf6b208f5930951ca427f8f7">mField</a>.<a class="code hl_function" href="group__mofem__problems.html#gaf165948ec92b5fcfbe5ec19ea1918ba1">modify_problem_add_finite_element</a>(<span class="stringliteral">&quot;MIX&quot;</span>,<span class="stringliteral">&quot;MIX_SKELETON&quot;</span>); </div>
<div class="line">  <span class="comment">// Boundary conditions</span></div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element.html#a68f344cfbf6b208f5930951ca427f8f7">mField</a>.<a class="code hl_function" href="group__mofem__problems.html#gaf165948ec92b5fcfbe5ec19ea1918ba1">modify_problem_add_finite_element</a>(<span class="stringliteral">&quot;MIX&quot;</span>,<span class="stringliteral">&quot;MIX_BCFLUX&quot;</span>); </div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element.html#a68f344cfbf6b208f5930951ca427f8f7">mField</a>.<a class="code hl_function" href="group__mofem__problems.html#gaf165948ec92b5fcfbe5ec19ea1918ba1">modify_problem_add_finite_element</a>(<span class="stringliteral">&quot;MIX&quot;</span>,<span class="stringliteral">&quot;MIX_BCVALUE&quot;</span>); </div>
<div class="line">  <span class="comment">//build problem</span></div>
<div class="line">  ProblemsManager *prb_mng_ptr;</div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element.html#a68f344cfbf6b208f5930951ca427f8f7">mField</a>.<a class="code hl_function" href="struct_mo_f_e_m_1_1_unknown_interface.html#a7ab248ec45fca778800dcd92e5171beb">getInterface</a>(prb_mng_ptr); </div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> prb_mng_ptr-&gt;buildProblems(); </div>
<div class="line">  <span class="comment">//mesh partitioning</span></div>
<div class="line">  <span class="comment">//partition</span></div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> prb_mng_ptr-&gt;partitionProblem(<span class="stringliteral">&quot;MIX&quot;</span>); </div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> prb_mng_ptr-&gt;partitionFiniteElements(<span class="stringliteral">&quot;MIX&quot;</span>); </div>
<div class="line">  <span class="comment">//what are ghost nodes, see Petsc Manual</span></div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> prb_mng_ptr-&gt;partitionGhostDofs(<span class="stringliteral">&quot;MIX&quot;</span>); </div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#acb0a46d159695a01bf667313b7788b45">MoFEMFunctionReturn</a>(0);</div>
<div class="line">}</div>
<div class="ttc" id="adefinitions_8h_html_a3b43531d53059927f420c79cf954561a"><div class="ttname"><a href="definitions_8h.html#a3b43531d53059927f420c79cf954561a">BITREFLEVEL_SIZE</a></div><div class="ttdeci">#define BITREFLEVEL_SIZE</div><div class="ttdoc">max number of refinements</div><div class="ttdef"><b>Definition:</b> <a href="definitions_8h_source.html#l00219">definitions.h:219</a></div></div>
<div class="ttc" id="agroup__mofem__fe_html_ga735f920686a9c958073ec14ea0dc1da0"><div class="ttname"><a href="group__mofem__fe.html#ga735f920686a9c958073ec14ea0dc1da0">MoFEM::CoreInterface::build_finite_elements</a></div><div class="ttdeci">virtual MoFEMErrorCode build_finite_elements(int verb=DEFAULT_VERBOSITY)=0</div><div class="ttdoc">Build finite elements.</div></div>
<div class="ttc" id="agroup__mofem__field_html_ga126ea0bb04802f9d1946435279c3da56"><div class="ttname"><a href="group__mofem__field.html#ga126ea0bb04802f9d1946435279c3da56">MoFEM::CoreInterface::build_fields</a></div><div class="ttdeci">virtual MoFEMErrorCode build_fields(int verb=DEFAULT_VERBOSITY)=0</div></div>
<div class="ttc" id="agroup__mofem__problems_html_ga6afc6820fa64d4ceb733bd778adb925a"><div class="ttname"><a href="group__mofem__problems.html#ga6afc6820fa64d4ceb733bd778adb925a">MoFEM::CoreInterface::add_problem</a></div><div class="ttdeci">virtual MoFEMErrorCode add_problem(const std::string &amp;name, enum MoFEMTypes bh=MF_EXCL, int verb=DEFAULT_VERBOSITY)=0</div><div class="ttdoc">Add problem.</div></div>
<div class="ttc" id="agroup__mofem__problems_html_gade85bdcb72d29202b60f6994fd6a8e8f"><div class="ttname"><a href="group__mofem__problems.html#gade85bdcb72d29202b60f6994fd6a8e8f">MoFEM::CoreInterface::modify_problem_ref_level_set_bit</a></div><div class="ttdeci">virtual MoFEMErrorCode modify_problem_ref_level_set_bit(const std::string &amp;name_problem, const BitRefLevel &amp;bit)=0</div><div class="ttdoc">set ref level for problem</div></div>
<div class="ttc" id="agroup__mofem__problems_html_gaf165948ec92b5fcfbe5ec19ea1918ba1"><div class="ttname"><a href="group__mofem__problems.html#gaf165948ec92b5fcfbe5ec19ea1918ba1">MoFEM::CoreInterface::modify_problem_add_finite_element</a></div><div class="ttdeci">virtual MoFEMErrorCode modify_problem_add_finite_element(const std::string name_problem, const std::string &amp;fe_name)=0</div><div class="ttdoc">add finite element to problem, this add entities assigned to finite element to a particular problem</div></div>
<div class="ttc" id="astruct_mix_transport_1_1_mix_transport_element_html_afc104c3d8a2a02abae3987fec24af4a6"><div class="ttname"><a href="struct_mix_transport_1_1_mix_transport_element.html#afc104c3d8a2a02abae3987fec24af4a6">MixTransport::MixTransportElement::buildProblem</a></div><div class="ttdeci">MoFEMErrorCode buildProblem(BitRefLevel &amp;ref_level)</div><div class="ttdoc">Build problem.</div><div class="ttdef"><b>Definition:</b> <a href="_mix_transport_element_8hpp_source.html#l00291">MixTransportElement.hpp:291</a></div></div>
<div class="ttc" id="astruct_mo_f_e_m_1_1_core_interface_html_a727653d1367e758daf2a74cb65d4dfa5"><div class="ttname"><a href="struct_mo_f_e_m_1_1_core_interface.html#a727653d1367e758daf2a74cb65d4dfa5">MoFEM::CoreInterface::build_adjacencies</a></div><div class="ttdeci">virtual MoFEMErrorCode build_adjacencies(const Range &amp;ents, int verb=DEFAULT_VERBOSITY)=0</div><div class="ttdoc">build adjacencies</div></div>
</div><!-- fragment --><p >In the above code, several key functions are used. Function <a class="el" href="group__mofem__field.html#ga126ea0bb04802f9d1946435279c3da56">MoFEM::Interface::build_fields</a> builds field data structure by construction degrees of freedom on each entity on which given field is spanning. For example, for L2 space, DOFs are only on tetrahedra which were added to the field. For H-div space is the more complex case, degrees of freedom are associated with triangles and tetrahedra, but a number of degrees of each type of entity depend on approximation order, for details look to <a class="el" href="citelist.html#CITEREF_NME:NME847">[1]</a>.</p>
<p >At that point, field structure is created including DOFs on entities. Such structure can carry information about approximation order and values of a field. For example, you can do algebraic operations on field values directly mofem_field_algebra.</p>
<p >No indices are attached to DOFs since indices depend on a number of processors on which solution is carried on, partitioning method or directly type of problem which you like to solve.</p>
<p >Function <a class="el" href="group__mofem__fe.html#ga735f920686a9c958073ec14ea0dc1da0" title="Build finite elements.">MoFEM::Interface::build_finite_elements</a> is used to build data structure. You can note that, in the above code, in subsequent mesh refinements, elements are added to the database, no whole base is rebuilt from scratch. At that point, information about degrees of freedom of fields acting on the element is aggregated. Finite element is problem independent.</p>
<p >Once fields and finite element structures are built, we can build problem. Domain of the problem, its size and structure of the matrix are uniquely defined by finite elements and fields on which element operates. First, a problem is declared using <a class="el" href="group__mofem__problems.html#ga6afc6820fa64d4ceb733bd778adb925a" title="Add problem.">MoFEM::Interface::add_problem</a>, where the argument of the function is the name of the problem which we like to add. Next we define problem, by setting finite elements, this is done using function <a class="el" href="group__mofem__problems.html#gaf165948ec92b5fcfbe5ec19ea1918ba1" title="add finite element to problem, this add entities assigned to finite element to a particular problem">MoFEM::Interface::modify_problem_add_finite_element</a> where elements are added to the problem.</p>
<p >To build problem, we need to set <a class="el" href="namespace_mo_f_e_m_1_1_types.html#aa9495b406c5326b7bca937846ec421c5">MoFEM::BitRefLevel</a> to the problem. In short <a class="el" href="namespace_mo_f_e_m_1_1_types.html#aa9495b406c5326b7bca937846ec421c5">MoFEM::BitRefLevel</a> allows selecting a refined mesh on which we like to solve our problem. The details and unique flexibility of <a class="el" href="namespace_mo_f_e_m_1_1_types.html#aa9495b406c5326b7bca937846ec421c5">MoFEM::BitRefLevel</a> are explained in <a class="el" href="mix_transport.html#mix_mesh_refinement">Explaining mesh BitRefLevel</a>.</p>
<dl class="section note"><dt>Note</dt><dd>Declaration, definition and building of data structures, are independent of each other. We can first declare fields, finite elements and problems, then define at the end build data structures. Implementation of a finite element is independent of its definition.</dd></dl>
<p>Having all those stages done, at that point, structure of algebraic equations emerging from problem definition, finite elements, fields and domains on which finite elements and fields operate. That defines the structure of sparse matrix and structure of parallel vectors which ghost values.</p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="namespace_mo_f_e_m.html" title="implementation of Data Operators for Forces and Sources">MoFEM</a> utilizes properties of approximation spaces, knowing space of approximation field, we know how DOFs are distributed on the mesh. With information about the bilinear form, which is set in the definition of a finite element, we can build adjacencies between DOFs. At last, with the definition of a problem, i.e. set of finite elements in the problem, we can build unique enumeration of DOFs and build the system of algebraic equations. Using spaces (L2, H1, H-DIV, H-CURL) and their properties, we build a system of a data structure which abstracts and general.</dd></dl>
<h2><a class="anchor" id="mixtransport_create_matrices"></a>
Create vectors and matrices (ufe.createMatrices)</h2>
<p >At that point, we have defined and partitioned problem and that is enough to construct distributed matrices and vectors. The sparsity of the matrix, adjacencies and other bookkeeping operations are handled by <a class="el" href="namespace_mo_f_e_m.html" title="implementation of Data Operators for Forces and Sources">MoFEM</a> and PETSc.</p>
<p >Functions and use of below code have been explained earlier in minimal_surface_equation; </p><div class="fragment"><div class="line">MoFEMErrorCode <a class="code hl_function" href="struct_mix_transport_1_1_mix_transport_element.html#a54ece3d2656b896a0546ab797fc7edbc">MixTransport::MixTransportElement::createMatrices</a>() {</div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#a6c0b52978f1abc88bf8a1ba70b7308e3">MoFEMFunctionBegin</a>;</div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element.html#a68f344cfbf6b208f5930951ca427f8f7">mField</a>.<a class="code hl_function" href="struct_mo_f_e_m_1_1_unknown_interface.html#a7ab248ec45fca778800dcd92e5171beb">getInterface</a>&lt;MatrixManager&gt;()-&gt;createMPIAIJWithArrays&lt;PetscGlobalIdx_mi_tag&gt;(<span class="stringliteral">&quot;MIX&quot;</span>,&amp;<a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element.html#a1e16e7b1bfce6569f65abfac52d9fed7">Aij</a>); </div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element.html#a68f344cfbf6b208f5930951ca427f8f7">mField</a>.<a class="code hl_function" href="struct_mo_f_e_m_1_1_unknown_interface.html#a7ab248ec45fca778800dcd92e5171beb">getInterface</a>&lt;VecManager&gt;()-&gt;vecCreateGhost(<span class="stringliteral">&quot;MIX&quot;</span>,<a class="code hl_enumvalue" href="definitions_8h.html#a194bf71b1f5ddbc56eef764d19ea69dba3e66f07732b51f2cb52e13d598f8abda">COL</a>,&amp;<a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element.html#ab3d10f929f16c2642fa7daf82dc8bb75">D</a>); </div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element.html#a68f344cfbf6b208f5930951ca427f8f7">mField</a>.<a class="code hl_function" href="struct_mo_f_e_m_1_1_unknown_interface.html#a7ab248ec45fca778800dcd92e5171beb">getInterface</a>&lt;VecManager&gt;()-&gt;vecCreateGhost(<span class="stringliteral">&quot;MIX&quot;</span>,<a class="code hl_enumvalue" href="definitions_8h.html#a194bf71b1f5ddbc56eef764d19ea69dba3e66f07732b51f2cb52e13d598f8abda">COL</a>,&amp;<a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element.html#aef4b56931e9515f1c9dee1e737484129">D0</a>); </div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element.html#a68f344cfbf6b208f5930951ca427f8f7">mField</a>.<a class="code hl_function" href="struct_mo_f_e_m_1_1_unknown_interface.html#a7ab248ec45fca778800dcd92e5171beb">getInterface</a>&lt;VecManager&gt;()-&gt;vecCreateGhost(<span class="stringliteral">&quot;MIX&quot;</span>,<a class="code hl_enumvalue" href="definitions_8h.html#a194bf71b1f5ddbc56eef764d19ea69dbabf470e461303b909bf0dc58084ebafa0">ROW</a>,&amp;<a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element.html#abd2bfa6ca905f8f60c3f5cb8d53977c3">F</a>); </div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#acb0a46d159695a01bf667313b7788b45">MoFEMFunctionReturn</a>(0);</div>
<div class="line">}</div>
<div class="ttc" id="adefinitions_8h_html_a194bf71b1f5ddbc56eef764d19ea69dba3e66f07732b51f2cb52e13d598f8abda"><div class="ttname"><a href="definitions_8h.html#a194bf71b1f5ddbc56eef764d19ea69dba3e66f07732b51f2cb52e13d598f8abda">COL</a></div><div class="ttdeci">@ COL</div><div class="ttdef"><b>Definition:</b> <a href="definitions_8h_source.html#l00123">definitions.h:123</a></div></div>
<div class="ttc" id="adefinitions_8h_html_a194bf71b1f5ddbc56eef764d19ea69dbabf470e461303b909bf0dc58084ebafa0"><div class="ttname"><a href="definitions_8h.html#a194bf71b1f5ddbc56eef764d19ea69dbabf470e461303b909bf0dc58084ebafa0">ROW</a></div><div class="ttdeci">@ ROW</div><div class="ttdef"><b>Definition:</b> <a href="definitions_8h_source.html#l00123">definitions.h:123</a></div></div>
<div class="ttc" id="astruct_mix_transport_1_1_mix_transport_element_html_a1e16e7b1bfce6569f65abfac52d9fed7"><div class="ttname"><a href="struct_mix_transport_1_1_mix_transport_element.html#a1e16e7b1bfce6569f65abfac52d9fed7">MixTransport::MixTransportElement::Aij</a></div><div class="ttdeci">Mat Aij</div><div class="ttdef"><b>Definition:</b> <a href="_mix_transport_element_8hpp_source.html#l00471">MixTransportElement.hpp:471</a></div></div>
<div class="ttc" id="astruct_mix_transport_1_1_mix_transport_element_html_a54ece3d2656b896a0546ab797fc7edbc"><div class="ttname"><a href="struct_mix_transport_1_1_mix_transport_element.html#a54ece3d2656b896a0546ab797fc7edbc">MixTransport::MixTransportElement::createMatrices</a></div><div class="ttdeci">MoFEMErrorCode createMatrices()</div><div class="ttdoc">create matrices</div><div class="ttdef"><b>Definition:</b> <a href="_mix_transport_element_8hpp_source.html#l00474">MixTransportElement.hpp:474</a></div></div>
<div class="ttc" id="astruct_mix_transport_1_1_mix_transport_element_html_ab3d10f929f16c2642fa7daf82dc8bb75"><div class="ttname"><a href="struct_mix_transport_1_1_mix_transport_element.html#ab3d10f929f16c2642fa7daf82dc8bb75">MixTransport::MixTransportElement::D</a></div><div class="ttdeci">Vec D</div><div class="ttdef"><b>Definition:</b> <a href="_mix_transport_element_8hpp_source.html#l00470">MixTransportElement.hpp:470</a></div></div>
<div class="ttc" id="astruct_mix_transport_1_1_mix_transport_element_html_abd2bfa6ca905f8f60c3f5cb8d53977c3"><div class="ttname"><a href="struct_mix_transport_1_1_mix_transport_element.html#abd2bfa6ca905f8f60c3f5cb8d53977c3">MixTransport::MixTransportElement::F</a></div><div class="ttdeci">Vec F</div><div class="ttdef"><b>Definition:</b> <a href="_mix_transport_element_8hpp_source.html#l00470">MixTransportElement.hpp:470</a></div></div>
<div class="ttc" id="astruct_mix_transport_1_1_mix_transport_element_html_aef4b56931e9515f1c9dee1e737484129"><div class="ttname"><a href="struct_mix_transport_1_1_mix_transport_element.html#aef4b56931e9515f1c9dee1e737484129">MixTransport::MixTransportElement::D0</a></div><div class="ttdeci">Vec D0</div><div class="ttdef"><b>Definition:</b> <a href="_mix_transport_element_8hpp_source.html#l00470">MixTransportElement.hpp:470</a></div></div>
</div><!-- fragment --><h1><a class="anchor" id="mixtransport_assemble_and_solve"></a>
Assemble and solve</h1>
<p >At this point, we have all data structures necessary to solve the problem. Now we focus attention on the implementation of finite element instances and solution procedure. In essence, we need to assemble matrices and vectors, enforce constraints, solve a linear system of equations and post-process results.</p>
<h2><a class="anchor" id="mixtransport_finite_element_instances"></a>
Finite element instances</h2>
<p >Definition of the finite element allows building the structure (adjacency) of the matrix, however, assemble (calculate) matrix we need finite element class implementation and its instance which will do the work. <a class="el" href="namespace_mo_f_e_m.html" title="implementation of Data Operators for Forces and Sources">MoFEM</a> allows implementing finite element at a low level, however, except special cases, a generic finite element class implementations can be used, where some operations like calculation of Jacobian, face areas and normals are implemented. Generic finite element classes enable us to focusses attention on the implementation of the bilinear form and its algebraic representation. That is numerical integration and evaluation of physical equations, evaluation of base functions and fields. The implementation of generic finite element is done by user data operators, see tutorials <a class="el" href="hello_world_tut1.html">FUN-0: Hello world</a> and <a class="el" href="poisson_tut1.html">COR-2: Solving the Poisson equation</a>. Class of user data operator is inherited, and problem specific application is by function overloading. From user data operator class, we have access to base functions, integration points, local and global indices and values of DOFs. etc. <em><a class="el" href="class_user_data_operator.html">UserDataOperator</a></em> is run for entities on the element, on which approximation base is constructed.</p>
<p >In <a class="el" href="struct_mix_transport_1_1_mix_transport_element.html" title="Mix transport problem.">MixTransport::MixTransportElement</a> class we create two generic finite element instances, i.e. <a class="el" href="struct_mix_transport_1_1_mix_transport_element_1_1_my_volume_f_e.html" title="definition of volume element">MixTransport::MixTransportElement::MyVolumeFE</a> and <a class="el" href="struct_mix_transport_1_1_mix_transport_element_1_1_my_tri_f_e.html" title="definition of surface element">MixTransport::MixTransportElement::MyTriFE</a>. </p><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code hl_struct" href="struct_mix_transport_1_1_mix_transport_element_1_1_my_volume_f_e.html">MixTransport::MixTransportElement::MyVolumeFE</a>: <span class="keyword">public</span> <a class="code hl_struct" href="struct_mo_f_e_m_1_1_volume_element_forces_and_sources_core.html">MoFEM::VolumeElementForcesAndSourcesCore</a> {</div>
<div class="line">  MyVolumeFE(<a class="code hl_struct" href="struct_mo_f_e_m_1_1_deprecated_core_interface.html">MoFEM::Interface</a> &amp;m_field): <a class="code hl_namespace" href="namespace_mo_f_e_m.html">MoFEM</a>::VolumeElementForcesAndSourcesCore(m_field) {}</div>
<div class="line">  <span class="keywordtype">int</span> <a class="code hl_function" href="struct_mix_transport_1_1_mix_transport_element_1_1_my_volume_f_e.html#a052e80959030a6f1b1fb34936415d499">getRule</a>(<span class="keywordtype">int</span> <a class="code hl_variable" href="dg__projection_8cpp.html#ad7eceded84ace5678d9df3e44f47d475">order</a>) { <span class="keywordflow">return</span> 2*<a class="code hl_variable" href="dg__projection_8cpp.html#ad7eceded84ace5678d9df3e44f47d475">order</a>+1; };</div>
<div class="line">};</div>
<div class="line">MyVolumeFE feVol;   <span class="comment">///&gt; Instance of volume element</span></div>
<div class="line"><span class="keyword">struct </span><a class="code hl_struct" href="struct_mix_transport_1_1_mix_transport_element_1_1_my_tri_f_e.html">MixTransport::MixTransportElement::MyTriFE</a>: <span class="keyword">public</span> <a class="code hl_struct" href="struct_mo_f_e_m_1_1_face_element_forces_and_sources_core.html">MoFEM::FaceElementForcesAndSourcesCore</a> {</div>
<div class="line">  <a class="code hl_function" href="struct_mix_transport_1_1_mix_transport_element_1_1_my_tri_f_e.html#a5f1b46776cb40a160af6ac9bc666a992">MyTriFE</a>(<a class="code hl_struct" href="struct_mo_f_e_m_1_1_deprecated_core_interface.html">MoFEM::Interface</a> &amp;m_field): <a class="code hl_namespace" href="namespace_mo_f_e_m.html">MoFEM</a>::<a class="code hl_class" href="class_face_element_forces_and_sources_core.html">FaceElementForcesAndSourcesCore</a>(m_field) {}</div>
<div class="line">  <span class="keywordtype">int</span> <a class="code hl_function" href="struct_mix_transport_1_1_mix_transport_element_1_1_my_tri_f_e.html#a30225bfec952402265d4ed3cf5a652ba">getRule</a>(<span class="keywordtype">int</span> <a class="code hl_variable" href="dg__projection_8cpp.html#ad7eceded84ace5678d9df3e44f47d475">order</a>) { <span class="keywordflow">return</span> 2*<a class="code hl_variable" href="dg__projection_8cpp.html#ad7eceded84ace5678d9df3e44f47d475">order</a>+1; };</div>
<div class="line">};</div>
<div class="line">MyTriFE feTri;   <span class="comment">///&lt; Instance of surface element</span></div>
<div class="ttc" id="aclass_face_element_forces_and_sources_core_html"><div class="ttname"><a href="class_face_element_forces_and_sources_core.html">FaceElementForcesAndSourcesCore</a></div></div>
<div class="ttc" id="anamespace_mo_f_e_m_html"><div class="ttname"><a href="namespace_mo_f_e_m.html">MoFEM</a></div><div class="ttdoc">implementation of Data Operators for Forces and Sources</div><div class="ttdef"><b>Definition:</b> <a href="_common_8hpp_source.html#l00010">Common.hpp:10</a></div></div>
<div class="ttc" id="astruct_mix_transport_1_1_mix_transport_element_1_1_my_tri_f_e_html"><div class="ttname"><a href="struct_mix_transport_1_1_mix_transport_element_1_1_my_tri_f_e.html">MixTransport::MixTransportElement::MyTriFE</a></div><div class="ttdoc">definition of surface element</div><div class="ttdef"><b>Definition:</b> <a href="_mix_transport_element_8hpp_source.html#l00054">MixTransportElement.hpp:54</a></div></div>
<div class="ttc" id="astruct_mix_transport_1_1_mix_transport_element_1_1_my_tri_f_e_html_a30225bfec952402265d4ed3cf5a652ba"><div class="ttname"><a href="struct_mix_transport_1_1_mix_transport_element_1_1_my_tri_f_e.html#a30225bfec952402265d4ed3cf5a652ba">MixTransport::MixTransportElement::MyTriFE::getRule</a></div><div class="ttdeci">int getRule(int order)</div><div class="ttdef"><b>Definition:</b> <a href="_mix_transport_element_8hpp_source.html#l00057">MixTransportElement.hpp:57</a></div></div>
<div class="ttc" id="astruct_mix_transport_1_1_mix_transport_element_1_1_my_tri_f_e_html_a5f1b46776cb40a160af6ac9bc666a992"><div class="ttname"><a href="struct_mix_transport_1_1_mix_transport_element_1_1_my_tri_f_e.html#a5f1b46776cb40a160af6ac9bc666a992">MixTransport::MixTransportElement::MyTriFE::MyTriFE</a></div><div class="ttdeci">MyTriFE(MoFEM::Interface &amp;m_field)</div><div class="ttdef"><b>Definition:</b> <a href="_mix_transport_element_8hpp_source.html#l00055">MixTransportElement.hpp:55</a></div></div>
<div class="ttc" id="astruct_mix_transport_1_1_mix_transport_element_1_1_my_volume_f_e_html"><div class="ttname"><a href="struct_mix_transport_1_1_mix_transport_element_1_1_my_volume_f_e.html">MixTransport::MixTransportElement::MyVolumeFE</a></div><div class="ttdoc">definition of volume element</div><div class="ttdef"><b>Definition:</b> <a href="_mix_transport_element_8hpp_source.html#l00040">MixTransportElement.hpp:40</a></div></div>
<div class="ttc" id="astruct_mix_transport_1_1_mix_transport_element_1_1_my_volume_f_e_html_a052e80959030a6f1b1fb34936415d499"><div class="ttname"><a href="struct_mix_transport_1_1_mix_transport_element_1_1_my_volume_f_e.html#a052e80959030a6f1b1fb34936415d499">MixTransport::MixTransportElement::MyVolumeFE::getRule</a></div><div class="ttdeci">int getRule(int order)</div><div class="ttdef"><b>Definition:</b> <a href="_mix_transport_element_8hpp_source.html#l00043">MixTransportElement.hpp:43</a></div></div>
<div class="ttc" id="astruct_mo_f_e_m_1_1_face_element_forces_and_sources_core_html"><div class="ttname"><a href="struct_mo_f_e_m_1_1_face_element_forces_and_sources_core.html">MoFEM::FaceElementForcesAndSourcesCore</a></div><div class="ttdoc">Face finite element.</div><div class="ttdef"><b>Definition:</b> <a href="_face_element_forces_and_sources_core_8hpp_source.html#l00025">FaceElementForcesAndSourcesCore.hpp:25</a></div></div>
<div class="ttc" id="astruct_mo_f_e_m_1_1_volume_element_forces_and_sources_core_html"><div class="ttname"><a href="struct_mo_f_e_m_1_1_volume_element_forces_and_sources_core.html">MoFEM::VolumeElementForcesAndSourcesCore</a></div><div class="ttdoc">Volume finite element base.</div><div class="ttdef"><b>Definition:</b> <a href="_volume_element_forces_and_sources_core_8hpp_source.html#l00026">VolumeElementForcesAndSourcesCore.hpp:26</a></div></div>
</div><!-- fragment --><p >Those two finite element classes have method <a class="el" href="struct_mo_f_e_m_1_1_forces_and_sources_core.html#a6c236ff2640fcecead71327af7937b37" title="another variant of getRule">MoFEM::ForcesAndSourcesCore::getRule</a> overloaded, which sets rank of integration rule on the element. The programmer needs to set integration rule, since he knows what will be integrated.</p>
<p ><a class="el" href="namespace_mo_f_e_m.html" title="implementation of Data Operators for Forces and Sources">MoFEM</a> bases on that function and higher order of approximation base functions sets precalculated in integration points and weights. In some classes, the programmer would like to use own integration rule, that could be easily done as well, but we postpone explanation how to do this to another example. If you like to see how it works in practice, please have a look here <a class="el" href="group__mofem__fs__post__proc.html">Post Process</a>.</p>
<p >Now we can add tasks (<em>UsersOperators</em>) to finite element, which will do a sequence of calculations. However, before we show how to implement <em>UsersOperators</em>, we show first how finite element objects are used.</p>
<h2><a class="anchor" id="mixtransport_solve_problem"></a>
Solve problem (ufe.solveLinearProblem)</h2>
<p >In the previous step, we have constructed matrices and vectors, next step is to calculate matrices and vectors and to solve the linear system of equations. At that point, we not yet focus how to integrate local finite element matrices, showing only how a solution of this problem is constructed. Numeration of DOFs, looping over finite elements, parallelization of the problem or assembly itself is handled by <a class="el" href="namespace_mo_f_e_m.html" title="implementation of Data Operators for Forces and Sources">MoFEM</a>.</p>
<p >The function </p><div class="fragment"><div class="line">MoFEMErrorCode <a class="code hl_function" href="struct_mix_transport_1_1_mix_transport_element.html#a265a8139704dd6783a70bdc913ce0251">MixTransport::MixTransportElement::solveLinearProblem</a>() {</div>
<div class="line">    <a class="code hl_define" href="definitions_8h.html#a6c0b52978f1abc88bf8a1ba70b7308e3">MoFEMFunctionBegin</a>;</div>
<div class="line">    \\ Code inside</div>
<div class="line">    <a class="code hl_define" href="definitions_8h.html#acb0a46d159695a01bf667313b7788b45">MoFEMFunctionReturn</a>(0);</div>
<div class="line"> }</div>
<div class="ttc" id="astruct_mix_transport_1_1_mix_transport_element_html_a265a8139704dd6783a70bdc913ce0251"><div class="ttname"><a href="struct_mix_transport_1_1_mix_transport_element.html#a265a8139704dd6783a70bdc913ce0251">MixTransport::MixTransportElement::solveLinearProblem</a></div><div class="ttdeci">MoFEMErrorCode solveLinearProblem()</div><div class="ttdoc">solve problem</div><div class="ttdef"><b>Definition:</b> <a href="_mix_transport_element_8hpp_source.html#l00488">MixTransportElement.hpp:488</a></div></div>
</div><!-- fragment --><p> can be divided into several stages. First, we will focus on the calculation of essential boundary conditions. We already defined boundary where flux is applied, however unlike in standard FE formulation where nodal shape functions are used, for H-div space we need to apriori calculate values of degrees of freedom for essential boundary conditions. Exploiting properties of H-div space, trace of base functions on the boundary can be evaluated element by element, where for each boundary triangle small system of linear equations is solved. </p><div class="fragment"><div class="line">feTri.getOpPtrVector().clear();</div>
<div class="line">feTri.getOpPtrVector().push_back(<span class="keyword">new</span> OpEvaluateBcOnFluxes(*<span class="keyword">this</span>,<span class="stringliteral">&quot;FLUXES&quot;</span>,D0));</div>
<div class="line"><a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> mField.loop_finite_elements(<span class="stringliteral">&quot;MIX&quot;</span>,<span class="stringliteral">&quot;MIX_BCFLUX&quot;</span>,feTri); </div>
</div><!-- fragment --><p> Note that first line in the code above cleans vector of operators on the element instance (element object could be used before doing other tasks), second line adds operator <a class="el" href="struct_mix_transport_1_1_mix_transport_element_1_1_op_evaluate_bc_on_fluxes.html" title="Evaluate boundary conditions on fluxes.">MixTransport::MixTransportElement::OpEvaluateBcOnFluxes</a> to the finite element instance. The operator has an argument vector D0 in which DOF values for essential boundary conditions are stored. The third line makes the loop over all elements in the problem (name of the problem is the first argument and the finite element is the second argument) and evaluates operators of element instance for object <a class="el" href="struct_mix_transport_1_1_mix_transport_element.html#a91f92ecbe4915298309d1aa4c49a85b8" title="Instance of surface element.">MixTransport::MixTransportElement::feTri</a>. It is clear here that definition of element is separated from its implementation.</p>
<p >The similar procedure is repeated to calculate matrix and the right-hand side vector </p><div class="fragment"><div class="line">feVol.getOpPtrVector().clear();</div>
<div class="line">feVol.getOpPtrVector().push_back(<span class="keyword">new</span> <a class="code hl_struct" href="struct_mix_transport_1_1_mix_transport_element_1_1_op_l2_source.html">MixTransport::MixTransportElement::OpL2Source</a>(*<span class="keyword">this</span>,<span class="stringliteral">&quot;VALUES&quot;</span>,<a class="code hl_enumvalue" href="free__surface_8cpp.html#a275fe82762dca6ff32ecbb73db0b3b84af382a63cc3d6491bf26b59e66f46826d">F</a>));</div>
<div class="line">feVol.getOpPtrVector().push_back(<span class="keyword">new</span> <a class="code hl_struct" href="struct_mix_transport_1_1_mix_transport_element_1_1_op_flux_divergence_at_gauss_pts.html">MixTransport::MixTransportElement::OpFluxDivergenceAtGaussPts</a>(*<span class="keyword">this</span>,<span class="stringliteral">&quot;FLUXES&quot;</span>));</div>
<div class="line">feVol.getOpPtrVector().push_back(<span class="keyword">new</span> <a class="code hl_struct" href="struct_mix_transport_1_1_mix_transport_element_1_1_op_values_at_gauss_pts.html">MixTransport::MixTransportElement::OpValuesAtGaussPts</a>(*<span class="keyword">this</span>,<span class="stringliteral">&quot;VALUES&quot;</span>));</div>
<div class="line">feVol.getOpPtrVector().push_back(<span class="keyword">new</span> <a class="code hl_struct" href="struct_mix_transport_1_1_mix_transport_element_1_1_op_div_tau_u___hdiv_l2.html">MixTransport::MixTransportElement::OpDivTauU_HdivL2</a>(*<span class="keyword">this</span>,<span class="stringliteral">&quot;FLUXES&quot;</span>,<span class="stringliteral">&quot;VALUES&quot;</span>,Aij,<a class="code hl_enumvalue" href="free__surface_8cpp.html#a275fe82762dca6ff32ecbb73db0b3b84af382a63cc3d6491bf26b59e66f46826d">F</a>));</div>
<div class="line">feVol.getOpPtrVector().push_back(<span class="keyword">new</span> <a class="code hl_struct" href="struct_mix_transport_1_1_mix_transport_element_1_1_op_tau_dot_sigma___hdiv_hdiv.html">MixTransport::MixTransportElement::OpTauDotSigma_HdivHdiv</a>(*<span class="keyword">this</span>,<span class="stringliteral">&quot;FLUXES&quot;</span>,Aij,<a class="code hl_enumvalue" href="free__surface_8cpp.html#a275fe82762dca6ff32ecbb73db0b3b84af382a63cc3d6491bf26b59e66f46826d">F</a>));</div>
<div class="line">feVol.getOpPtrVector().push_back(<span class="keyword">new</span> <a class="code hl_struct" href="struct_mix_transport_1_1_mix_transport_element_1_1_op_v_div_sigma___l2_hdiv.html">MixTransport::MixTransportElement::OpVDivSigma_L2Hdiv</a>(*<span class="keyword">this</span>,<span class="stringliteral">&quot;VALUES&quot;</span>,<span class="stringliteral">&quot;FLUXES&quot;</span>,Aij,<a class="code hl_enumvalue" href="free__surface_8cpp.html#a275fe82762dca6ff32ecbb73db0b3b84af382a63cc3d6491bf26b59e66f46826d">F</a>));</div>
<div class="line"><a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> mField.loop_finite_elements(<span class="stringliteral">&quot;MIX&quot;</span>,<span class="stringliteral">&quot;MIX&quot;</span>,feVol); </div>
<div class="ttc" id="afree__surface_8cpp_html_a275fe82762dca6ff32ecbb73db0b3b84af382a63cc3d6491bf26b59e66f46826d"><div class="ttname"><a href="free__surface_8cpp.html#a275fe82762dca6ff32ecbb73db0b3b84af382a63cc3d6491bf26b59e66f46826d">F</a></div><div class="ttdeci">@ F</div><div class="ttdef"><b>Definition:</b> <a href="free__surface_8cpp_source.html#l00394">free_surface.cpp:394</a></div></div>
<div class="ttc" id="astruct_mix_transport_1_1_mix_transport_element_1_1_op_div_tau_u___hdiv_l2_html"><div class="ttname"><a href="struct_mix_transport_1_1_mix_transport_element_1_1_op_div_tau_u___hdiv_l2.html">MixTransport::MixTransportElement::OpDivTauU_HdivL2</a></div><div class="ttdoc">Assemble .</div><div class="ttdef"><b>Definition:</b> <a href="_mix_transport_element_8hpp_source.html#l00865">MixTransportElement.hpp:866</a></div></div>
<div class="ttc" id="astruct_mix_transport_1_1_mix_transport_element_1_1_op_flux_divergence_at_gauss_pts_html"><div class="ttname"><a href="struct_mix_transport_1_1_mix_transport_element_1_1_op_flux_divergence_at_gauss_pts.html">MixTransport::MixTransportElement::OpFluxDivergenceAtGaussPts</a></div><div class="ttdoc">calculate flux at integration point</div><div class="ttdef"><b>Definition:</b> <a href="_mix_transport_element_8hpp_source.html#l01314">MixTransportElement.hpp:1315</a></div></div>
<div class="ttc" id="astruct_mix_transport_1_1_mix_transport_element_1_1_op_l2_source_html"><div class="ttname"><a href="struct_mix_transport_1_1_mix_transport_element_1_1_op_l2_source.html">MixTransport::MixTransportElement::OpL2Source</a></div><div class="ttdoc">Calculate source therms, i.e. .</div><div class="ttdef"><b>Definition:</b> <a href="_mix_transport_element_8hpp_source.html#l01024">MixTransportElement.hpp:1025</a></div></div>
<div class="ttc" id="astruct_mix_transport_1_1_mix_transport_element_1_1_op_tau_dot_sigma___hdiv_hdiv_html"><div class="ttname"><a href="struct_mix_transport_1_1_mix_transport_element_1_1_op_tau_dot_sigma___hdiv_hdiv.html">MixTransport::MixTransportElement::OpTauDotSigma_HdivHdiv</a></div><div class="ttdoc">Assemble .</div><div class="ttdef"><b>Definition:</b> <a href="_mix_transport_element_8hpp_source.html#l00719">MixTransportElement.hpp:720</a></div></div>
<div class="ttc" id="astruct_mix_transport_1_1_mix_transport_element_1_1_op_v_div_sigma___l2_hdiv_html"><div class="ttname"><a href="struct_mix_transport_1_1_mix_transport_element_1_1_op_v_div_sigma___l2_hdiv.html">MixTransport::MixTransportElement::OpVDivSigma_L2Hdiv</a></div><div class="ttdef"><b>Definition:</b> <a href="_mix_transport_element_8hpp_source.html#l00921">MixTransportElement.hpp:922</a></div></div>
<div class="ttc" id="astruct_mix_transport_1_1_mix_transport_element_1_1_op_values_at_gauss_pts_html"><div class="ttname"><a href="struct_mix_transport_1_1_mix_transport_element_1_1_op_values_at_gauss_pts.html">MixTransport::MixTransportElement::OpValuesAtGaussPts</a></div><div class="ttdoc">Calculate values at integration points.</div><div class="ttdef"><b>Definition:</b> <a href="_mix_transport_element_8hpp_source.html#l01249">MixTransportElement.hpp:1250</a></div></div>
</div><!-- fragment --><p> where the calculation of matrix and right-hand side vector is broken down into several stages, where each sub-matrix is calculated by an user operator acting on finite element entities. Note that this time integration is over volume element, i.e. <a class="el" href="struct_mix_transport_1_1_mix_transport_element.html#aad3b7f3ea9e46ab87a9c17b47fd63447" title="Instance of volume element.">MixTransport::MixTransportElement::feVol</a>. Finally, this part of code ends with the loop over all <em>MIX</em> finite elements in the <em>MIX</em> problem. If calculations are done in parallel, <a class="el" href="namespace_mo_f_e_m.html" title="implementation of Data Operators for Forces and Sources">MoFEM</a> manages related complexities transparently.</p>
<p >To complete calculations we have to integrate natural boundary conditions, i.e. enforce Dirichlet boundary condition </p><div class="fragment"><div class="line">feTri.getOpPtrVector().clear();</div>
<div class="line">feTri.getOpPtrVector().push_back(<span class="keyword">new</span> OpRhsBcOnValues(*<span class="keyword">this</span>,<span class="stringliteral">&quot;FLUXES&quot;</span>,<a class="code hl_enumvalue" href="free__surface_8cpp.html#a275fe82762dca6ff32ecbb73db0b3b84af382a63cc3d6491bf26b59e66f46826d">F</a>));</div>
<div class="line"><a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> mField.loop_finite_elements(<span class="stringliteral">&quot;MIX&quot;</span>,<span class="stringliteral">&quot;MIX_BCVALUE&quot;</span>,feTri); </div>
</div><!-- fragment --><p> This procedure looks very similar to what has been done before, we clear existing operators on <a class="el" href="struct_mix_transport_1_1_mix_transport_element.html#a91f92ecbe4915298309d1aa4c49a85b8" title="Instance of surface element.">MixTransport::MixTransportElement::feTri</a>, add operator <a class="el" href="struct_mix_transport_1_1_mix_transport_element_1_1_op_rhs_bc_on_values.html" title="calculate">MixTransport::MixTransportElement::OpRhsBcOnValues</a> and loop over all surface elements where Dirichlet boundary is set.</p>
<p >At this point, we have created and assembled linear system of equations, we have not given an explanation how to do integration at user operator level, this will be explained later. At this point, we will show how to enforce essential boundary conditions. We have calculated values of DOFs already. Now we have to modify matrix and the right-hand side vector </p><div class="fragment"><div class="line"><a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> getDirichletBCIndices(&amp;essential_bc_ids); </div>
<div class="line"><a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> MatZeroRowsIS(Aij,essential_bc_ids,1,D0,<a class="code hl_enumvalue" href="free__surface_8cpp.html#a275fe82762dca6ff32ecbb73db0b3b84af382a63cc3d6491bf26b59e66f46826d">F</a>); </div>
</div><!-- fragment --><p> while operator <a class="el" href="struct_mix_transport_1_1_mix_transport_element_1_1_op_evaluate_bc_on_fluxes.html" title="Evaluate boundary conditions on fluxes.">MixTransport::MixTransportElement::OpEvaluateBcOnFluxes</a> is executed, it records indices of DOFs for which essential boundary conditions are applied. These DOFs are accessed by <a class="el" href="struct_mix_transport_1_1_mix_transport_element.html#a2ffff13c47cec52cfcd5193ba138383e" title="get dof indices where essential boundary conditions are applied">MixTransport::MixTransportElement::getDirichletBCIndices</a>. We use those indices to zero rows of matrix <em>Aij</em> and insert 1 on diagonal. In addition, we fill the right-hand side vector with previously calculated vector D0. This operation is performed with PETSc function MatZeroRowsIS (<a href="http://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/Mat/MatZeroRowsIS.html">http://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/Mat/MatZeroRowsIS.html</a>)</p>
<p >At this point, we can solve system of equations </p><div class="fragment"><div class="line">KSP solver;</div>
<div class="line"><a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> KSPCreate(PETSC_COMM_WORLD,&amp;solver); </div>
<div class="line"><a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> KSPSetOperators(solver,Aij,Aij); </div>
<div class="line"><a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> KSPSetFromOptions(solver); </div>
<div class="line"><a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> KSPSetUp(solver); </div>
<div class="line"><a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> KSPSolve(solver,<a class="code hl_enumvalue" href="free__surface_8cpp.html#a275fe82762dca6ff32ecbb73db0b3b84af382a63cc3d6491bf26b59e66f46826d">F</a>,<a class="code hl_variable" href="initial__diffusion_8cpp.html#ad8657a5ec76e12f3066fb4b4eb75ace9">D</a>); </div>
<div class="line"><a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> VecGhostUpdateBegin(<a class="code hl_variable" href="initial__diffusion_8cpp.html#ad8657a5ec76e12f3066fb4b4eb75ace9">D</a>,INSERT_VALUES,SCATTER_FORWARD); </div>
<div class="line"><a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> VecGhostUpdateEnd(<a class="code hl_variable" href="initial__diffusion_8cpp.html#ad8657a5ec76e12f3066fb4b4eb75ace9">D</a>,INSERT_VALUES,SCATTER_FORWARD); </div>
<div class="line"><a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> KSPDestroy(&amp;solver); </div>
<div class="ttc" id="ainitial__diffusion_8cpp_html_ad8657a5ec76e12f3066fb4b4eb75ace9"><div class="ttname"><a href="initial__diffusion_8cpp.html#ad8657a5ec76e12f3066fb4b4eb75ace9">D</a></div><div class="ttdeci">double D</div><div class="ttdef"><b>Definition:</b> <a href="initial__diffusion_8cpp_source.html#l00044">initial_diffusion.cpp:44</a></div></div>
</div><!-- fragment --><p> For details about the code above, we refer to PETSc user manual <a href="https://www.mcs.anl.gov/petsc/documentation/index.html">https://www.mcs.anl.gov/petsc/documentation/index.html</a>.</p>
<p >The last operation at that stage is to store results on the mesh </p><div class="fragment"><div class="line"><a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> mField.getInterface&lt;VecManager&gt;()-&gt;setGlobalGhostVector(<span class="stringliteral">&quot;MIX&quot;</span>,<a class="code hl_enumvalue" href="definitions_8h.html#a194bf71b1f5ddbc56eef764d19ea69dba3e66f07732b51f2cb52e13d598f8abda">COL</a>,<a class="code hl_variable" href="initial__diffusion_8cpp.html#ad8657a5ec76e12f3066fb4b4eb75ace9">D</a>,INSERT_VALUES,SCATTER_REVERSE); </div>
</div><!-- fragment --><p> You can think about <a class="el" href="namespace_mo_f_e_m.html" title="implementation of Data Operators for Forces and Sources">MoFEM</a> as a link between algebraic structures (e.g. vector) and mesh. Function MoFEM::Interface::set_global_ghost_vector is an example of this, using it you can transfer field values from mesh to vector and reverse of it.</p>
<dl class="section note"><dt>Note</dt><dd>Note that discretization field is abstract has no indices, where vector has indexing by its nature. You can imagine that you solve the thermal problem. As a result, you have calculated temperature field, in other problem, solved with different partitioning, on some subdomain of thermal problem, you like to calculate mechanical field using a staggered method where previously calculated temperature is used. In that case, an algebraic structure (enumeration of DOFs) is different. However, when you use MoFEM::Interface::set_global_ghost_vector, transferring field from one problem to another is straightforward.</dd></dl>
<h1><a class="anchor" id="mixtransport_implementation"></a>
Implementation of user operator</h1>
<p >In <a class="el" href="namespace_mo_f_e_m.html" title="implementation of Data Operators for Forces and Sources">MoFEM</a>, we apply general procedure, recognising in the typical finite analysis, to calculate matrices and vectors we make loops. Loop over finite elements on given partition, loop over entities in the elements (e.g. triangle is composed of entities like vertices, edges and triangle itself) and build on those entities base functions. Finally loop over integration points, where base functions are evaluated and local element matrix assembled.</p>
<p >Performing those loops, <a class="el" href="namespace_mo_f_e_m.html" title="implementation of Data Operators for Forces and Sources">MoFEM</a> manages associated complexities, like extraction of global and local indices or DOFs values, evaluation of base functions and derivatives and other typical operations.</p>
<p >All this work is done by generic finite element, the basic finite element instance is built on <a class="el" href="struct_mo_f_e_m_1_1_f_e_method.html" title="structure for User Loop Methods on finite elements">MoFEM::FEMethod</a>, then more advanced structure recognising that finite element entity is composed of lower dimension entities is <a class="el" href="struct_mo_f_e_m_1_1_forces_and_sources_core.html" title="structure to get information form mofem into EntitiesFieldData">MoFEM::ForcesAndSourcesCore</a>. <a class="el" href="struct_mo_f_e_m_1_1_forces_and_sources_core.html" title="structure to get information form mofem into EntitiesFieldData">MoFEM::ForcesAndSourcesCore</a> allows to add so-called user operators, which are classes operating on each lower dimension entities and performing loops over integration points.</p>
<p >From class <a class="el" href="struct_mo_f_e_m_1_1_forces_and_sources_core.html" title="structure to get information form mofem into EntitiesFieldData">MoFEM::ForcesAndSourcesCore</a>, there are more specialised classes like <a class="el" href="struct_mo_f_e_m_1_1_volume_element_forces_and_sources_core.html" title="Volume finite element base.">MoFEM::VolumeElementForcesAndSourcesCore</a>, <a class="el" href="struct_mo_f_e_m_1_1_face_element_forces_and_sources_core.html" title="Face finite element.">MoFEM::FaceElementForcesAndSourcesCore</a> and others, see <a class="el" href="group__mofem__forces__and__sources.html">Forces and sources</a> . Those elements recognise the fact that for example working with a volume (3d) finite element you would like to calculate volume or use appropriate integration rule. From other hand, working with faces like triangles, <a class="el" href="struct_mo_f_e_m_1_1_face_element_forces_and_sources_core.html" title="Face finite element.">MoFEM::FaceElementForcesAndSourcesCore</a>, you would like to know what is the area of the face or its normal and tangent vectors. Derived classes like <a class="el" href="struct_mo_f_e_m_1_1_volume_element_forces_and_sources_core.html" title="Volume finite element base.">MoFEM::VolumeElementForcesAndSourcesCore</a> delivers tools for finite element programmer to do the specific job.</p>
<p >In this example, we use functionality of <a class="el" href="struct_mo_f_e_m_1_1_volume_element_forces_and_sources_core.html" title="Volume finite element base.">MoFEM::VolumeElementForcesAndSourcesCore</a> by creating new class <a class="el" href="struct_mix_transport_1_1_mix_transport_element_1_1_my_volume_f_e.html" title="definition of volume element">MixTransport::MixTransportElement::MyVolumeFE</a> that derives from the existing class. The derived class inherits the properties of the base class, and you can add or override methods and properties as required. Each class has method <a class="el" href="struct_mo_f_e_m_1_1_forces_and_sources_core.html#aba236b9f5892be49d6ae6756b12f5a88" title="Use to push back operator for row operator.">MoFEM::ForcesAndSourcesCore::getOpPtrVector</a>, returning reference to vector of shared pointers to <a class="el" href="struct_mo_f_e_m_1_1_forces_and_sources_core_1_1_user_data_operator.html">MoFEM::ForcesAndSourcesCore::UserDataOperator</a>, i.e. </p><div class="fragment"><div class="line">boost::ptr_deque&lt;MoFEM::ForcesAndSourcesCore::UserDataOperator&gt;&amp; <a class="code hl_function" href="struct_mo_f_e_m_1_1_forces_and_sources_core.html#aba236b9f5892be49d6ae6756b12f5a88">MoFEM::ForcesAndSourcesCore::getOpPtrVector</a> ();</div>
<div class="ttc" id="astruct_mo_f_e_m_1_1_forces_and_sources_core_html_aba236b9f5892be49d6ae6756b12f5a88"><div class="ttname"><a href="struct_mo_f_e_m_1_1_forces_and_sources_core.html#aba236b9f5892be49d6ae6756b12f5a88">MoFEM::ForcesAndSourcesCore::getOpPtrVector</a></div><div class="ttdeci">boost::ptr_deque&lt; UserDataOperator &gt; &amp; getOpPtrVector()</div><div class="ttdoc">Use to push back operator for row operator.</div><div class="ttdef"><b>Definition:</b> <a href="_forces_and_sources_core_8hpp_source.html#l00083">ForcesAndSourcesCore.hpp:83</a></div></div>
</div><!-- fragment --><p >Instances of operator classes derived from <a class="el" href="struct_mo_f_e_m_1_1_data_operator.html" title="base operator to do operations at Gauss Pt. level">MoFEM::DataOperator</a>. <a class="el" href="struct_mo_f_e_m_1_1_forces_and_sources_core_1_1_user_data_operator.html">MoFEM::ForcesAndSourcesCore::UserDataOperator</a> does particular jobs, for example, calculating field values at integration points, integrating mass or stiffness matrix. Finite element instance can run the sequence of user operator in the order you add them to share common data structure, here <a class="el" href="struct_mix_transport_1_1_mix_transport_element.html">MixTransport::MixTransportElement</a> itself. So for example, in one operator you can calculate gradients of displacement field at each integration point, in another, you can symmetrize gradient to calculate strain and in following to calculate stress and another to calculate the vector of internal forces. You break down the big job into smaller components, which you can use in several different contexts and easily test them one by one, making debugging easy. That is general philosophy of <a class="el" href="namespace_mo_f_e_m.html" title="implementation of Data Operators for Forces and Sources">MoFEM</a>, that complex and difficult problems are composition of small and simple tasks.</p>
<p >Class <a class="el" href="struct_mo_f_e_m_1_1_forces_and_sources_core_1_1_user_data_operator.html">MoFEM::ForcesAndSourcesCore::UserDataOperator</a> is inherited by <a class="el" href="struct_mo_f_e_m_1_1_volume_element_forces_and_sources_core_1_1_user_data_operator.html">MoFEM::VolumeElementForcesAndSourcesCore::UserDataOperator</a> or <a class="el" href="struct_mo_f_e_m_1_1_face_element_forces_and_sources_core_1_1_user_data_operator.html" title="default operator for TRI element">MoFEM::FaceElementForcesAndSourcesCore::UserDataOperator</a> and other user operator classes associated with vertices and edges. User operator class has two types of functions which need to be overloaded to do calculations, and they are </p><div class="fragment"><div class="line"> <span class="keyword">virtual</span> MoFEMErrorCode <a class="code hl_function" href="struct_mo_f_e_m_1_1_data_operator.html#a19219f04bba3938fd893898f128dcfb2">MoFEM::DataOperator::doWork</a>( <span class="keywordtype">int</span> row_side,<span class="keywordtype">int</span></div>
<div class="line">col_side, <a class="code hl_class" href="class_entity_type.html">EntityType</a> row_type,<a class="code hl_class" href="class_entity_type.html">EntityType</a> col_type,</div>
<div class="line">EntitiesFieldData::EntData &amp;row_data, EntitiesFieldData::EntData</div>
<div class="line">&amp;col_data ); </div>
<div class="ttc" id="aclass_entity_type_html"><div class="ttname"><a href="class_entity_type.html">EntityType</a></div></div>
<div class="ttc" id="astruct_mo_f_e_m_1_1_data_operator_html_a19219f04bba3938fd893898f128dcfb2"><div class="ttname"><a href="struct_mo_f_e_m_1_1_data_operator.html#a19219f04bba3938fd893898f128dcfb2">MoFEM::DataOperator::doWork</a></div><div class="ttdeci">virtual MoFEMErrorCode doWork(int row_side, int col_side, EntityType row_type, EntityType col_type, EntitiesFieldData::EntData &amp;row_data, EntitiesFieldData::EntData &amp;col_data)</div><div class="ttdoc">Operator for bi-linear form, usually to calculate values on left hand side.</div><div class="ttdef"><b>Definition:</b> <a href="_data_operators_8hpp_source.html#l00040">DataOperators.hpp:40</a></div></div>
</div><!-- fragment --><p> and </p><div class="fragment"><div class="line"> <span class="keyword">virtual</span> MoFEMErrorCode</div>
<div class="line"><a class="code hl_function" href="struct_mo_f_e_m_1_1_data_operator.html#a19219f04bba3938fd893898f128dcfb2">MoFEM::DataOperator::doWork</a>( <span class="keywordtype">int</span> side, <a class="code hl_class" href="class_entity_type.html">EntityType</a> type,</div>
<div class="line">EntitiesFieldData::EntData &amp;data ) </div>
</div><!-- fragment --><p> You have seen how we use those operators in the previous section. Here we show how to implement particular cases. The first <b>doWork(int row_side, int col_side, ...)</b> function is usually overloaded when you assemble matrix, the second is often used to assemble vectors. However, use of user operators is beyond assembly of matrices and vectors. Note that first <b>doWork(int side, EntityType type, ...)</b> function has an argument information about data in rows and columns, where second takes as an argument only rows or columns, depending on how user operator is set-up.</p>
<h2><a class="anchor" id="mixtransport_assmble_matrix"></a>
Assembling matrix</h2>
<p >We will show how user operators work on two examples. First, we focus attention on term  </p><p class="formulaDsp">
\[
b_\mathbf{C}(\sigma,v) =
\int_\Omega \textrm{div}[\boldsymbol\sigma] v \textrm{d}\Omega =
\sum_\mathcal{T}^E
\int_{\mathcal{T}^e} \textrm{div}[\boldsymbol\sigma] v \textrm{d}\mathcal{T} =
\mathbf{q}_\textrm{h-div}^\textrm{T}
\left(
\sum_\mathcal{T}^E
\sum_\mathcal{E_\textrm{row}}^e
\sum_\mathcal{E_\textrm{col}}^e
\sum_{g=0}^\textrm{N}
w_g B^\textrm{h-div}_{i,i} B^\textrm{v}
\right) \mathbf{q}_\textrm{v} =
\left(\mathbf{q}_\textrm{h-div}\right)^\textrm{T} \mathbf{C} \mathbf{q}_\textrm{v}
\]
</p>
<p> were we implement matrix \(\mathbf{C}\)  </p><p class="formulaDsp">
\[
\mathbf{C} = \sum_\mathcal{T}^E
\sum_\mathcal{E_\textrm{row}}^e
\sum_\mathcal{E_\textrm{col}}^e
\sum_{g=0}^\textrm{N}
w_g B^\textrm{h-div}_{i,i} B^\textrm{v}
\]
</p>
<p> Note that in this case, where we have H-div space on rows and L2 space on columns, we have  </p><p class="formulaDsp">
\[
\mathcal{E}_\textrm{row}=\{ TRIANGLES\,\times\,4, TETRAHERAL \},\quad \mathcal{E}_\textrm{col} = \{ TETRAHEDRAL \}
\]
</p>
<p >You can notice three loops, over elements, entities on element and integration point. The first and second loop are managed by <a class="el" href="namespace_mo_f_e_m.html" title="implementation of Data Operators for Forces and Sources">MoFEM</a> while the last one over integration points where a particular operator is evaluated is implemented by programmer, as shown below </p><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code hl_struct" href="struct_mix_transport_1_1_mix_transport_element_1_1_op_v_div_sigma___l2_hdiv.html">MixTransport::MixTransportElement::OpVDivSigma_L2Hdiv</a>: <span class="keyword">public</span> <a class="code hl_struct" href="struct_mo_f_e_m_1_1_volume_element_forces_and_sources_core_1_1_user_data_operator.html">MoFEM::VolumeElementForcesAndSourcesCore::UserDataOperator</a> {</div>
<div class="line">  Mat <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element_1_1_op_v_div_sigma___l2_hdiv.html#a97b630d784030154c4e9f2789daabfec">Aij</a>;</div>
<div class="line">  OpVDivSigma_L2Hdiv(Mat aij):</div>
<div class="line">  <a class="code hl_namespace" href="namespace_mo_f_e_m.html">MoFEM</a>::VolumeElementForcesAndSourcesCore::<a class="code hl_typedef" href="_hooke_element_8hpp.html#aee27a2ebc8f3d34a5c1ce71b2607d1a3">UserDataOperator</a>(</div>
<div class="line">    <span class="stringliteral">&quot;FLUXES&quot;</span>,<span class="stringliteral">&quot;VALUES&quot;</span>,<a class="code hl_typedef" href="_hooke_element_8hpp.html#aee27a2ebc8f3d34a5c1ce71b2607d1a3">UserDataOperator</a>::<a class="code hl_enumvalue" href="struct_mo_f_e_m_1_1_forces_and_sources_core_1_1_user_data_operator.html#ac99de5ec6fa9bad3ccc5c5d60bc48e40a3884917d2b4b602e2579971b6d56878a">OPROWCOL</a></div>
<div class="line">  ),</div>
<div class="line">  <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element_1_1_op_v_div_sigma___l2_hdiv.html#a97b630d784030154c4e9f2789daabfec">Aij</a>(aij) {</div>
<div class="line">    <span class="comment">//this operator is not symmetric setting this variable makes element</span></div>
<div class="line">    <span class="comment">//operator to loop over element entities without</span></div>
<div class="line">    <span class="comment">//assumption that off-diagonal matrices are symmetric.</span></div>
<div class="line">    <a class="code hl_variable" href="struct_mo_f_e_m_1_1_data_operator.html#a300b85aefcf2cf7203ada5d6d501f25f">sYmm</a> = <span class="keyword">false</span>;</div>
<div class="line">  }</div>
<div class="line">  MatrixDouble C;</div>
<div class="line">  VectorDouble <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element_1_1_op_v_div_sigma___l2_hdiv.html#ae82103a247a14db8adccf7ecc5a49157">divVec</a>,<a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element_1_1_op_v_div_sigma___l2_hdiv.html#aae8635e7cad4655f05c6e7f7b2063e42">Nf</a>;</div>
<div class="line">  MoFEMErrorCode <a class="code hl_function" href="struct_mix_transport_1_1_mix_transport_element_1_1_op_v_div_sigma___l2_hdiv.html#a8553613978e25f39d15086b292011ea5">doWork</a>(</div>
<div class="line">    <span class="keywordtype">int</span> row_side,<span class="keywordtype">int</span> col_side,</div>
<div class="line">    <a class="code hl_class" href="class_entity_type.html">EntityType</a> row_type,<a class="code hl_class" href="class_entity_type.html">EntityType</a> col_type,</div>
<div class="line">    EntitiesFieldData::EntData &amp;row_data,</div>
<div class="line">    EntitiesFieldData::EntData &amp;col_data</div>
<div class="line">  ) {</div>
<div class="line">    <a class="code hl_define" href="definitions_8h.html#a6c0b52978f1abc88bf8a1ba70b7308e3">MoFEMFunctionBegin</a>;</div>
<div class="line">    <span class="keywordtype">int</span> nb_row = row_data.getFieldData().size();</div>
<div class="line">    <span class="keywordtype">int</span> nb_col = col_data.getFieldData().size();</div>
<div class="line">    <span class="keywordflow">if</span>(nb_row==0) <a class="code hl_define" href="definitions_8h.html#a59cd650c2f6d3e0dc1ad1c29821e8692">MoFEMFunctionReturnHot</a>(0);</div>
<div class="line">    <span class="keywordflow">if</span>(nb_col==0) <a class="code hl_define" href="definitions_8h.html#a59cd650c2f6d3e0dc1ad1c29821e8692">MoFEMFunctionReturnHot</a>(0);</div>
<div class="line">    C.resize(nb_row,nb_col);</div>
<div class="line">    C.clear();</div>
<div class="line">    <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element_1_1_op_v_div_sigma___l2_hdiv.html#ae82103a247a14db8adccf7ecc5a49157">divVec</a>.resize(nb_row,<span class="keyword">false</span>);</div>
<div class="line">    <span class="keywordtype">int</span> nb_gauss_pts = row_data.getVectorN().size1();</div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> gg = 0;gg&lt;nb_gauss_pts;gg++) {</div>
<div class="line">      <span class="keywordtype">double</span> w = <a class="code hl_function" href="struct_mo_f_e_m_1_1_forces_and_sources_core_1_1_user_data_operator.html#ae90a09d3c36b0a4ed9ab1d99fcce0c1d">getGaussPts</a>()(3,gg)*<a class="code hl_function" href="struct_mo_f_e_m_1_1_volume_element_forces_and_sources_core_1_1_user_data_operator.html#a27ada41314b2540fb0a722aad7257051">getVolume</a>();<span class="comment"></span></div>
<div class="line"><span class="comment">      /// FIXME:</span></div>
<div class="line"><span class="comment">      /// This in newer versions is removed. Using FTensor you can directly calulate </span></div>
<div class="line"><span class="comment">      /// trace of derivative of HDiv base function.</span></div>
<div class="line"><span class="comment"></span>      <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> getDivergenceOfHDivBaseFunctions(</div>
<div class="line">        row_side,row_type,col_data,gg,<a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element_1_1_op_v_div_sigma___l2_hdiv.html#ae82103a247a14db8adccf7ecc5a49157">divVec</a>);   </div>
<div class="line">      noalias(C) += w*outer_prod(<a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element_1_1_op_v_div_sigma___l2_hdiv.html#ae82103a247a14db8adccf7ecc5a49157">divVec</a>,row_data.getN(gg));</div>
<div class="line">    }</div>
<div class="line">    <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> MatSetValues(</div>
<div class="line">      <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element_1_1_op_v_div_sigma___l2_hdiv.html#a97b630d784030154c4e9f2789daabfec">Aij</a>,</div>
<div class="line">      nb_row,&amp;row_data.getIndices()[0],</div>
<div class="line">      nb_col,&amp;col_data.getIndices()[0],</div>
<div class="line">      &amp;C(0,0),ADD_VALUES</div>
<div class="line">    ); </div>
<div class="line">    <a class="code hl_define" href="definitions_8h.html#acb0a46d159695a01bf667313b7788b45">MoFEMFunctionReturn</a>(0);</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="ttc" id="a_hooke_element_8hpp_html_aee27a2ebc8f3d34a5c1ce71b2607d1a3"><div class="ttname"><a href="_hooke_element_8hpp.html#aee27a2ebc8f3d34a5c1ce71b2607d1a3">UserDataOperator</a></div><div class="ttdeci">ForcesAndSourcesCore::UserDataOperator UserDataOperator</div><div class="ttdef"><b>Definition:</b> <a href="_hooke_element_8hpp_source.html#l00075">HookeElement.hpp:75</a></div></div>
<div class="ttc" id="astruct_mix_transport_1_1_mix_transport_element_1_1_op_v_div_sigma___l2_hdiv_html_a8553613978e25f39d15086b292011ea5"><div class="ttname"><a href="struct_mix_transport_1_1_mix_transport_element_1_1_op_v_div_sigma___l2_hdiv.html#a8553613978e25f39d15086b292011ea5">MixTransport::MixTransportElement::OpVDivSigma_L2Hdiv::doWork</a></div><div class="ttdeci">MoFEMErrorCode doWork(int row_side, int col_side, EntityType row_type, EntityType col_type, EntitiesFieldData::EntData &amp;row_data, EntitiesFieldData::EntData &amp;col_data)</div><div class="ttdoc">Do calculations.</div><div class="ttdef"><b>Definition:</b> <a href="_mix_transport_element_8hpp_source.html#l00959">MixTransportElement.hpp:959</a></div></div>
<div class="ttc" id="astruct_mix_transport_1_1_mix_transport_element_1_1_op_v_div_sigma___l2_hdiv_html_a97b630d784030154c4e9f2789daabfec"><div class="ttname"><a href="struct_mix_transport_1_1_mix_transport_element_1_1_op_v_div_sigma___l2_hdiv.html#a97b630d784030154c4e9f2789daabfec">MixTransport::MixTransportElement::OpVDivSigma_L2Hdiv::Aij</a></div><div class="ttdeci">Mat Aij</div><div class="ttdef"><b>Definition:</b> <a href="_mix_transport_element_8hpp_source.html#l00925">MixTransportElement.hpp:925</a></div></div>
<div class="ttc" id="astruct_mix_transport_1_1_mix_transport_element_1_1_op_v_div_sigma___l2_hdiv_html_aae8635e7cad4655f05c6e7f7b2063e42"><div class="ttname"><a href="struct_mix_transport_1_1_mix_transport_element_1_1_op_v_div_sigma___l2_hdiv.html#aae8635e7cad4655f05c6e7f7b2063e42">MixTransport::MixTransportElement::OpVDivSigma_L2Hdiv::Nf</a></div><div class="ttdeci">VectorDouble Nf</div><div class="ttdef"><b>Definition:</b> <a href="_mix_transport_element_8hpp_source.html#l00945">MixTransportElement.hpp:945</a></div></div>
<div class="ttc" id="astruct_mix_transport_1_1_mix_transport_element_1_1_op_v_div_sigma___l2_hdiv_html_ae82103a247a14db8adccf7ecc5a49157"><div class="ttname"><a href="struct_mix_transport_1_1_mix_transport_element_1_1_op_v_div_sigma___l2_hdiv.html#ae82103a247a14db8adccf7ecc5a49157">MixTransport::MixTransportElement::OpVDivSigma_L2Hdiv::divVec</a></div><div class="ttdeci">VectorDouble divVec</div><div class="ttdef"><b>Definition:</b> <a href="_mix_transport_element_8hpp_source.html#l00945">MixTransportElement.hpp:945</a></div></div>
<div class="ttc" id="astruct_mo_f_e_m_1_1_data_operator_html_a300b85aefcf2cf7203ada5d6d501f25f"><div class="ttname"><a href="struct_mo_f_e_m_1_1_data_operator.html#a300b85aefcf2cf7203ada5d6d501f25f">MoFEM::DataOperator::sYmm</a></div><div class="ttdeci">bool sYmm</div><div class="ttdoc">If true assume that matrix is symmetric structure.</div><div class="ttdef"><b>Definition:</b> <a href="_data_operators_8hpp_source.html#l00082">DataOperators.hpp:82</a></div></div>
<div class="ttc" id="astruct_mo_f_e_m_1_1_forces_and_sources_core_1_1_user_data_operator_html_ac99de5ec6fa9bad3ccc5c5d60bc48e40a3884917d2b4b602e2579971b6d56878a"><div class="ttname"><a href="struct_mo_f_e_m_1_1_forces_and_sources_core_1_1_user_data_operator.html#ac99de5ec6fa9bad3ccc5c5d60bc48e40a3884917d2b4b602e2579971b6d56878a">MoFEM::ForcesAndSourcesCore::UserDataOperator::OPROWCOL</a></div><div class="ttdeci">@ OPROWCOL</div><div class="ttdoc">operator doWork is executed on FE rows &amp;columns</div><div class="ttdef"><b>Definition:</b> <a href="_forces_and_sources_core_8hpp_source.html#l00566">ForcesAndSourcesCore.hpp:566</a></div></div>
<div class="ttc" id="astruct_mo_f_e_m_1_1_forces_and_sources_core_1_1_user_data_operator_html_ae90a09d3c36b0a4ed9ab1d99fcce0c1d"><div class="ttname"><a href="struct_mo_f_e_m_1_1_forces_and_sources_core_1_1_user_data_operator.html#ae90a09d3c36b0a4ed9ab1d99fcce0c1d">MoFEM::ForcesAndSourcesCore::UserDataOperator::getGaussPts</a></div><div class="ttdeci">MatrixDouble &amp; getGaussPts()</div><div class="ttdoc">matrix of integration (Gauss) points for Volume Element</div><div class="ttdef"><b>Definition:</b> <a href="_forces_and_sources_core_8hpp_source.html#l01232">ForcesAndSourcesCore.hpp:1232</a></div></div>
<div class="ttc" id="astruct_mo_f_e_m_1_1_volume_element_forces_and_sources_core_1_1_user_data_operator_html"><div class="ttname"><a href="struct_mo_f_e_m_1_1_volume_element_forces_and_sources_core_1_1_user_data_operator.html">MoFEM::VolumeElementForcesAndSourcesCore::UserDataOperator</a></div><div class="ttdef"><b>Definition:</b> <a href="_volume_element_forces_and_sources_core_8hpp_source.html#l00108">VolumeElementForcesAndSourcesCore.hpp:109</a></div></div>
<div class="ttc" id="astruct_mo_f_e_m_1_1_volume_element_forces_and_sources_core_1_1_user_data_operator_html_a27ada41314b2540fb0a722aad7257051"><div class="ttname"><a href="struct_mo_f_e_m_1_1_volume_element_forces_and_sources_core_1_1_user_data_operator.html#a27ada41314b2540fb0a722aad7257051">MoFEM::VolumeElementForcesAndSourcesCore::UserDataOperator::getVolume</a></div><div class="ttdeci">double getVolume() const</div><div class="ttdoc">element volume (linear geometry)</div><div class="ttdef"><b>Definition:</b> <a href="_volume_element_forces_and_sources_core_8hpp_source.html#l00161">VolumeElementForcesAndSourcesCore.hpp:161</a></div></div>
</div><!-- fragment --><p> Note that we integrate over tetrahedra. Thus operator <a class="el" href="struct_mo_f_e_m_1_1_volume_element_forces_and_sources_core_1_1_user_data_operator.html">MoFEM::VolumeElementForcesAndSourcesCore::UserDataOperator</a> is inherited. The class constructor <a class="el" href="struct_mix_transport_1_1_mix_transport_element_1_1_op_v_div_sigma___l2_hdiv.html#aa67b386a4a7c3f33867be392ae86b357" title="Constructor.">MixTransport::MixTransportElement::OpVDivSigma_L2Hdiv::OpVDivSigma_L2Hdiv</a> takes an argument PETSc matrix and set variable <em>sYmm</em> to false, since matrix \(\mathbf{C}\) is non-symmetric. Moreover, constructing operator we indicate that in the first argument of bilinear form we take field <em>FLUXES</em> and in the second argument of bilinear form we take field <em>VALUES</em>. Finally, in the constructor of operator we indicate that we like to loop over all possible combinations of entities on rows and columns, by setting <em>OPROWCOL</em> from enum type MoFEM::ForcesAndSourcesCore::UserDataOperator::OpType.</p>
<p >The real work is done in </p><div class="fragment"><div class="line">MoFEMErrorCode <a class="code hl_function" href="struct_mix_transport_1_1_mix_transport_element_1_1_op_v_div_sigma___l2_hdiv.html#a8553613978e25f39d15086b292011ea5">MixTransport::MixTransportElement::OpVDivSigma_L2Hdiv::doWork</a>(</div>
<div class="line">  <span class="keywordtype">int</span> row_side,<span class="keywordtype">int</span> col_side,</div>
<div class="line">  <a class="code hl_class" href="class_entity_type.html">EntityType</a> row_type,<a class="code hl_class" href="class_entity_type.html">EntityType</a> col_type,</div>
<div class="line">  EntitiesFieldData::EntData &amp;row_data,</div>
<div class="line">  EntitiesFieldData::EntData &amp;col_data</div>
<div class="line">);</div>
</div><!-- fragment --><p> <a class="el" href="namespace_mo_f_e_m.html" title="implementation of Data Operators for Forces and Sources">MoFEM</a> executes this method, in this particular case, for each combination of pairs  </p><p class="formulaDsp">
\[
\mathcal{E}_\textrm{row} \times \mathcal{E}_\textrm{col} = \{
\left(TRI_0, TET\right),
\left(TRI_1, TET\right),
\left(TRI_2, TET\right),
\left(TRI_4, TET\right),
\left(TET, TET\right)
\}
\]
</p>
<p> Note that function <a class="el" href="struct_mo_f_e_m_1_1_data_operator.html#a19219f04bba3938fd893898f128dcfb2" title="Operator for bi-linear form, usually to calculate values on left hand side.">MoFEM::DataOperator::doWork</a> takes as argument <b>row_side</b> and <b>col_side</b>, which represent a local index of processed entity on rows and columns, respectively. Also, <b>row_type</b> and <b>col_type</b> shows the type of entity, for example, tetrahedra or triangle in this case. To see more details about a type of entities, local indices and canonical numeration see <a class="el" href="citelist.html#CITEREF_tautges2010canonical">[48]</a>.</p>
<p >The <b>row_data</b> and <b>col_data</b> are data structures <a class="el" href="struct_mo_f_e_m_1_1_entities_field_data_1_1_ent_data.html" title="Data on single entity (This is passed as argument to DataOperator::doWork)">MoFEM::EntitiesFieldData::EntData</a> carrying information about values of base functions, global and local DOF indices, DOF values on evaluated entities. For example, you can get indices on the row using <b>row_data.getIndices()</b>, or matrix of base functions at integration point as follows </p><div class="fragment"><div class="line">MatrixDouble &amp;base_row_hdiv = row_data.getVectorN(gg);</div>
</div><!-- fragment --><p> In this case, each row of the matrix <b>base_row_hdiv</b> represents base function, where columns represent values of the element of base function vector. Look to <a class="el" href="struct_mo_f_e_m_1_1_entities_field_data_1_1_ent_data.html" title="Data on single entity (This is passed as argument to DataOperator::doWork)">MoFEM::EntitiesFieldData::EntData</a> to see a range of data which is accessible by this data structure.</p>
<p >From inside <a class="el" href="struct_mo_f_e_m_1_1_volume_element_forces_and_sources_core_1_1_user_data_operator.html">MoFEM::VolumeElementForcesAndSourcesCore::UserDataOperator</a>, we can access more finite element specific information, in that case volume element, for example, </p><div class="fragment"><div class="line"><span class="keywordtype">double</span> vol = getVolume(); <span class="comment">// get volume of element</span></div>
<div class="line">MarixDouble &amp;coords_at_gauss_pts = getCoordsAtGaussPts(); <span class="comment">// physical coordinates of integration points</span></div>
</div><!-- fragment --><p> and much more.</p>
<p >After above explanation, we focus on implementation itself, so finally we loop over integration points and calculate local matrix <b>C</b>, as follows </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> nb_gauss_pts = row_data.getVectorN().size1();</div>
<div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">int</span> gg = 0;gg&lt;nb_gauss_pts;gg++) {</div>
<div class="line">  <span class="keywordtype">double</span> w = getGaussPts()(3,gg)*getVolume();<span class="comment"></span></div>
<div class="line"><span class="comment">  /// FIXME:</span></div>
<div class="line"><span class="comment">  /// This in newer versions is removed. Using FTensor you can directly calulate </span></div>
<div class="line"><span class="comment">  /// trace of derivative of HDiv base function. </span></div>
<div class="line"><span class="comment"></span>  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> getDivergenceOfHDivBaseFunctions(</div>
<div class="line">    row_side,row_type,col_data,gg,divVec</div>
<div class="line">  ); </div>
<div class="line">  noalias(C) += w*outer_prod(divVec,row_data.getN(gg));</div>
<div class="line">}</div>
</div><!-- fragment --><p> Here we are using Boost uBlas functions to do operations on local matrices. You can alternatively use tensor library implemented in <a class="el" href="namespace_mo_f_e_m.html" title="implementation of Data Operators for Forces and Sources">MoFEM</a> (<a class="el" href="namespace_f_tensor.html">FTensor</a>) to do the job. Once local element matrix <b>C</b> is calculated, it is assembled into global matrix </p><div class="fragment"><div class="line"><a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> MatSetValues(</div>
<div class="line">  Aij,</div>
<div class="line">  nb_row,&amp;row_data.getIndices()[0],</div>
<div class="line">  nb_col,&amp;col_data.getIndices()[0],</div>
<div class="line">  &amp;C(0,0),ADD_VALUES</div>
<div class="line">); </div>
</div><!-- fragment --><p> where global indices on entities on rows and columns are easily retrieved by </p><div class="fragment"><div class="line">VectorInt &amp;global_row_indices = row_data.getIndices();</div>
<div class="line">VectorInt &amp;global_col_indices = col_data.getIndices();</div>
</div><!-- fragment --><p> where MatSetValues is a PETSc function documented here <a href="http://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/Mat/MatSetValues.html">http://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/Mat/MatSetValues.html</a></p>
<p >To solve problem, other blocks of matrix need to be assembled, for details how is done please see <a class="el" href="struct_mix_transport_1_1_mix_transport_element.html" title="Mix transport problem.">MixTransport::MixTransportElement</a>.</p>
<h2><a class="anchor" id="mixtransport_assmble_vector"></a>
Assembling vector</h2>
<p >At this stage you could see how to assemble vector, we focus attention on the assembly of Dirichlet boundary condition. Note the Dirichlet boundary conditions in this formulation, are natural, i.e. enforced in a weak sense when a system of linear equations is solved.</p>
<p >This time, we will calculate integral  </p><p class="formulaDsp">
\[
\mathbf{f} = \int_{\Gamma_\textrm{u}} \overline{u} \tau_{i} n_i \textrm{d}\Gamma =
\sum_\mathcal{T}^E \int_{\partial\mathcal{T}_\textrm{u}} \overline{u} \tau_{i} n_i \textrm{d}\partial\mathcal{T} =
\sum_\mathcal{T}^E \sum_\mathcal{E}^e \sum_{g=0}^N w_g \overline{u} B^\textrm{h-div}_{i} n_i
\]
</p>
<p> to do that we use following user operator class </p><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code hl_struct" href="struct_mix_transport_1_1_mix_transport_element_1_1_op_rhs_bc_on_values.html">MixTransport::MixTransportElement::OpRhsBcOnValues</a>: <span class="keyword">public</span> <a class="code hl_struct" href="struct_mo_f_e_m_1_1_face_element_forces_and_sources_core_1_1_user_data_operator.html">MoFEM::FaceElementForcesAndSourcesCore::UserDataOperator</a> {</div>
<div class="line">  <a class="code hl_struct" href="struct_mix_transport_1_1_mix_transport_element.html">MixTransport::MixTransportElement</a> &amp;<a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element_1_1_op_rhs_bc_on_values.html#a40cc82e3442917f9c56c3c4dda3317c8">cTx</a>;</div>
<div class="line">  Vec <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element_1_1_op_rhs_bc_on_values.html#a460f647c270a02e89364f6dfe89eb5a1">F</a>;</div>
<div class="line">  OpRhsBcOnValues(<a class="code hl_struct" href="struct_mix_transport_1_1_mix_transport_element.html">MixTransport::MixTransportElement</a> &amp;ctx,Vec f):</div>
<div class="line">  <a class="code hl_namespace" href="namespace_mo_f_e_m.html">MoFEM</a>::<a class="code hl_class" href="class_face_element_forces_and_sources_core.html">FaceElementForcesAndSourcesCore</a>::<a class="code hl_typedef" href="_hooke_element_8hpp.html#aee27a2ebc8f3d34a5c1ce71b2607d1a3">UserDataOperator</a>(<span class="stringliteral">&quot;FLUXES&quot;</span>,<a class="code hl_typedef" href="_hooke_element_8hpp.html#aee27a2ebc8f3d34a5c1ce71b2607d1a3">UserDataOperator</a>::<a class="code hl_enumvalue" href="struct_mo_f_e_m_1_1_forces_and_sources_core_1_1_user_data_operator.html#ac99de5ec6fa9bad3ccc5c5d60bc48e40a2d8d202342fada158e521ef00be491e1">OPROW</a>),</div>
<div class="line">  <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element_1_1_op_rhs_bc_on_values.html#a40cc82e3442917f9c56c3c4dda3317c8">cTx</a>(ctx),</div>
<div class="line">  <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element_1_1_op_rhs_bc_on_values.html#a460f647c270a02e89364f6dfe89eb5a1">F</a>(f) {}</div>
<div class="line">  VectorDouble Nf;</div>
<div class="line">  MoFEMErrorCode <a class="code hl_function" href="struct_mix_transport_1_1_mix_transport_element_1_1_op_rhs_bc_on_values.html#ade5d96c3098b9a5d64c6ddafca2c9b5d">doWork</a>(<span class="keywordtype">int</span> side,<a class="code hl_class" href="class_entity_type.html">EntityType</a> type,EntitiesFieldData::EntData &amp;data) {</div>
<div class="line">    <a class="code hl_define" href="definitions_8h.html#a6c0b52978f1abc88bf8a1ba70b7308e3">MoFEMFunctionBegin</a>;</div>
<div class="line">    <span class="keywordflow">if</span>(data.getFieldData().size()==0) <a class="code hl_define" href="definitions_8h.html#a59cd650c2f6d3e0dc1ad1c29821e8692">MoFEMFunctionReturnHot</a>(0);</div>
<div class="line">    Nf.resize(data.getIndices().size());</div>
<div class="line">    Nf.clear();</div>
<div class="line">    <span class="keywordtype">int</span> nb_gauss_pts = data.getVectorN().size1();</div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> gg = 0;gg&lt;nb_gauss_pts;gg++) {</div>
<div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> x = <a class="code hl_function" href="struct_mo_f_e_m_1_1_forces_and_sources_core_1_1_user_data_operator.html#a8c24ba4a5a415ae0b9b1a3da21cfe066">getCoordsAtGaussPts</a>()(gg,0);</div>
<div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> y = <a class="code hl_function" href="struct_mo_f_e_m_1_1_forces_and_sources_core_1_1_user_data_operator.html#a8c24ba4a5a415ae0b9b1a3da21cfe066">getCoordsAtGaussPts</a>()(gg,1);</div>
<div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> z = <a class="code hl_function" href="struct_mo_f_e_m_1_1_forces_and_sources_core_1_1_user_data_operator.html#a8c24ba4a5a415ae0b9b1a3da21cfe066">getCoordsAtGaussPts</a>()(gg,2);</div>
<div class="line">      <span class="keywordtype">double</span> value;</div>
<div class="line">      <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element_1_1_op_rhs_bc_on_values.html#a40cc82e3442917f9c56c3c4dda3317c8">cTx</a>.<a class="code hl_function" href="struct_mix_transport_1_1_mix_transport_element.html#aa2252de32c5c866aedff5f489b4ad60e">getBcOnValues</a>(x,y,z,value); </div>
<div class="line">      <span class="keywordtype">double</span> w = <a class="code hl_function" href="struct_mo_f_e_m_1_1_forces_and_sources_core_1_1_user_data_operator.html#ae90a09d3c36b0a4ed9ab1d99fcce0c1d">getGaussPts</a>()(2,gg)*0.5;</div>
<div class="line">      noalias(Nf) += w*prod(data.getVectorN(gg),<a class="code hl_function" href="struct_mo_f_e_m_1_1_face_element_forces_and_sources_core_1_1_user_data_operator.html#ab0d2c2cbdf4c35183c09a64d6f088e0c">getNormal</a>())*value;</div>
<div class="line">    }</div>
<div class="line">    <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> VecSetValues(<a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element_1_1_op_rhs_bc_on_values.html#a460f647c270a02e89364f6dfe89eb5a1">F</a>,data.getIndices().size(),&amp;data.getIndices()[0],&amp;Nf[0],ADD_VALUES); </div>
<div class="line">    <a class="code hl_define" href="definitions_8h.html#acb0a46d159695a01bf667313b7788b45">MoFEMFunctionReturn</a>(0);</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="ttc" id="astruct_mix_transport_1_1_mix_transport_element_1_1_op_rhs_bc_on_values_html"><div class="ttname"><a href="struct_mix_transport_1_1_mix_transport_element_1_1_op_rhs_bc_on_values.html">MixTransport::MixTransportElement::OpRhsBcOnValues</a></div><div class="ttdoc">calculate</div><div class="ttdef"><b>Definition:</b> <a href="_mix_transport_element_8hpp_source.html#l01068">MixTransportElement.hpp:1069</a></div></div>
<div class="ttc" id="astruct_mix_transport_1_1_mix_transport_element_1_1_op_rhs_bc_on_values_html_a40cc82e3442917f9c56c3c4dda3317c8"><div class="ttname"><a href="struct_mix_transport_1_1_mix_transport_element_1_1_op_rhs_bc_on_values.html#a40cc82e3442917f9c56c3c4dda3317c8">MixTransport::MixTransportElement::OpRhsBcOnValues::cTx</a></div><div class="ttdeci">MixTransportElement &amp; cTx</div><div class="ttdef"><b>Definition:</b> <a href="_mix_transport_element_8hpp_source.html#l01071">MixTransportElement.hpp:1071</a></div></div>
<div class="ttc" id="astruct_mix_transport_1_1_mix_transport_element_1_1_op_rhs_bc_on_values_html_a460f647c270a02e89364f6dfe89eb5a1"><div class="ttname"><a href="struct_mix_transport_1_1_mix_transport_element_1_1_op_rhs_bc_on_values.html#a460f647c270a02e89364f6dfe89eb5a1">MixTransport::MixTransportElement::OpRhsBcOnValues::F</a></div><div class="ttdeci">Vec F</div><div class="ttdef"><b>Definition:</b> <a href="_mix_transport_element_8hpp_source.html#l01072">MixTransportElement.hpp:1072</a></div></div>
<div class="ttc" id="astruct_mix_transport_1_1_mix_transport_element_1_1_op_rhs_bc_on_values_html_ade5d96c3098b9a5d64c6ddafca2c9b5d"><div class="ttname"><a href="struct_mix_transport_1_1_mix_transport_element_1_1_op_rhs_bc_on_values.html#ade5d96c3098b9a5d64c6ddafca2c9b5d">MixTransport::MixTransportElement::OpRhsBcOnValues::doWork</a></div><div class="ttdeci">MoFEMErrorCode doWork(int side, EntityType type, EntitiesFieldData::EntData &amp;data)</div><div class="ttdoc">Integrate boundary condition.</div><div class="ttdef"><b>Definition:</b> <a href="_mix_transport_element_8hpp_source.html#l01092">MixTransportElement.hpp:1092</a></div></div>
<div class="ttc" id="astruct_mix_transport_1_1_mix_transport_element_html"><div class="ttname"><a href="struct_mix_transport_1_1_mix_transport_element.html">MixTransport::MixTransportElement</a></div><div class="ttdoc">Mix transport problem.</div><div class="ttdef"><b>Definition:</b> <a href="_mix_transport_element_8hpp_source.html#l00029">MixTransportElement.hpp:29</a></div></div>
<div class="ttc" id="astruct_mix_transport_1_1_mix_transport_element_html_aa2252de32c5c866aedff5f489b4ad60e"><div class="ttname"><a href="struct_mix_transport_1_1_mix_transport_element.html#aa2252de32c5c866aedff5f489b4ad60e">MixTransport::MixTransportElement::getBcOnValues</a></div><div class="ttdeci">virtual MoFEMErrorCode getBcOnValues(const EntityHandle ent, const int gg, const double x, const double y, const double z, double &amp;value)</div><div class="ttdoc">evaluate natural (Dirichlet) boundary conditions</div><div class="ttdef"><b>Definition:</b> <a href="_mix_transport_element_8hpp_source.html#l00146">MixTransportElement.hpp:146</a></div></div>
<div class="ttc" id="astruct_mo_f_e_m_1_1_face_element_forces_and_sources_core_1_1_user_data_operator_html"><div class="ttname"><a href="struct_mo_f_e_m_1_1_face_element_forces_and_sources_core_1_1_user_data_operator.html">MoFEM::FaceElementForcesAndSourcesCore::UserDataOperator</a></div><div class="ttdoc">default operator for TRI element</div><div class="ttdef"><b>Definition:</b> <a href="_face_element_forces_and_sources_core_8hpp_source.html#l00095">FaceElementForcesAndSourcesCore.hpp:96</a></div></div>
<div class="ttc" id="astruct_mo_f_e_m_1_1_face_element_forces_and_sources_core_1_1_user_data_operator_html_ab0d2c2cbdf4c35183c09a64d6f088e0c"><div class="ttname"><a href="struct_mo_f_e_m_1_1_face_element_forces_and_sources_core_1_1_user_data_operator.html#ab0d2c2cbdf4c35183c09a64d6f088e0c">MoFEM::FaceElementForcesAndSourcesCore::UserDataOperator::getNormal</a></div><div class="ttdeci">VectorDouble &amp; getNormal()</div><div class="ttdoc">get triangle normal</div><div class="ttdef"><b>Definition:</b> <a href="_face_element_forces_and_sources_core_8hpp_source.html#l00244">FaceElementForcesAndSourcesCore.hpp:244</a></div></div>
<div class="ttc" id="astruct_mo_f_e_m_1_1_forces_and_sources_core_1_1_user_data_operator_html_a8c24ba4a5a415ae0b9b1a3da21cfe066"><div class="ttname"><a href="struct_mo_f_e_m_1_1_forces_and_sources_core_1_1_user_data_operator.html#a8c24ba4a5a415ae0b9b1a3da21cfe066">MoFEM::ForcesAndSourcesCore::UserDataOperator::getCoordsAtGaussPts</a></div><div class="ttdeci">MatrixDouble &amp; getCoordsAtGaussPts()</div><div class="ttdoc">Gauss points and weight, matrix (nb. of points x 3)</div><div class="ttdef"><b>Definition:</b> <a href="_forces_and_sources_core_8hpp_source.html#l01261">ForcesAndSourcesCore.hpp:1261</a></div></div>
<div class="ttc" id="astruct_mo_f_e_m_1_1_forces_and_sources_core_1_1_user_data_operator_html_ac99de5ec6fa9bad3ccc5c5d60bc48e40a2d8d202342fada158e521ef00be491e1"><div class="ttname"><a href="struct_mo_f_e_m_1_1_forces_and_sources_core_1_1_user_data_operator.html#ac99de5ec6fa9bad3ccc5c5d60bc48e40a2d8d202342fada158e521ef00be491e1">MoFEM::ForcesAndSourcesCore::UserDataOperator::OPROW</a></div><div class="ttdeci">@ OPROW</div><div class="ttdoc">operator doWork function is executed on FE rows</div><div class="ttdef"><b>Definition:</b> <a href="_forces_and_sources_core_8hpp_source.html#l00564">ForcesAndSourcesCore.hpp:564</a></div></div>
</div><!-- fragment --><p> Note that above class is derived from <a class="el" href="struct_mo_f_e_m_1_1_face_element_forces_and_sources_core_1_1_user_data_operator.html" title="default operator for TRI element">MoFEM::FaceElementForcesAndSourcesCore::UserDataOperator</a>, since we integrate over triangles where Dirichlet boundary conditions are set.</p>
<p >In this case, the constructor has two arguments, reference to <a class="el" href="struct_mix_transport_1_1_mix_transport_element.html" title="Mix transport problem.">MixTransport::MixTransportElement</a> object itself, and the right-hand side vector. We use <b>cTx</b> reference to access function evaluating boundary conditions. Constructing derived class, we are indicating that use field <em>FLUXES</em> and loop only over entities on the row, by setting OPROW from enum type MoFEM::ForcesAndSourcesCore::UserDataOperator::OpType.</p>
<p >The real work is done in </p><div class="fragment"><div class="line">MoFEMErrorCode <a class="code hl_function" href="struct_mix_transport_1_1_mix_transport_element_1_1_op_rhs_bc_on_values.html#ade5d96c3098b9a5d64c6ddafca2c9b5d">MixTransport::MixTransportElement::OpRhsBcOnValues::doWork</a>(</div>
<div class="line">  <span class="keywordtype">int</span> side,<a class="code hl_class" href="class_entity_type.html">EntityType</a> type,EntitiesFieldData::EntData &amp;data</div>
<div class="line">);</div>
</div><!-- fragment --><p> Since we loop only over row entities, the function <b>doWork</b>, looks different that that one to integrate matrix, it is simpler. It passes argument about <b>side</b> which is local number of entity for which operator is executed, <b>type</b> of entity and finally <b>data</b> structure</p>
<p ><a class="el" href="namespace_mo_f_e_m.html" title="implementation of Data Operators for Forces and Sources">MoFEM</a> executes this method, in this particular case, for only one entity, i.e.  </p><p class="formulaDsp">
\[
\mathcal{E}=\{ TRI \}
\]
</p>
<p> This is a consequence that testing functions on rows are in H-div space. Note that if the testing function would be in H-curl space, so for triangle loop on entities will involve three edges and triangle itself, from a testing function in H1 space loop will involve vertices, edges and triangle itself.</p>
<p >The integration takes place in these lines of the code </p><div class="fragment"><div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">int</span> gg = 0;gg&lt;nb_gauss_pts;gg++) {</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> x = getCoordsAtGaussPts()(gg,0);</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> y = getCoordsAtGaussPts()(gg,1);</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> z = getCoordsAtGaussPts()(gg,2);</div>
<div class="line">  <span class="keywordtype">double</span> value;</div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> cTx.<a class="code hl_function" href="struct_mix_transport_1_1_mix_transport_element.html#aa2252de32c5c866aedff5f489b4ad60e">getBcOnValues</a>(x,y,z,value); </div>
<div class="line">  <span class="keywordtype">double</span> w = getGaussPts()(2,gg)*0.5;</div>
<div class="line">  noalias(Nf) += w*prod(data.getVectorN(gg),getNormal())*value;</div>
<div class="line">}</div>
</div><!-- fragment --><p> where <b>getNormal()</b> get normal of the face and <b>cTx.getBcOnValues(x,y,z,value)</b> calculates value of boundary condition at coordinates of integration point.</p>
<p >Finally, local entity local vector is assembled, </p><div class="fragment"><div class="line"><a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> VecSetValues(<a class="code hl_enumvalue" href="free__surface_8cpp.html#a275fe82762dca6ff32ecbb73db0b3b84af382a63cc3d6491bf26b59e66f46826d">F</a>,data.getIndices().size(),&amp;data.getIndices()[0],&amp;Nf[0],ADD_VALUES); </div>
</div><!-- fragment --><p> where VecSetValues is PETSc function, see <a href="http://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/Vec/VecSetValues.html">http://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/Vec/VecSetValues.html</a> for details.</p>
<h1><a class="anchor" id="mixtransport_error"></a>
Evaluate error</h1>
<p >In this example to estimate posterior error we follow paper <a class="el" href="citelist.html#CITEREF_braess1996posteriori">[13]</a>. This error estimator works well for mesh-dependent norms, for which is reliable and efficient. However, it is not efficient in natural norm of \(H(\textrm{div},\Omega)\times L^2(\Omega)\) <a class="el" href="citelist.html#CITEREF_carstensen1997posteriori">[15]</a>.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000075">Todo:</a></b></dt><dd>You can find two other papers, <a class="el" href="citelist.html#CITEREF_carstensen1997posteriori">[15]</a> and <a class="el" href="citelist.html#CITEREF_ainsworth2007posteriori">[5]</a> which have efficient error estimator working in the natural norm. Those error estimators are not very different from an implementation point of view and could be easily added here.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000076">Todo:</a></b></dt><dd>To do numerical experiment testing error bound, we can solve the problem from <a class="el" href="citelist.html#CITEREF_demkowicz2011analysis">[20]</a> where analytical solutions are given. That will involve modification how boundary conditions are applied. Again, this is easy to implement, so if you are willing to add this to this documentation, it is very welcome.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000077">Todo:</a></b></dt><dd>Based on this work, you can write a good journal article about the efficiency of error estimator, taking into account two above remarks. If you are interested, we are happy to help. Extension to hp-adaptivity is straightforward.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000078">Todo:</a></b></dt><dd>A useful add-on is to construct preconditioner, which will take into account hierarchy created during hp-adaptivity, this involves some work, again we are happy to help.</dd></dl>
<p >Following paper <a class="el" href="citelist.html#CITEREF_braess1996posteriori">[13]</a>, we consider bounds of the error estimator in respect to the mesh-dependent norms  </p><p class="formulaDsp">
\[
\| \boldsymbol\tau \|_{0,h} := \left(
\| \boldsymbol\tau \|_0^2 + h \sum_{e\in\Gamma_h} \| \boldsymbol\tau \mathbf{n} \|^2_{0,e}
\right)^{1/2}
\]
</p>
<p> and  </p><p class="formulaDsp">
\[
|v|_{1,h} := \left(
\sum_{T\in\mathcal{T}_h} |v|^2_{1,T}
+
h^{-1}\sum_{e\in\Gamma_h} | J(v) |_{0,e}^2
\right)^{1/2}
\]
</p>
<p> where \(J(v)\) is a jump on the face \(e\) and h is is consistently replaced by the diameters of the actual elements and the lengths of the edges. \(\|\cdot\|_0\) and \(\|\cdot\|_1\) are Sobolev norms and semi-norm, respectively.</p>
<p >Our a posteriori estimator will be based on residuals. There will be contributions from the tetrahedra as  </p><p class="formulaDsp">
\[
\begin{split}
\eta_{T,R,1} &amp;:= \| \mathbf{A} \boldsymbol\sigma + \textrm{grad}[\mathbf{u}] \|_{0,T} \\
\eta_{T,R,2} &amp;:= h\| \textrm{div}[\boldsymbol\sigma] -\mathbf{f} \|_{0,T}
\end{split}
\]
</p>
<p> and from the jumps on the inter-element boundaries  </p><p class="formulaDsp">
\[
\eta_{e,R} := h^{-1/2} \| J(u) \|_{0,e}
\]
</p>
<p> The local error estimator is a weighted combination  </p><p class="formulaDsp">
\[
\eta_{T,R} :=
\left(
\eta^2_{T,R,1} + \eta^2_{T,R,2} + \sum_{e \in \partial T} \eta_{e,R}^2
\right)^{1/2}
\]
</p>
<p> For convenience, we will also refer to the global sum  </p><p class="formulaDsp">
\[
\eta_{T,R} :=
\left(
\sum_{T \in \mathcal{T}_h} \left[ \eta^2_{T,R,1} + \eta^2_{T,R,2} \right] + \sum_{e \in \partial T} \eta_{e,R}^2
\right)^{1/2}
\]
</p>
<p >This error estimator is reliable and efficient, and the upper bound is  </p><p class="formulaDsp">
\[
\|\boldsymbol\sigma^*-\boldsymbol\sigma\|_{0,h} + | u^* - u |_{1,h} \leq \frac{c}{1-\beta} \eta_R
\]
</p>
<p> where \(c\) depends on the shape parameter of \(\mathcal{T}_h\) and \(\beta\) is saturation parameter, see <a class="el" href="citelist.html#CITEREF_braess1996posteriori">[13]</a> for details. Lower bound is  </p><p class="formulaDsp">
\[
\eta_{T,R} \leq
\| \boldsymbol\sigma^* - \boldsymbol\sigma \|_{0,h} +
| u^* -  u |_{1,h} +
h \| f - \textrm{div}[\boldsymbol\sigma] \|_0
\]
</p>
<h2><a class="anchor" id="mixtransport_refinemnt_sequence"></a>
Calculate error and refine mesh</h2>
<p >Once we have residual error estimator we could do h-adaptivity, it is done by executing following code </p><div class="fragment"><div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">int</span> ll = 1;ll!=<a class="code hl_variable" href="level__set_8cpp.html#a4a62410a15dcd5a702a26f8bff4ae683">nb_levels</a>;ll++) {</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code hl_variable" href="level__set_8cpp.html#a4a62410a15dcd5a702a26f8bff4ae683">nb_levels</a> = ll;</div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> ufe.squashBits(); </div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> ufe.refineMesh(ufe,<a class="code hl_variable" href="level__set_8cpp.html#a4a62410a15dcd5a702a26f8bff4ae683">nb_levels</a>,<a class="code hl_variable" href="dg__projection_8cpp.html#ad7eceded84ace5678d9df3e44f47d475">order</a>); </div>
<div class="line">  ref_level = BitRefLevel().set(<a class="code hl_variable" href="level__set_8cpp.html#a4a62410a15dcd5a702a26f8bff4ae683">nb_levels</a>);</div>
<div class="line">  bc_flux_map.clear();</div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> ufe.addBoundaryElements(ref_level);</div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> ufe.buildProblem(ref_level); </div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> ufe.createMatrices(); </div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> ufe.solveLinearProblem(); </div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> ufe.calculateResidual(); </div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> ufe.evaluateError(); </div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> ufe.destroyMatrices(); </div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> ufe.postProc(</div>
<div class="line">    <span class="keyword">static_cast&lt;</span>std::ostringstream&amp;<span class="keyword">&gt;</span></div>
<div class="line">    (std::ostringstream().seekp(0) &lt;&lt; <span class="stringliteral">&quot;out_&quot;</span> &lt;&lt; <a class="code hl_variable" href="level__set_8cpp.html#a4a62410a15dcd5a702a26f8bff4ae683">nb_levels</a> &lt;&lt; <span class="stringliteral">&quot;.h5m&quot;</span>).str()</div>
<div class="line">  ); </div>
<div class="line">}</div>
</div><!-- fragment --><p> where <em>nb_levels</em> is the number of refinement levels.</p>
<p >We focus attention on mesh refinement procedures in next section, but first we will show how to calculate residual error estimator using user operators. Function evaluating error is implemented as follows </p><div class="fragment"><div class="line">MoFEMErrorCode <a class="code hl_function" href="struct_mix_transport_1_1_mix_transport_element.html#a236b1357594649ba4aeead9a5e9cfaa5">MixTransport::MixTransportElement::evaluateError</a>() {</div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#a6c0b52978f1abc88bf8a1ba70b7308e3">MoFEMFunctionBegin</a>;</div>
<div class="line">  <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element.html#a90d6e69d5d612ef52f151b73ff770143">errorMap</a>.clear();</div>
<div class="line">  <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element.html#ae625b646f20954d6815221981ada37c9">sumErrorFlux</a> = 0;</div>
<div class="line">  <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element.html#ab412c80e7ec70111f97dc4ec4d7716ac">sumErrorDiv</a> = 0;</div>
<div class="line">  <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element.html#a61e2bd85b3eb99e24eee0343951f666c">sumErrorJump</a> = 0;</div>
<div class="line">  <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element.html#a91f92ecbe4915298309d1aa4c49a85b8">feTri</a>.<a class="code hl_function" href="struct_mo_f_e_m_1_1_forces_and_sources_core.html#aba236b9f5892be49d6ae6756b12f5a88">getOpPtrVector</a>().clear();</div>
<div class="line">  <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element.html#a91f92ecbe4915298309d1aa4c49a85b8">feTri</a>.<a class="code hl_function" href="struct_mo_f_e_m_1_1_forces_and_sources_core.html#aba236b9f5892be49d6ae6756b12f5a88">getOpPtrVector</a>().push_back(<span class="keyword">new</span> <a class="code hl_struct" href="struct_mix_transport_1_1_mix_transport_element_1_1_op_skeleton.html">MixTransport::MixTransportElement::OpSkeleton</a>(*<span class="keyword">this</span>,<span class="stringliteral">&quot;FLUXES&quot;</span>));</div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element.html#a68f344cfbf6b208f5930951ca427f8f7">mField</a>.<a class="code hl_function" href="group__mofem__loops.html#gab3dc3302de79f29b26605579d77797c9">loop_finite_elements</a>(<span class="stringliteral">&quot;MIX&quot;</span>,<span class="stringliteral">&quot;MIX_SKELETON&quot;</span>,<a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element.html#a91f92ecbe4915298309d1aa4c49a85b8">feTri</a>,0,<a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element.html#a68f344cfbf6b208f5930951ca427f8f7">mField</a>.<a class="code hl_function" href="struct_mo_f_e_m_1_1_core_interface.html#a093526a60371b07213a0be2aaf7afa35">get_comm_size</a>()); </div>
<div class="line">  <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element.html#aad3b7f3ea9e46ab87a9c17b47fd63447">feVol</a>.<a class="code hl_function" href="struct_mo_f_e_m_1_1_forces_and_sources_core.html#aba236b9f5892be49d6ae6756b12f5a88">getOpPtrVector</a>().clear();</div>
<div class="line">  <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element.html#aad3b7f3ea9e46ab87a9c17b47fd63447">feVol</a>.<a class="code hl_function" href="struct_mo_f_e_m_1_1_forces_and_sources_core.html#aba236b9f5892be49d6ae6756b12f5a88">getOpPtrVector</a>().push_back(<span class="keyword">new</span> <a class="code hl_struct" href="struct_mix_transport_1_1_mix_transport_element_1_1_op_flux_divergence_at_gauss_pts.html">MixTransport::MixTransportElement::OpFluxDivergenceAtGaussPts</a>(*<span class="keyword">this</span>,<span class="stringliteral">&quot;FLUXES&quot;</span>));</div>
<div class="line">  <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element.html#aad3b7f3ea9e46ab87a9c17b47fd63447">feVol</a>.<a class="code hl_function" href="struct_mo_f_e_m_1_1_forces_and_sources_core.html#aba236b9f5892be49d6ae6756b12f5a88">getOpPtrVector</a>().push_back(<span class="keyword">new</span> <a class="code hl_struct" href="struct_mix_transport_1_1_mix_transport_element_1_1_op_values_gradient_at_gauss_pts.html">MixTransport::MixTransportElement::OpValuesGradientAtGaussPts</a>(*<span class="keyword">this</span>,<span class="stringliteral">&quot;VALUES&quot;</span>));</div>
<div class="line">  <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element.html#aad3b7f3ea9e46ab87a9c17b47fd63447">feVol</a>.<a class="code hl_function" href="struct_mo_f_e_m_1_1_forces_and_sources_core.html#aba236b9f5892be49d6ae6756b12f5a88">getOpPtrVector</a>().push_back(<span class="keyword">new</span> <a class="code hl_struct" href="struct_mix_transport_1_1_mix_transport_element_1_1_op_error.html">MixTransport::MixTransportElement::OpError</a>(*<span class="keyword">this</span>,<span class="stringliteral">&quot;VALUES&quot;</span>));</div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element.html#a68f344cfbf6b208f5930951ca427f8f7">mField</a>.<a class="code hl_function" href="group__mofem__loops.html#gab3dc3302de79f29b26605579d77797c9">loop_finite_elements</a>(<span class="stringliteral">&quot;MIX&quot;</span>,<span class="stringliteral">&quot;MIX&quot;</span>,<a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element.html#aad3b7f3ea9e46ab87a9c17b47fd63447">feVol</a>,0,<a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element.html#a68f344cfbf6b208f5930951ca427f8f7">mField</a>.<a class="code hl_function" href="struct_mo_f_e_m_1_1_core_interface.html#a093526a60371b07213a0be2aaf7afa35">get_comm_size</a>()); </div>
<div class="line">  <span class="keyword">const</span> Problem *problem_ptr;</div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element.html#a68f344cfbf6b208f5930951ca427f8f7">mField</a>.<a class="code hl_function" href="group__mofem__access.html#ga311e33eaba451897a151813e8ea6fae4">get_problem</a>(<span class="stringliteral">&quot;MIX&quot;</span>,&amp;problem_ptr); </div>
<div class="line">  PetscPrintf(</div>
<div class="line">    <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element.html#a68f344cfbf6b208f5930951ca427f8f7">mField</a>.<a class="code hl_function" href="struct_mo_f_e_m_1_1_core_interface.html#a9b2bc8c1b980f49d31a0b5f7fbe756f5">get_comm</a>(),</div>
<div class="line">    <span class="stringliteral">&quot;Nb dofs %d error flux^2 = %6.4e error div^2 = %6.4e error jump^2 = %6.4e error tot^2 = %6.4e\n&quot;</span>,</div>
<div class="line">    problem_ptr-&gt;getNbDofsRow(),</div>
<div class="line">    <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element.html#ae625b646f20954d6815221981ada37c9">sumErrorFlux</a>,<a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element.html#ab412c80e7ec70111f97dc4ec4d7716ac">sumErrorDiv</a>,<a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element.html#a61e2bd85b3eb99e24eee0343951f666c">sumErrorJump</a>,<a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element.html#ae625b646f20954d6815221981ada37c9">sumErrorFlux</a>+<a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element.html#ab412c80e7ec70111f97dc4ec4d7716ac">sumErrorDiv</a>+<a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element.html#a61e2bd85b3eb99e24eee0343951f666c">sumErrorJump</a></div>
<div class="line">  );</div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#acb0a46d159695a01bf667313b7788b45">MoFEMFunctionReturn</a>(0);</div>
<div class="line">}</div>
<div class="ttc" id="agroup__mofem__access_html_ga311e33eaba451897a151813e8ea6fae4"><div class="ttname"><a href="group__mofem__access.html#ga311e33eaba451897a151813e8ea6fae4">MoFEM::CoreInterface::get_problem</a></div><div class="ttdeci">virtual const Problem * get_problem(const std::string problem_name) const =0</div><div class="ttdoc">Get the problem object.</div></div>
<div class="ttc" id="agroup__mofem__loops_html_gab3dc3302de79f29b26605579d77797c9"><div class="ttname"><a href="group__mofem__loops.html#gab3dc3302de79f29b26605579d77797c9">MoFEM::CoreInterface::loop_finite_elements</a></div><div class="ttdeci">virtual MoFEMErrorCode loop_finite_elements(const std::string problem_name, const std::string &amp;fe_name, FEMethod &amp;method, boost::shared_ptr&lt; NumeredEntFiniteElement_multiIndex &gt; fe_ptr=nullptr, MoFEMTypes bh=MF_EXIST, CacheTupleWeakPtr cache_ptr=CacheTupleSharedPtr(), int verb=DEFAULT_VERBOSITY)=0</div><div class="ttdoc">Make a loop over finite elements.</div></div>
<div class="ttc" id="astruct_mix_transport_1_1_mix_transport_element_1_1_op_error_html"><div class="ttname"><a href="struct_mix_transport_1_1_mix_transport_element_1_1_op_error.html">MixTransport::MixTransportElement::OpError</a></div><div class="ttdoc">calculate error evaluator</div><div class="ttdef"><b>Definition:</b> <a href="_mix_transport_element_8hpp_source.html#l01367">MixTransportElement.hpp:1368</a></div></div>
<div class="ttc" id="astruct_mix_transport_1_1_mix_transport_element_1_1_op_skeleton_html"><div class="ttname"><a href="struct_mix_transport_1_1_mix_transport_element_1_1_op_skeleton.html">MixTransport::MixTransportElement::OpSkeleton</a></div><div class="ttdoc">calculate jump on entities</div><div class="ttdef"><b>Definition:</b> <a href="_mix_transport_element_8hpp_source.html#l01467">MixTransportElement.hpp:1468</a></div></div>
<div class="ttc" id="astruct_mix_transport_1_1_mix_transport_element_1_1_op_values_gradient_at_gauss_pts_html"><div class="ttname"><a href="struct_mix_transport_1_1_mix_transport_element_1_1_op_values_gradient_at_gauss_pts.html">MixTransport::MixTransportElement::OpValuesGradientAtGaussPts</a></div><div class="ttdoc">Calculate gradients of values at integration points.</div><div class="ttdef"><b>Definition:</b> <a href="_mix_transport_element_8hpp_source.html#l01282">MixTransportElement.hpp:1283</a></div></div>
<div class="ttc" id="astruct_mix_transport_1_1_mix_transport_element_html_a236b1357594649ba4aeead9a5e9cfaa5"><div class="ttname"><a href="struct_mix_transport_1_1_mix_transport_element.html#a236b1357594649ba4aeead9a5e9cfaa5">MixTransport::MixTransportElement::evaluateError</a></div><div class="ttdeci">MoFEMErrorCode evaluateError()</div><div class="ttdoc">Calculate error on elements.</div><div class="ttdef"><b>Definition:</b> <a href="_mix_transport_element_8hpp_source.html#l00670">MixTransportElement.hpp:670</a></div></div>
<div class="ttc" id="astruct_mix_transport_1_1_mix_transport_element_html_a61e2bd85b3eb99e24eee0343951f666c"><div class="ttname"><a href="struct_mix_transport_1_1_mix_transport_element.html#a61e2bd85b3eb99e24eee0343951f666c">MixTransport::MixTransportElement::sumErrorJump</a></div><div class="ttdeci">double sumErrorJump</div><div class="ttdef"><b>Definition:</b> <a href="_mix_transport_element_8hpp_source.html#l01363">MixTransportElement.hpp:1363</a></div></div>
<div class="ttc" id="astruct_mix_transport_1_1_mix_transport_element_html_a90d6e69d5d612ef52f151b73ff770143"><div class="ttname"><a href="struct_mix_transport_1_1_mix_transport_element.html#a90d6e69d5d612ef52f151b73ff770143">MixTransport::MixTransportElement::errorMap</a></div><div class="ttdeci">map&lt; double, EntityHandle &gt; errorMap</div><div class="ttdef"><b>Definition:</b> <a href="_mix_transport_element_8hpp_source.html#l01360">MixTransportElement.hpp:1360</a></div></div>
<div class="ttc" id="astruct_mix_transport_1_1_mix_transport_element_html_a91f92ecbe4915298309d1aa4c49a85b8"><div class="ttname"><a href="struct_mix_transport_1_1_mix_transport_element.html#a91f92ecbe4915298309d1aa4c49a85b8">MixTransport::MixTransportElement::feTri</a></div><div class="ttdeci">MyTriFE feTri</div><div class="ttdoc">Instance of surface element.</div><div class="ttdef"><b>Definition:</b> <a href="_mix_transport_element_8hpp_source.html#l00060">MixTransportElement.hpp:60</a></div></div>
<div class="ttc" id="astruct_mix_transport_1_1_mix_transport_element_html_aad3b7f3ea9e46ab87a9c17b47fd63447"><div class="ttname"><a href="struct_mix_transport_1_1_mix_transport_element.html#aad3b7f3ea9e46ab87a9c17b47fd63447">MixTransport::MixTransportElement::feVol</a></div><div class="ttdeci">MyVolumeFE feVol</div><div class="ttdoc">Instance of volume element.</div><div class="ttdef"><b>Definition:</b> <a href="_mix_transport_element_8hpp_source.html#l00046">MixTransportElement.hpp:46</a></div></div>
<div class="ttc" id="astruct_mix_transport_1_1_mix_transport_element_html_ab412c80e7ec70111f97dc4ec4d7716ac"><div class="ttname"><a href="struct_mix_transport_1_1_mix_transport_element.html#ab412c80e7ec70111f97dc4ec4d7716ac">MixTransport::MixTransportElement::sumErrorDiv</a></div><div class="ttdeci">double sumErrorDiv</div><div class="ttdef"><b>Definition:</b> <a href="_mix_transport_element_8hpp_source.html#l01362">MixTransportElement.hpp:1362</a></div></div>
<div class="ttc" id="astruct_mix_transport_1_1_mix_transport_element_html_ae625b646f20954d6815221981ada37c9"><div class="ttname"><a href="struct_mix_transport_1_1_mix_transport_element.html#ae625b646f20954d6815221981ada37c9">MixTransport::MixTransportElement::sumErrorFlux</a></div><div class="ttdeci">double sumErrorFlux</div><div class="ttdef"><b>Definition:</b> <a href="_mix_transport_element_8hpp_source.html#l01361">MixTransportElement.hpp:1361</a></div></div>
<div class="ttc" id="astruct_mo_f_e_m_1_1_core_interface_html_a093526a60371b07213a0be2aaf7afa35"><div class="ttname"><a href="struct_mo_f_e_m_1_1_core_interface.html#a093526a60371b07213a0be2aaf7afa35">MoFEM::CoreInterface::get_comm_size</a></div><div class="ttdeci">virtual int get_comm_size() const =0</div></div>
<div class="ttc" id="astruct_mo_f_e_m_1_1_core_interface_html_a9b2bc8c1b980f49d31a0b5f7fbe756f5"><div class="ttname"><a href="struct_mo_f_e_m_1_1_core_interface.html#a9b2bc8c1b980f49d31a0b5f7fbe756f5">MoFEM::CoreInterface::get_comm</a></div><div class="ttdeci">virtual MPI_Comm &amp; get_comm() const =0</div></div>
</div><!-- fragment --><p >Once the problem is solved, first we need to calculate jump on the skeleton. We simply doing this by applying the same procedure like before, adding appropriate entity operator to the element object and looping over all triangular elements in the problem, as follows </p><div class="fragment"><div class="line">feTri.getOpPtrVector().push_back(<span class="keyword">new</span> <a class="code hl_struct" href="struct_mix_transport_1_1_mix_transport_element_1_1_op_skeleton.html">MixTransport::MixTransportElement::OpSkeleton</a>(*<span class="keyword">this</span>,<span class="stringliteral">&quot;FLUXES&quot;</span>));</div>
<div class="line"><a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> mField.loop_finite_elements(<span class="stringliteral">&quot;MIX&quot;</span>,<span class="stringliteral">&quot;MIX_SKELETON&quot;</span>,feTri,0,mField.get_comm_size()); </div>
</div><!-- fragment --><p> Note that entity operator <a class="el" href="struct_mix_transport_1_1_mix_transport_element_1_1_op_skeleton.html" title="calculate jump on entities">MixTransport::MixTransportElement::OpSkeleton</a> is executed for every element <em>MIX_SKELETON</em>. How this entity operator is implemented is described in the following section.</p>
<p >Once the jump is calculated, we can evaluate error estimator, by running sequence of entity operators on each volume element, as follows, </p><div class="fragment"><div class="line">feVol.getOpPtrVector().push_back(<span class="keyword">new</span> <a class="code hl_struct" href="struct_mix_transport_1_1_mix_transport_element_1_1_op_flux_divergence_at_gauss_pts.html">MixTransport::MixTransportElement::OpFluxDivergenceAtGaussPts</a>(*<span class="keyword">this</span>,<span class="stringliteral">&quot;FLUXES&quot;</span>));</div>
<div class="line">  feVol.getOpPtrVector().push_back(<span class="keyword">new</span> <a class="code hl_struct" href="struct_mix_transport_1_1_mix_transport_element_1_1_op_values_gradient_at_gauss_pts.html">MixTransport::MixTransportElement::OpValuesGradientAtGaussPts</a>(*<span class="keyword">this</span>,<span class="stringliteral">&quot;VALUES&quot;</span>));</div>
<div class="line">  feVol.getOpPtrVector().push_back(<span class="keyword">new</span> <a class="code hl_struct" href="struct_mix_transport_1_1_mix_transport_element_1_1_op_error.html">MixTransport::MixTransportElement::OpError</a>(*<span class="keyword">this</span>,<span class="stringliteral">&quot;VALUES&quot;</span>));</div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> mField.loop_finite_elements(<span class="stringliteral">&quot;MIX&quot;</span>,<span class="stringliteral">&quot;MIX&quot;</span>,feVol,0,mField.get_comm_size()); </div>
</div><!-- fragment --><p >Once we loop over all elements and calculate error, we aggregate all element contributions in <b>sumErrorFlux</b> and <b>sumErrorDiv</b> and <b>sumErrorJump</b> which are \(\eta^2_{T,R,1}\), \(\eta^2_{T,R,2}\) and \(\eta^2_{e,R}\), respectively.</p>
<h2><a class="anchor" id="mixtransport_jump"></a>
Calculate jump on the skeleton</h2>
<p >At this point, we will describe how to integrate over skeleton to get jumps on the faces. That involves loop over triangles and then for each triangle visiting adjacent tetrahedral, one by one.</p>
<p >On each triangle, we set some integration rule, which integration points are projected on appropriate sides of two adjacent tetrahedra. Next, for each tetrahedron, base functions (and derivatives) are evaluated at integration points and values of function \(u\) calculated. Once values on each tetrahedron are computed we do loop over all integration points on face and calculate norm of the jump, i.e. \(\eta_{e,R}\).</p>
<p ><a class="el" href="namespace_mo_f_e_m.html" title="implementation of Data Operators for Forces and Sources">MoFEM</a> has some dedicated data structures and methods to do this type of integration. Those procedures were implemented to give user ability to implement Discontinuous (Petrov) Galerkin, contact mechanics or other approaches involving integration on skeleton where information from adjacent entities is needed.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code hl_struct" href="struct_mix_transport_1_1_mix_transport_element_1_1_op_skeleton.html">MixTransport::MixTransportElement::OpSkeleton</a>: <span class="keyword">public</span> <a class="code hl_struct" href="struct_mo_f_e_m_1_1_face_element_forces_and_sources_core_1_1_user_data_operator.html">MoFEM::FaceElementForcesAndSourcesCore::UserDataOperator</a> {</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">  /**</span></div>
<div class="line"><span class="comment">   * \brief volume element to get values from adjacent tets to face</span></div>
<div class="line"><span class="comment">   */</span></div>
<div class="line">  <a class="code hl_struct" href="struct_mo_f_e_m_1_1_volume_element_forces_and_sources_core_on_side.html">MoFEM::VolumeElementForcesAndSourcesCoreOnSide</a> <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element_1_1_op_skeleton.html#a81bc2f88a5d61fa74e7ef6ab24fe2c22">volSideFe</a>;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">  /** store values at integration point, key of the map is sense of face in</span></div>
<div class="line"><span class="comment">   * respect to adjacent tetrahedra</span></div>
<div class="line"><span class="comment">   */</span></div>
<div class="line">  map&lt;int,VectorDouble&gt; <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element_1_1_op_skeleton.html#a6f66ea5cc0a3384d5700ede04aa8467a">valMap</a>;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">  /**</span></div>
<div class="line"><span class="comment">   * \brief calculate values on adjacent tetrahedra to face</span></div>
<div class="line"><span class="comment">   */</span></div>
<div class="line">  <span class="keyword">struct </span>OpVolSide;</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_struct" href="struct_mix_transport_1_1_mix_transport_element.html">MixTransport::MixTransportElement</a> &amp;<a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element_1_1_op_skeleton.html#aef3f15c3707fadaa7191ae63adc2333c">cTx</a>;</div>
<div class="line"> </div>
<div class="line">  OpSkeleton(</div>
<div class="line">    <a class="code hl_struct" href="struct_mix_transport_1_1_mix_transport_element.html">MixTransport::MixTransportElement</a> &amp;ctx,<span class="keyword">const</span> std::string flux_name</div>
<div class="line">  ):</div>
<div class="line">  <a class="code hl_namespace" href="namespace_mo_f_e_m.html">MoFEM</a>::<a class="code hl_class" href="class_face_element_forces_and_sources_core.html">FaceElementForcesAndSourcesCore</a>::<a class="code hl_typedef" href="_hooke_element_8hpp.html#aee27a2ebc8f3d34a5c1ce71b2607d1a3">UserDataOperator</a>(flux_name,<a class="code hl_typedef" href="_hooke_element_8hpp.html#aee27a2ebc8f3d34a5c1ce71b2607d1a3">UserDataOperator</a>::<a class="code hl_enumvalue" href="struct_mo_f_e_m_1_1_forces_and_sources_core_1_1_user_data_operator.html#ac99de5ec6fa9bad3ccc5c5d60bc48e40a2d8d202342fada158e521ef00be491e1">OPROW</a>),</div>
<div class="line">  <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element_1_1_op_skeleton.html#a81bc2f88a5d61fa74e7ef6ab24fe2c22">volSideFe</a>(ctx.<a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element.html#a68f344cfbf6b208f5930951ca427f8f7">mField</a>),</div>
<div class="line">  <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element_1_1_op_skeleton.html#aef3f15c3707fadaa7191ae63adc2333c">cTx</a>(ctx) {</div>
<div class="line">    <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element_1_1_op_skeleton.html#a81bc2f88a5d61fa74e7ef6ab24fe2c22">volSideFe</a>.getOpPtrVector().push_back(<span class="keyword">new</span> OpSkeleton::OpVolSide(<a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element_1_1_op_skeleton.html#a6f66ea5cc0a3384d5700ede04aa8467a">valMap</a>));</div>
<div class="line">  }</div>
<div class="line">  MoFEMErrorCode <a class="code hl_function" href="struct_mix_transport_1_1_mix_transport_element_1_1_op_skeleton.html#aebfa55a1d63e69d37ed9a8c4eb93d4ac">doWork</a>(<span class="keywordtype">int</span> side,<a class="code hl_class" href="class_entity_type.html">EntityType</a> type,EntitiesFieldData::EntData &amp;data);</div>
<div class="line">};</div>
<div class="ttc" id="astruct_mix_transport_1_1_mix_transport_element_1_1_op_skeleton_html_a6f66ea5cc0a3384d5700ede04aa8467a"><div class="ttname"><a href="struct_mix_transport_1_1_mix_transport_element_1_1_op_skeleton.html#a6f66ea5cc0a3384d5700ede04aa8467a">MixTransport::MixTransportElement::OpSkeleton::valMap</a></div><div class="ttdeci">map&lt; int, VectorDouble &gt; valMap</div><div class="ttdef"><b>Definition:</b> <a href="_mix_transport_element_8hpp_source.html#l01478">MixTransportElement.hpp:1478</a></div></div>
<div class="ttc" id="astruct_mix_transport_1_1_mix_transport_element_1_1_op_skeleton_html_a81bc2f88a5d61fa74e7ef6ab24fe2c22"><div class="ttname"><a href="struct_mix_transport_1_1_mix_transport_element_1_1_op_skeleton.html#a81bc2f88a5d61fa74e7ef6ab24fe2c22">MixTransport::MixTransportElement::OpSkeleton::volSideFe</a></div><div class="ttdeci">VolumeElementForcesAndSourcesCoreOnSide volSideFe</div><div class="ttdoc">volume element to get values from adjacent tets to face</div><div class="ttdef"><b>Definition:</b> <a href="_mix_transport_element_8hpp_source.html#l01473">MixTransportElement.hpp:1473</a></div></div>
<div class="ttc" id="astruct_mix_transport_1_1_mix_transport_element_1_1_op_skeleton_html_aebfa55a1d63e69d37ed9a8c4eb93d4ac"><div class="ttname"><a href="struct_mix_transport_1_1_mix_transport_element_1_1_op_skeleton.html#aebfa55a1d63e69d37ed9a8c4eb93d4ac">MixTransport::MixTransportElement::OpSkeleton::doWork</a></div><div class="ttdeci">MoFEMErrorCode doWork(int side, EntityType type, EntitiesFieldData::EntData &amp;data)</div><div class="ttdef"><b>Definition:</b> <a href="_mix_transport_element_8hpp_source.html#l01514">MixTransportElement.hpp:1514</a></div></div>
<div class="ttc" id="astruct_mix_transport_1_1_mix_transport_element_1_1_op_skeleton_html_aef3f15c3707fadaa7191ae63adc2333c"><div class="ttname"><a href="struct_mix_transport_1_1_mix_transport_element_1_1_op_skeleton.html#aef3f15c3707fadaa7191ae63adc2333c">MixTransport::MixTransportElement::OpSkeleton::cTx</a></div><div class="ttdeci">MixTransportElement &amp; cTx</div><div class="ttdef"><b>Definition:</b> <a href="_mix_transport_element_8hpp_source.html#l01505">MixTransportElement.hpp:1505</a></div></div>
<div class="ttc" id="astruct_mo_f_e_m_1_1_volume_element_forces_and_sources_core_on_side_html"><div class="ttname"><a href="struct_mo_f_e_m_1_1_volume_element_forces_and_sources_core_on_side.html">MoFEM::VolumeElementForcesAndSourcesCoreOnSide</a></div><div class="ttdoc">Base volume element used to integrate on skeleton.</div><div class="ttdef"><b>Definition:</b> <a href="_volume_element_forces_and_sources_core_on_side_8hpp_source.html#l00022">VolumeElementForcesAndSourcesCoreOnSide.hpp:23</a></div></div>
</div><!-- fragment --><p >User entity operator <a class="el" href="struct_mix_transport_1_1_mix_transport_element_1_1_op_skeleton.html" title="calculate jump on entities">MixTransport::MixTransportElement::OpSkeleton</a> has nested volume element and nested entity operator to integrate over it. Note that nested volume element is a class <a class="el" href="struct_mo_f_e_m_1_1_volume_element_forces_and_sources_core_on_side.html" title="Base volume element used to integrate on skeleton.">MoFEM::VolumeElementForcesAndSourcesCoreOnSide</a>, that is inherited from <a class="el" href="struct_mo_f_e_m_1_1_volume_element_forces_and_sources_core.html" title="Volume finite element base.">MoFEM::VolumeElementForcesAndSourcesCore</a>. This derived class has additional functionality, which if an instance of it is called from face operator, it projects face integration points on the appropriate face of adjacent tetrahedra. As results volume, base functions are evaluated at integration points which come from currently evaluated skeleton face.</p>
<p >That nested volume element, here having instance <b>volSideFe</b>, run nested operator class <a class="el" href="struct_mix_transport_1_1_mix_transport_element_1_1_op_skeleton_1_1_op_vol_side.html" title="calculate values on adjacent tetrahedra to face">MixTransport::MixTransportElement::OpSkeleton::OpVolSide</a>, this class is derived form <a class="el" href="struct_mo_f_e_m_1_1_volume_element_forces_and_sources_core_on_side_1_1_user_data_operator.html" title="default operator for TET element">MoFEM::VolumeElementForcesAndSourcesCoreOnSide::UserDataOperator</a>. Again this class gives access to additional information which is useful when integration is over skeleton, like face normal vector, face area, etc. Note that nested operator <a class="el" href="struct_mix_transport_1_1_mix_transport_element_1_1_op_skeleton_1_1_op_vol_side.html" title="calculate values on adjacent tetrahedra to face">MixTransport::MixTransportElement::OpSkeleton::OpVolSide</a> is added to nested volume instance <b>volSideFe</b>, in constructor of face operator with the command line </p><div class="fragment"><div class="line">volSideFe.<a class="code hl_function" href="struct_mo_f_e_m_1_1_forces_and_sources_core.html#aba236b9f5892be49d6ae6756b12f5a88">getOpPtrVector</a>().push_back(<span class="keyword">new</span> MixTransport::MixTransportElement::OpSkeleton::OpSkeleton::OpVolSide(valMap));</div>
</div><!-- fragment --><p >The example of implementation of nested volume element operator looks as follows </p><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code hl_struct" href="struct_mix_transport_1_1_mix_transport_element_1_1_op_skeleton_1_1_op_vol_side.html">MixTransport::MixTransportElement::OpSkeleton::OpVolSide</a>: <span class="keyword">public</span> <a class="code hl_struct" href="struct_mo_f_e_m_1_1_volume_element_forces_and_sources_core_on_side_1_1_user_data_operator.html">MoFEM::VolumeElementForcesAndSourcesCoreOnSide::UserDataOperator</a> {</div>
<div class="line">  map&lt;int,VectorDouble&gt; &amp;<a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element_1_1_op_skeleton_1_1_op_vol_side.html#a564e8c6dd394f42cf1de140fdee92081">valMap</a>;</div>
<div class="line">  OpVolSide(map&lt;int,VectorDouble&gt; &amp;val_map):</div>
<div class="line">  VolumeElementForcesAndSourcesCoreOnSide::<a class="code hl_typedef" href="_hooke_element_8hpp.html#aee27a2ebc8f3d34a5c1ce71b2607d1a3">UserDataOperator</a>(<span class="stringliteral">&quot;VALUES&quot;</span>,<a class="code hl_typedef" href="_hooke_element_8hpp.html#aee27a2ebc8f3d34a5c1ce71b2607d1a3">UserDataOperator</a>::<a class="code hl_enumvalue" href="struct_mo_f_e_m_1_1_forces_and_sources_core_1_1_user_data_operator.html#ac99de5ec6fa9bad3ccc5c5d60bc48e40a2d8d202342fada158e521ef00be491e1">OPROW</a>),</div>
<div class="line">  <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element_1_1_op_skeleton_1_1_op_vol_side.html#a564e8c6dd394f42cf1de140fdee92081">valMap</a>(val_map) {</div>
<div class="line">  }</div>
<div class="line">  MoFEMErrorCode <a class="code hl_function" href="struct_mix_transport_1_1_mix_transport_element_1_1_op_skeleton_1_1_op_vol_side.html#a998e6f8d52bd3cc3686a6f1b335a24aa">doWork</a>(<span class="keywordtype">int</span> side, <a class="code hl_class" href="class_entity_type.html">EntityType</a> type,EntitiesFieldData::EntData &amp;data) {</div>
<div class="line">    <a class="code hl_define" href="definitions_8h.html#a6c0b52978f1abc88bf8a1ba70b7308e3">MoFEMFunctionBegin</a>;</div>
<div class="line">    <span class="keywordflow">if</span>(data.getFieldData().size() == 0)  <a class="code hl_define" href="definitions_8h.html#a59cd650c2f6d3e0dc1ad1c29821e8692">MoFEMFunctionReturnHot</a>(0);</div>
<div class="line">    <span class="keywordtype">int</span> nb_gauss_pts = data.getN().size1();</div>
<div class="line">    <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element_1_1_op_skeleton_1_1_op_vol_side.html#a564e8c6dd394f42cf1de140fdee92081">valMap</a>[getFaceSense()].resize(nb_gauss_pts);</div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> gg = 0;gg&lt;nb_gauss_pts;gg++) {</div>
<div class="line">      <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element_1_1_op_skeleton_1_1_op_vol_side.html#a564e8c6dd394f42cf1de140fdee92081">valMap</a>[getFaceSense()][gg] = inner_prod(trans(data.getN(gg)),data.getFieldData());</div>
<div class="line">    }</div>
<div class="line">    <a class="code hl_define" href="definitions_8h.html#acb0a46d159695a01bf667313b7788b45">MoFEMFunctionReturn</a>(0);</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="ttc" id="astruct_mix_transport_1_1_mix_transport_element_1_1_op_skeleton_1_1_op_vol_side_html"><div class="ttname"><a href="struct_mix_transport_1_1_mix_transport_element_1_1_op_skeleton_1_1_op_vol_side.html">MixTransport::MixTransportElement::OpSkeleton::OpVolSide</a></div><div class="ttdoc">calculate values on adjacent tetrahedra to face</div><div class="ttdef"><b>Definition:</b> <a href="_mix_transport_element_8hpp_source.html#l01483">MixTransportElement.hpp:1484</a></div></div>
<div class="ttc" id="astruct_mix_transport_1_1_mix_transport_element_1_1_op_skeleton_1_1_op_vol_side_html_a564e8c6dd394f42cf1de140fdee92081"><div class="ttname"><a href="struct_mix_transport_1_1_mix_transport_element_1_1_op_skeleton_1_1_op_vol_side.html#a564e8c6dd394f42cf1de140fdee92081">MixTransport::MixTransportElement::OpSkeleton::OpVolSide::valMap</a></div><div class="ttdeci">map&lt; int, VectorDouble &gt; &amp; valMap</div><div class="ttdef"><b>Definition:</b> <a href="_mix_transport_element_8hpp_source.html#l01485">MixTransportElement.hpp:1485</a></div></div>
<div class="ttc" id="astruct_mix_transport_1_1_mix_transport_element_1_1_op_skeleton_1_1_op_vol_side_html_a998e6f8d52bd3cc3686a6f1b335a24aa"><div class="ttname"><a href="struct_mix_transport_1_1_mix_transport_element_1_1_op_skeleton_1_1_op_vol_side.html#a998e6f8d52bd3cc3686a6f1b335a24aa">MixTransport::MixTransportElement::OpSkeleton::OpVolSide::doWork</a></div><div class="ttdeci">MoFEMErrorCode doWork(int side, EntityType type, EntitiesFieldData::EntData &amp;data)</div><div class="ttdef"><b>Definition:</b> <a href="_mix_transport_element_8hpp_source.html#l01490">MixTransportElement.hpp:1490</a></div></div>
<div class="ttc" id="astruct_mo_f_e_m_1_1_volume_element_forces_and_sources_core_on_side_1_1_user_data_operator_html"><div class="ttname"><a href="struct_mo_f_e_m_1_1_volume_element_forces_and_sources_core_on_side_1_1_user_data_operator.html">MoFEM::VolumeElementForcesAndSourcesCoreOnSide::UserDataOperator</a></div><div class="ttdoc">default operator for TET element</div><div class="ttdef"><b>Definition:</b> <a href="_volume_element_forces_and_sources_core_on_side_8hpp_source.html#l00097">VolumeElementForcesAndSourcesCoreOnSide.hpp:98</a></div></div>
</div><!-- fragment --><p> Implementation of <b>doWork</b> function is straightforward. It loops over integration points and computes function values using base functions and DOF values. Results are stored in the map <b>valMap</b>. Note that internal face has two adjacent volume elements, whereas face on boundary has only one. Each face has a unique orientation (sense) in respect to face, information about that sense is accessed by <b>getFaceSense()</b>.</p>
<p >Once we evaluated approximation function values at each face, we can calculate error \(\eta_{e,R}\), using face operator </p><div class="fragment"><div class="line">MoFEMErrorCode <a class="code hl_function" href="struct_mix_transport_1_1_mix_transport_element_1_1_op_skeleton.html#aebfa55a1d63e69d37ed9a8c4eb93d4ac">MixTransport::MixTransportElement::OpSkeleton::doWork</a>(<span class="keywordtype">int</span> side,<a class="code hl_class" href="class_entity_type.html">EntityType</a> type,EntitiesFieldData::EntData &amp;data) {</div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#a6c0b52978f1abc88bf8a1ba70b7308e3">MoFEMFunctionBegin</a>;</div>
<div class="line">  <span class="keywordflow">if</span>(type == MBTRI) {</div>
<div class="line">    <a class="code hl_class" href="class_entity_handle.html">EntityHandle</a> fe_ent = <a class="code hl_function" href="struct_mo_f_e_m_1_1_forces_and_sources_core_1_1_user_data_operator.html#ab1001cc939d6a6b797c22099281d9615">getNumeredEntFiniteElementPtr</a>()-&gt;getEnt();</div>
<div class="line">    <span class="keywordtype">double</span> def_val = 0;</div>
<div class="line">    Tag th_error_jump;</div>
<div class="line">    <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element_1_1_op_skeleton.html#aef3f15c3707fadaa7191ae63adc2333c">cTx</a>.<a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element.html#a68f344cfbf6b208f5930951ca427f8f7">mField</a>.<a class="code hl_function" href="struct_mo_f_e_m_1_1_core_interface.html#a174e70b67f4f235d096d3c45d865645b">get_moab</a>().tag_get_handle(</div>
<div class="line">      <span class="stringliteral">&quot;ERROR_JUMP&quot;</span>,1,MB_TYPE_DOUBLE,th_error_jump,MB_TAG_CREAT|MB_TAG_SPARSE,&amp;def_val</div>
<div class="line">    ); </div>
<div class="line">    <span class="keywordtype">double</span>* error_jump_ptr;</div>
<div class="line">    <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element_1_1_op_skeleton.html#aef3f15c3707fadaa7191ae63adc2333c">cTx</a>.<a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element.html#a68f344cfbf6b208f5930951ca427f8f7">mField</a>.<a class="code hl_function" href="struct_mo_f_e_m_1_1_core_interface.html#a174e70b67f4f235d096d3c45d865645b">get_moab</a>().tag_get_by_ptr(</div>
<div class="line">      th_error_jump,&amp;fe_ent,1,(<span class="keyword">const</span> <span class="keywordtype">void</span>**)&amp;error_jump_ptr</div>
<div class="line">    ); </div>
<div class="line">    *error_jump_ptr = 0;</div>
<div class="line">    <span class="comment">// check if this is essential boundary condition</span></div>
<div class="line">    <a class="code hl_class" href="class_entity_handle.html">EntityHandle</a> essential_bc_meshset = <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element_1_1_op_skeleton.html#aef3f15c3707fadaa7191ae63adc2333c">cTx</a>.<a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element.html#a68f344cfbf6b208f5930951ca427f8f7">mField</a>.<a class="code hl_function" href="group__mofem__fe.html#ga70d1de87ded796f436cf5df5273f59de">get_finite_element_meshset</a>(<span class="stringliteral">&quot;MIX_BCFLUX&quot;</span>);</div>
<div class="line">    <span class="keywordflow">if</span>(<a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element_1_1_op_skeleton.html#aef3f15c3707fadaa7191ae63adc2333c">cTx</a>.<a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element.html#a68f344cfbf6b208f5930951ca427f8f7">mField</a>.<a class="code hl_function" href="struct_mo_f_e_m_1_1_core_interface.html#a174e70b67f4f235d096d3c45d865645b">get_moab</a>().contains_entities(essential_bc_meshset,&amp;fe_ent,1)) {</div>
<div class="line">      <span class="comment">// essential bc, np jump then, exit and go to next face</span></div>
<div class="line">      <a class="code hl_define" href="definitions_8h.html#a59cd650c2f6d3e0dc1ad1c29821e8692">MoFEMFunctionReturnHot</a>(0);</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">// calculate values form adjacent tets</span></div>
<div class="line">    <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element_1_1_op_skeleton.html#a6f66ea5cc0a3384d5700ede04aa8467a">valMap</a>.clear();</div>
<div class="line">    <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> <a class="code hl_function" href="struct_mo_f_e_m_1_1_face_element_forces_and_sources_core_1_1_user_data_operator.html#a4d534a91408c5ec5627c2f3a59de596e">loopSideVolumes</a>(<span class="stringliteral">&quot;MIX&quot;</span>,<a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element_1_1_op_skeleton.html#a81bc2f88a5d61fa74e7ef6ab24fe2c22">volSideFe</a>); </div>
<div class="line">    <span class="keywordtype">int</span> nb_gauss_pts = data.getVectorN().size1();</div>
<div class="line">    <span class="comment">// it is only one face, so it has to be bc natural boundary condition</span></div>
<div class="line">    <span class="keywordflow">if</span>(<a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element_1_1_op_skeleton.html#a6f66ea5cc0a3384d5700ede04aa8467a">valMap</a>.size()==1) {</div>
<div class="line">      <span class="keywordflow">if</span>(<a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element_1_1_op_skeleton.html#a6f66ea5cc0a3384d5700ede04aa8467a">valMap</a>.begin()-&gt;second.size()!=nb_gauss_pts) {</div>
<div class="line">        SETERRQ(PETSC_COMM_WORLD,<a class="code hl_enumvalue" href="definitions_8h.html#a980bf270a5c3f2f984262f7e74786a2eac345e9ce83307109886a56dcaf5ab724">MOFEM_DATA_INCONSISTENCY</a>,<span class="stringliteral">&quot;wrong number of integration points&quot;</span>);</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">for</span>(<span class="keywordtype">int</span> gg = 0;gg!=nb_gauss_pts;gg++) {</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> x = <a class="code hl_function" href="struct_mo_f_e_m_1_1_forces_and_sources_core_1_1_user_data_operator.html#a8c24ba4a5a415ae0b9b1a3da21cfe066">getCoordsAtGaussPts</a>()(gg,0);</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> y = <a class="code hl_function" href="struct_mo_f_e_m_1_1_forces_and_sources_core_1_1_user_data_operator.html#a8c24ba4a5a415ae0b9b1a3da21cfe066">getCoordsAtGaussPts</a>()(gg,1);</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> z = <a class="code hl_function" href="struct_mo_f_e_m_1_1_forces_and_sources_core_1_1_user_data_operator.html#a8c24ba4a5a415ae0b9b1a3da21cfe066">getCoordsAtGaussPts</a>()(gg,2);</div>
<div class="line">        <span class="keywordtype">double</span> value;</div>
<div class="line">        <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element_1_1_op_skeleton.html#aef3f15c3707fadaa7191ae63adc2333c">cTx</a>.<a class="code hl_function" href="struct_mix_transport_1_1_mix_transport_element.html#aa2252de32c5c866aedff5f489b4ad60e">getBcOnValues</a>(fe_ent,x,y,z,value); </div>
<div class="line">        <span class="keywordtype">double</span> w = <a class="code hl_function" href="struct_mo_f_e_m_1_1_forces_and_sources_core_1_1_user_data_operator.html#ae90a09d3c36b0a4ed9ab1d99fcce0c1d">getGaussPts</a>()(2,gg);</div>
<div class="line">        w *= <a class="code hl_function" href="struct_mo_f_e_m_1_1_face_element_forces_and_sources_core_1_1_user_data_operator.html#a4f30530b3cf454259c47b48c117764a3">getArea</a>();</div>
<div class="line">        *error_jump_ptr += w*pow(value-<a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element_1_1_op_skeleton.html#a6f66ea5cc0a3384d5700ede04aa8467a">valMap</a>.begin()-&gt;second[gg],2);</div>
<div class="line">      }</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(<a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element_1_1_op_skeleton.html#a6f66ea5cc0a3384d5700ede04aa8467a">valMap</a>.size()==2) {</div>
<div class="line">      <span class="keywordflow">for</span>(<span class="keywordtype">int</span> gg = 0;gg!=nb_gauss_pts;gg++) {</div>
<div class="line">        <span class="keywordtype">double</span> <a class="code hl_function" href="namespace_op_contact_tools.html#a371e4e9b405b6e35551e60a986c18b58">w</a> = <a class="code hl_function" href="struct_mo_f_e_m_1_1_forces_and_sources_core_1_1_user_data_operator.html#ae90a09d3c36b0a4ed9ab1d99fcce0c1d">getGaussPts</a>()(2,gg);</div>
<div class="line">        <a class="code hl_function" href="namespace_op_contact_tools.html#a371e4e9b405b6e35551e60a986c18b58">w</a> *= <a class="code hl_function" href="struct_mo_f_e_m_1_1_face_element_forces_and_sources_core_1_1_user_data_operator.html#a4f30530b3cf454259c47b48c117764a3">getArea</a>();</div>
<div class="line">        <span class="keywordtype">double</span> <a class="code hl_variable" href="prism__elements__from__surface_8cpp.html#a9eb248cd425bb908c67fa311945029cc">delta</a> = <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element_1_1_op_skeleton.html#a6f66ea5cc0a3384d5700ede04aa8467a">valMap</a>.at(1)[gg]-<a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element_1_1_op_skeleton.html#a6f66ea5cc0a3384d5700ede04aa8467a">valMap</a>.at(-1)[gg];</div>
<div class="line">        *error_jump_ptr += <a class="code hl_function" href="namespace_op_contact_tools.html#a371e4e9b405b6e35551e60a986c18b58">w</a>*pow(<a class="code hl_variable" href="prism__elements__from__surface_8cpp.html#a9eb248cd425bb908c67fa311945029cc">delta</a>,2);</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#acb0a46d159695a01bf667313b7788b45">MoFEMFunctionReturn</a>(0);</div>
<div class="line">}</div>
<div class="ttc" id="adefinitions_8h_html_a980bf270a5c3f2f984262f7e74786a2eac345e9ce83307109886a56dcaf5ab724"><div class="ttname"><a href="definitions_8h.html#a980bf270a5c3f2f984262f7e74786a2eac345e9ce83307109886a56dcaf5ab724">MOFEM_DATA_INCONSISTENCY</a></div><div class="ttdeci">@ MOFEM_DATA_INCONSISTENCY</div><div class="ttdef"><b>Definition:</b> <a href="definitions_8h_source.html#l00031">definitions.h:31</a></div></div>
<div class="ttc" id="agroup__mofem__fe_html_ga70d1de87ded796f436cf5df5273f59de"><div class="ttname"><a href="group__mofem__fe.html#ga70d1de87ded796f436cf5df5273f59de">MoFEM::CoreInterface::get_finite_element_meshset</a></div><div class="ttdeci">virtual EntityHandle get_finite_element_meshset(const std::string name) const =0</div></div>
<div class="ttc" id="anamespace_op_contact_tools_html_a371e4e9b405b6e35551e60a986c18b58"><div class="ttname"><a href="namespace_op_contact_tools.html#a371e4e9b405b6e35551e60a986c18b58">OpContactTools::w</a></div><div class="ttdeci">double w(const double g, const double t)</div><div class="ttdef"><b>Definition:</b> <a href="_contact_operators_8hpp_source.html#l00109">ContactOperators.hpp:109</a></div></div>
<div class="ttc" id="aprism__elements__from__surface_8cpp_html_a9eb248cd425bb908c67fa311945029cc"><div class="ttname"><a href="prism__elements__from__surface_8cpp.html#a9eb248cd425bb908c67fa311945029cc">delta</a></div><div class="ttdeci">static constexpr double delta</div><div class="ttdef"><b>Definition:</b> <a href="prism__elements__from__surface_8cpp_source.html#l00018">prism_elements_from_surface.cpp:18</a></div></div>
<div class="ttc" id="astruct_mo_f_e_m_1_1_face_element_forces_and_sources_core_1_1_user_data_operator_html_a4d534a91408c5ec5627c2f3a59de596e"><div class="ttname"><a href="struct_mo_f_e_m_1_1_face_element_forces_and_sources_core_1_1_user_data_operator.html#a4d534a91408c5ec5627c2f3a59de596e">MoFEM::FaceElementForcesAndSourcesCore::UserDataOperator::loopSideVolumes</a></div><div class="ttdeci">MoFEMErrorCode loopSideVolumes(const string fe_name, VolumeElementForcesAndSourcesCoreOnSide &amp;fe_method)</div><div class="ttdef"><b>Definition:</b> <a href="_face_element_forces_and_sources_core_8cpp_source.html#l00442">FaceElementForcesAndSourcesCore.cpp:442</a></div></div>
<div class="ttc" id="astruct_mo_f_e_m_1_1_face_element_forces_and_sources_core_1_1_user_data_operator_html_a4f30530b3cf454259c47b48c117764a3"><div class="ttname"><a href="struct_mo_f_e_m_1_1_face_element_forces_and_sources_core_1_1_user_data_operator.html#a4f30530b3cf454259c47b48c117764a3">MoFEM::FaceElementForcesAndSourcesCore::UserDataOperator::getArea</a></div><div class="ttdeci">double getArea()</div><div class="ttdoc">get area of face</div><div class="ttdef"><b>Definition:</b> <a href="_face_element_forces_and_sources_core_8hpp_source.html#l00240">FaceElementForcesAndSourcesCore.hpp:240</a></div></div>
<div class="ttc" id="astruct_mo_f_e_m_1_1_forces_and_sources_core_1_1_user_data_operator_html_ab1001cc939d6a6b797c22099281d9615"><div class="ttname"><a href="struct_mo_f_e_m_1_1_forces_and_sources_core_1_1_user_data_operator.html#ab1001cc939d6a6b797c22099281d9615">MoFEM::ForcesAndSourcesCore::UserDataOperator::getNumeredEntFiniteElementPtr</a></div><div class="ttdeci">boost::shared_ptr&lt; const NumeredEntFiniteElement &gt; getNumeredEntFiniteElementPtr() const</div><div class="ttdoc">Return raw pointer to NumeredEntFiniteElement.</div><div class="ttdef"><b>Definition:</b> <a href="_forces_and_sources_core_8hpp_source.html#l00996">ForcesAndSourcesCore.hpp:996</a></div></div>
</div><!-- fragment --><p> Note that we have to consider three scenarios, first, on the face is essential boundary condition. In that case, jump on face values is zero. If that is not a case, we run loop over adjacent volume elements </p><div class="fragment"><div class="line"><a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> loopSideVolumes(<span class="stringliteral">&quot;MIX&quot;</span>,volSideFe); </div>
</div><!-- fragment --><p> At this point nested volume element instance is called and then operator on this element executed. Results of this operation are stored in <b>valMap</b>.</p>
<p >If it is not case one, and if a face has only one volume in the side, thus on that face natural boundary is applied, then jump is a difference between boundary value and values evaluated by adjacent volume operator. If a face is in volume, i.e. third case, we calculate the difference between values from adjacent volumes. Results are stored on face tag values, here we are using MOAB to do that for us, using </p><div class="fragment"><div class="line"><a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> cTx.<a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element.html#a68f344cfbf6b208f5930951ca427f8f7">mField</a>.<a class="code hl_function" href="struct_mo_f_e_m_1_1_core_interface.html#a174e70b67f4f235d096d3c45d865645b">get_moab</a>().tag_get_by_ptr(</div>
<div class="line">   th_error_jump,&amp;fe_ent,1,(<span class="keyword">const</span> <span class="keywordtype">void</span>**)&amp;error_jump_ptr</div>
<div class="line">); </div>
</div><!-- fragment --><p> which returns pointer to value stored (tagged) on face. Look here <a href="http://ftp.mcs.anl.gov/pub/fathom/moab-docs/contents.html#twofour">http://ftp.mcs.anl.gov/pub/fathom/moab-docs/contents.html#twofour</a> to learn about tags in MOAB and how to use them.</p>
<h2><a class="anchor" id="mixtransport_calculate_error"></a>
Calculate residual error estimator</h2>
<p >Once we have implemented how to calculate jumps between adjacent volume elements, we can focus on computing residual error estimator. We do that in standard way using operator which acts on volume element </p><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code hl_struct" href="struct_mix_transport_1_1_mix_transport_element_1_1_op_error.html">MixTransport::MixTransportElement::OpError</a>: <span class="keyword">public</span> <a class="code hl_struct" href="struct_mo_f_e_m_1_1_volume_element_forces_and_sources_core_1_1_user_data_operator.html">MoFEM::VolumeElementForcesAndSourcesCore::UserDataOperator</a> {</div>
<div class="line">  <a class="code hl_struct" href="struct_mix_transport_1_1_mix_transport_element.html">MixTransport::MixTransportElement</a> &amp;<a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element_1_1_op_error.html#ac1450d64f7652109f9ea7726cfc248a1">cTx</a>;</div>
<div class="line">  <a class="code hl_struct" href="struct_op_error.html">OpError</a>(</div>
<div class="line">    <a class="code hl_struct" href="struct_mix_transport_1_1_mix_transport_element.html">MixTransport::MixTransportElement</a> &amp;ctx,</div>
<div class="line">    <span class="keyword">const</span> std::string <a class="code hl_variable" href="poisson__2d__homogeneous_8cpp.html#a3917f3987bad1f4e24b85c9d0ab84a5e">field_name</a></div>
<div class="line">  ):</div>
<div class="line">  <a class="code hl_namespace" href="namespace_mo_f_e_m.html">MoFEM</a>::VolumeElementForcesAndSourcesCore::<a class="code hl_typedef" href="_hooke_element_8hpp.html#aee27a2ebc8f3d34a5c1ce71b2607d1a3">UserDataOperator</a>(<a class="code hl_variable" href="poisson__2d__homogeneous_8cpp.html#a3917f3987bad1f4e24b85c9d0ab84a5e">field_name</a>,<a class="code hl_typedef" href="_hooke_element_8hpp.html#aee27a2ebc8f3d34a5c1ce71b2607d1a3">UserDataOperator</a>::<a class="code hl_enumvalue" href="struct_mo_f_e_m_1_1_forces_and_sources_core_1_1_user_data_operator.html#ac99de5ec6fa9bad3ccc5c5d60bc48e40a2d8d202342fada158e521ef00be491e1">OPROW</a>),</div>
<div class="line">  <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element_1_1_op_error.html#ac1450d64f7652109f9ea7726cfc248a1">cTx</a>(ctx) {}</div>
<div class="line">  VectorDouble <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element_1_1_op_error.html#a3a0a1756377fe7a9178d9fb5c38ad8fa">deltaFlux</a>;</div>
<div class="line">  MatrixDouble <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element_1_1_op_error.html#a334b8bb560ffab6158791ade4be06ee7">invK</a>;</div>
<div class="line">  MoFEMErrorCode <a class="code hl_function" href="struct_mix_transport_1_1_mix_transport_element_1_1_op_error.html#ac236c302ca2e7f3bfce97673f3c07196">doWork</a>(</div>
<div class="line">    <span class="keywordtype">int</span> side,<a class="code hl_class" href="class_entity_type.html">EntityType</a> type,EntitiesFieldData::EntData &amp;data</div>
<div class="line">  ) {</div>
<div class="line">    <a class="code hl_define" href="definitions_8h.html#a6c0b52978f1abc88bf8a1ba70b7308e3">MoFEMFunctionBegin</a>;</div>
<div class="line">    <span class="keywordflow">if</span>(type != MBTET) <a class="code hl_define" href="definitions_8h.html#a59cd650c2f6d3e0dc1ad1c29821e8692">MoFEMFunctionReturnHot</a>(0);</div>
<div class="line">    <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element_1_1_op_error.html#a334b8bb560ffab6158791ade4be06ee7">invK</a>.resize(3,3,<span class="keyword">false</span>);</div>
<div class="line">    <span class="keywordtype">int</span> nb_gauss_pts = data.getN().size1();</div>
<div class="line">    <a class="code hl_class" href="class_entity_handle.html">EntityHandle</a> fe_ent = <a class="code hl_function" href="struct_mo_f_e_m_1_1_forces_and_sources_core_1_1_user_data_operator.html#ab1001cc939d6a6b797c22099281d9615">getNumeredEntFiniteElementPtr</a>()-&gt;getEnt();</div>
<div class="line">    <span class="keywordtype">double</span> def_val = 0;</div>
<div class="line">    Tag th_error_flux,th_error_div;</div>
<div class="line">    <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element_1_1_op_error.html#ac1450d64f7652109f9ea7726cfc248a1">cTx</a>.<a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element.html#a68f344cfbf6b208f5930951ca427f8f7">mField</a>.<a class="code hl_function" href="struct_mo_f_e_m_1_1_core_interface.html#a174e70b67f4f235d096d3c45d865645b">get_moab</a>().tag_get_handle(</div>
<div class="line">      <span class="stringliteral">&quot;ERROR_FLUX&quot;</span>,1,MB_TYPE_DOUBLE,th_error_flux,MB_TAG_CREAT|MB_TAG_SPARSE,&amp;def_val</div>
<div class="line">    ); </div>
<div class="line">    <span class="keywordtype">double</span>* error_flux_ptr;</div>
<div class="line">    <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element_1_1_op_error.html#ac1450d64f7652109f9ea7726cfc248a1">cTx</a>.<a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element.html#a68f344cfbf6b208f5930951ca427f8f7">mField</a>.<a class="code hl_function" href="struct_mo_f_e_m_1_1_core_interface.html#a174e70b67f4f235d096d3c45d865645b">get_moab</a>().tag_get_by_ptr(</div>
<div class="line">      th_error_flux,&amp;fe_ent,1,(<span class="keyword">const</span> <span class="keywordtype">void</span>**)&amp;error_flux_ptr</div>
<div class="line">    ); </div>
<div class="line">    <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element_1_1_op_error.html#ac1450d64f7652109f9ea7726cfc248a1">cTx</a>.<a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element.html#a68f344cfbf6b208f5930951ca427f8f7">mField</a>.<a class="code hl_function" href="struct_mo_f_e_m_1_1_core_interface.html#a174e70b67f4f235d096d3c45d865645b">get_moab</a>().tag_get_handle(</div>
<div class="line">      <span class="stringliteral">&quot;ERROR_DIV&quot;</span>,1,MB_TYPE_DOUBLE,th_error_div,MB_TAG_CREAT|MB_TAG_SPARSE,&amp;def_val</div>
<div class="line">    ); </div>
<div class="line">    <span class="keywordtype">double</span>* error_div_ptr;</div>
<div class="line">    <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element_1_1_op_error.html#ac1450d64f7652109f9ea7726cfc248a1">cTx</a>.<a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element.html#a68f344cfbf6b208f5930951ca427f8f7">mField</a>.<a class="code hl_function" href="struct_mo_f_e_m_1_1_core_interface.html#a174e70b67f4f235d096d3c45d865645b">get_moab</a>().tag_get_by_ptr(</div>
<div class="line">      th_error_div,&amp;fe_ent,1,(<span class="keyword">const</span> <span class="keywordtype">void</span>**)&amp;error_div_ptr</div>
<div class="line">    ); </div>
<div class="line">    Tag th_error_jump;</div>
<div class="line">    <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element_1_1_op_error.html#ac1450d64f7652109f9ea7726cfc248a1">cTx</a>.<a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element.html#a68f344cfbf6b208f5930951ca427f8f7">mField</a>.<a class="code hl_function" href="struct_mo_f_e_m_1_1_core_interface.html#a174e70b67f4f235d096d3c45d865645b">get_moab</a>().tag_get_handle(</div>
<div class="line">      <span class="stringliteral">&quot;ERROR_JUMP&quot;</span>,1,MB_TYPE_DOUBLE,th_error_jump,MB_TAG_CREAT|MB_TAG_SPARSE,&amp;def_val</div>
<div class="line">    ); </div>
<div class="line">    <span class="keywordtype">double</span>* error_jump_ptr;</div>
<div class="line">    <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element_1_1_op_error.html#ac1450d64f7652109f9ea7726cfc248a1">cTx</a>.<a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element.html#a68f344cfbf6b208f5930951ca427f8f7">mField</a>.<a class="code hl_function" href="struct_mo_f_e_m_1_1_core_interface.html#a174e70b67f4f235d096d3c45d865645b">get_moab</a>().tag_get_by_ptr(</div>
<div class="line">      th_error_jump,&amp;fe_ent,1,(<span class="keyword">const</span> <span class="keywordtype">void</span>**)&amp;error_jump_ptr</div>
<div class="line">    ); </div>
<div class="line">    *error_jump_ptr = 0;<span class="comment"></span></div>
<div class="line"><span class="comment">    /// characteristic size of the element</span></div>
<div class="line"><span class="comment"></span>    <span class="keyword">const</span> <span class="keywordtype">double</span> <a class="code hl_variable" href="photon__diffusion_8cpp.html#a8ee9be1b5aa75abae556de3088cba6d9">h</a> = pow(<a class="code hl_function" href="struct_mo_f_e_m_1_1_volume_element_forces_and_sources_core_1_1_user_data_operator.html#a27ada41314b2540fb0a722aad7257051">getVolume</a>()*12/sqrt(2),(<span class="keywordtype">double</span>)1/3);</div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ff = 0;ff!=4;ff++) {</div>
<div class="line">      <a class="code hl_class" href="class_entity_handle.html">EntityHandle</a> face;</div>
<div class="line">      <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element_1_1_op_error.html#ac1450d64f7652109f9ea7726cfc248a1">cTx</a>.<a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element.html#a68f344cfbf6b208f5930951ca427f8f7">mField</a>.<a class="code hl_function" href="struct_mo_f_e_m_1_1_core_interface.html#a174e70b67f4f235d096d3c45d865645b">get_moab</a>().side_element(fe_ent,2,ff,face); </div>
<div class="line">      <span class="keywordtype">double</span>* error_face_jump_ptr;</div>
<div class="line">      <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element_1_1_op_error.html#ac1450d64f7652109f9ea7726cfc248a1">cTx</a>.<a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element.html#a68f344cfbf6b208f5930951ca427f8f7">mField</a>.<a class="code hl_function" href="struct_mo_f_e_m_1_1_core_interface.html#a174e70b67f4f235d096d3c45d865645b">get_moab</a>().tag_get_by_ptr(</div>
<div class="line">        th_error_jump,&amp;face,1,(<span class="keyword">const</span> <span class="keywordtype">void</span>**)&amp;error_face_jump_ptr</div>
<div class="line">      ); </div>
<div class="line">      *error_face_jump_ptr = (1/sqrt(<a class="code hl_variable" href="photon__diffusion_8cpp.html#a8ee9be1b5aa75abae556de3088cba6d9">h</a>))*sqrt(*error_face_jump_ptr);</div>
<div class="line">      *error_face_jump_ptr = pow(*error_face_jump_ptr,2);</div>
<div class="line">      *error_jump_ptr += *error_face_jump_ptr;</div>
<div class="line">    }</div>
<div class="line">    *error_flux_ptr = 0;</div>
<div class="line">    *error_div_ptr = 0;</div>
<div class="line">    <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element_1_1_op_error.html#a3a0a1756377fe7a9178d9fb5c38ad8fa">deltaFlux</a>.resize(3,<span class="keyword">false</span>);</div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> gg = 0;gg&lt;nb_gauss_pts;gg++) {</div>
<div class="line">      <span class="keywordtype">double</span> w = <a class="code hl_function" href="struct_mo_f_e_m_1_1_forces_and_sources_core_1_1_user_data_operator.html#ae90a09d3c36b0a4ed9ab1d99fcce0c1d">getGaussPts</a>()(3,gg)*<a class="code hl_function" href="struct_mo_f_e_m_1_1_volume_element_forces_and_sources_core_1_1_user_data_operator.html#a27ada41314b2540fb0a722aad7257051">getVolume</a>();</div>
<div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> x = <a class="code hl_function" href="struct_mo_f_e_m_1_1_forces_and_sources_core_1_1_user_data_operator.html#a8c24ba4a5a415ae0b9b1a3da21cfe066">getCoordsAtGaussPts</a>()(gg,0);</div>
<div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> y = <a class="code hl_function" href="struct_mo_f_e_m_1_1_forces_and_sources_core_1_1_user_data_operator.html#a8c24ba4a5a415ae0b9b1a3da21cfe066">getCoordsAtGaussPts</a>()(gg,1);</div>
<div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> z = <a class="code hl_function" href="struct_mo_f_e_m_1_1_forces_and_sources_core_1_1_user_data_operator.html#a8c24ba4a5a415ae0b9b1a3da21cfe066">getCoordsAtGaussPts</a>()(gg,2);</div>
<div class="line">      <span class="keywordtype">double</span> flux;</div>
<div class="line">      <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element_1_1_op_error.html#ac1450d64f7652109f9ea7726cfc248a1">cTx</a>.<a class="code hl_function" href="struct_mix_transport_1_1_mix_transport_element.html#ae4baeb3ccff530cacba43fd18969364d">getSource</a>(fe_ent,x,y,z,flux); </div>
<div class="line">      *error_div_ptr += w*pow(<a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element_1_1_op_error.html#ac1450d64f7652109f9ea7726cfc248a1">cTx</a>.<a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element.html#ade9b21eb65ae4419dda4f8ab51b4fb55">divergenceAtGaussPts</a>[gg]-flux,2);</div>
<div class="line">      <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element_1_1_op_error.html#ac1450d64f7652109f9ea7726cfc248a1">cTx</a>.<a class="code hl_function" href="struct_mix_transport_1_1_mix_transport_element.html#acd897d63c94070449821109a721b2726">getResistivity</a>(fe_ent,x,y,z,<a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element_1_1_op_error.html#a334b8bb560ffab6158791ade4be06ee7">invK</a>); </div>
<div class="line">      noalias(<a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element_1_1_op_error.html#a3a0a1756377fe7a9178d9fb5c38ad8fa">deltaFlux</a>) = prod(<a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element_1_1_op_error.html#a334b8bb560ffab6158791ade4be06ee7">invK</a>,<a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element_1_1_op_error.html#ac1450d64f7652109f9ea7726cfc248a1">cTx</a>.<a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element.html#aed25d2483c3ac9398c1914f4cd24c5ce">fluxesAtGaussPts</a>[gg])+<a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element_1_1_op_error.html#ac1450d64f7652109f9ea7726cfc248a1">cTx</a>.<a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element.html#a75e46b9de15a71bf5138c801ed92a527">valuesGradientAtGaussPts</a>[gg];</div>
<div class="line">      *error_flux_ptr += w*inner_prod(<a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element_1_1_op_error.html#a3a0a1756377fe7a9178d9fb5c38ad8fa">deltaFlux</a>,<a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element_1_1_op_error.html#a3a0a1756377fe7a9178d9fb5c38ad8fa">deltaFlux</a>);</div>
<div class="line">    }</div>
<div class="line">    *error_div_ptr = <a class="code hl_variable" href="photon__diffusion_8cpp.html#a8ee9be1b5aa75abae556de3088cba6d9">h</a>*sqrt(*error_div_ptr);</div>
<div class="line">    *error_div_ptr = pow(*error_div_ptr,2);</div>
<div class="line">    <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element_1_1_op_error.html#ac1450d64f7652109f9ea7726cfc248a1">cTx</a>.<a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element.html#ae625b646f20954d6815221981ada37c9">sumErrorFlux</a> += *error_flux_ptr;</div>
<div class="line">    <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element_1_1_op_error.html#ac1450d64f7652109f9ea7726cfc248a1">cTx</a>.<a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element.html#ab412c80e7ec70111f97dc4ec4d7716ac">sumErrorDiv</a> += *error_div_ptr;</div>
<div class="line">    <span class="comment">// FIXME: Summation should be while skeleton is calculated</span></div>
<div class="line">    <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element_1_1_op_error.html#ac1450d64f7652109f9ea7726cfc248a1">cTx</a>.<a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element.html#a61e2bd85b3eb99e24eee0343951f666c">sumErrorJump</a> += *error_jump_ptr; <span class="comment">// FIXME: this need to be fixed</span></div>
<div class="line">    <a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element_1_1_op_error.html#ac1450d64f7652109f9ea7726cfc248a1">cTx</a>.<a class="code hl_variable" href="struct_mix_transport_1_1_mix_transport_element.html#a90d6e69d5d612ef52f151b73ff770143">errorMap</a>[sqrt(*error_flux_ptr+*error_div_ptr+*error_jump_ptr)] = fe_ent;</div>
<div class="line">    <a class="code hl_define" href="definitions_8h.html#acb0a46d159695a01bf667313b7788b45">MoFEMFunctionReturn</a>(0);</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="ttc" id="aphoton__diffusion_8cpp_html_a8ee9be1b5aa75abae556de3088cba6d9"><div class="ttname"><a href="photon__diffusion_8cpp.html#a8ee9be1b5aa75abae556de3088cba6d9">h</a></div><div class="ttdeci">double h</div><div class="ttdef"><b>Definition:</b> <a href="photon__diffusion_8cpp_source.html#l00060">photon_diffusion.cpp:60</a></div></div>
<div class="ttc" id="apoisson__2d__homogeneous_8cpp_html_a3917f3987bad1f4e24b85c9d0ab84a5e"><div class="ttname"><a href="poisson__2d__homogeneous_8cpp.html#a3917f3987bad1f4e24b85c9d0ab84a5e">field_name</a></div><div class="ttdeci">constexpr auto field_name</div><div class="ttdef"><b>Definition:</b> <a href="poisson__2d__homogeneous_8cpp_source.html#l00013">poisson_2d_homogeneous.cpp:13</a></div></div>
<div class="ttc" id="astruct_mix_transport_1_1_mix_transport_element_1_1_op_error_html_a334b8bb560ffab6158791ade4be06ee7"><div class="ttname"><a href="struct_mix_transport_1_1_mix_transport_element_1_1_op_error.html#a334b8bb560ffab6158791ade4be06ee7">MixTransport::MixTransportElement::OpError::invK</a></div><div class="ttdeci">MatrixDouble3by3 invK</div><div class="ttdef"><b>Definition:</b> <a href="_mix_transport_element_8hpp_source.html#l01379">MixTransportElement.hpp:1379</a></div></div>
<div class="ttc" id="astruct_mix_transport_1_1_mix_transport_element_1_1_op_error_html_a3a0a1756377fe7a9178d9fb5c38ad8fa"><div class="ttname"><a href="struct_mix_transport_1_1_mix_transport_element_1_1_op_error.html#a3a0a1756377fe7a9178d9fb5c38ad8fa">MixTransport::MixTransportElement::OpError::deltaFlux</a></div><div class="ttdeci">VectorDouble deltaFlux</div><div class="ttdef"><b>Definition:</b> <a href="_mix_transport_element_8hpp_source.html#l01378">MixTransportElement.hpp:1378</a></div></div>
<div class="ttc" id="astruct_mix_transport_1_1_mix_transport_element_1_1_op_error_html_ac1450d64f7652109f9ea7726cfc248a1"><div class="ttname"><a href="struct_mix_transport_1_1_mix_transport_element_1_1_op_error.html#ac1450d64f7652109f9ea7726cfc248a1">MixTransport::MixTransportElement::OpError::cTx</a></div><div class="ttdeci">MixTransportElement &amp; cTx</div><div class="ttdef"><b>Definition:</b> <a href="_mix_transport_element_8hpp_source.html#l01370">MixTransportElement.hpp:1370</a></div></div>
<div class="ttc" id="astruct_mix_transport_1_1_mix_transport_element_1_1_op_error_html_ac236c302ca2e7f3bfce97673f3c07196"><div class="ttname"><a href="struct_mix_transport_1_1_mix_transport_element_1_1_op_error.html#ac236c302ca2e7f3bfce97673f3c07196">MixTransport::MixTransportElement::OpError::doWork</a></div><div class="ttdeci">MoFEMErrorCode doWork(int side, EntityType type, EntitiesFieldData::EntData &amp;data)</div><div class="ttdef"><b>Definition:</b> <a href="_mix_transport_element_8hpp_source.html#l01381">MixTransportElement.hpp:1381</a></div></div>
<div class="ttc" id="astruct_mix_transport_1_1_mix_transport_element_html_a75e46b9de15a71bf5138c801ed92a527"><div class="ttname"><a href="struct_mix_transport_1_1_mix_transport_element.html#a75e46b9de15a71bf5138c801ed92a527">MixTransport::MixTransportElement::valuesGradientAtGaussPts</a></div><div class="ttdeci">MatrixDouble valuesGradientAtGaussPts</div><div class="ttdoc">gradients at integration points on element</div><div class="ttdef"><b>Definition:</b> <a href="_mix_transport_element_8hpp_source.html#l00075">MixTransportElement.hpp:75</a></div></div>
<div class="ttc" id="astruct_mix_transport_1_1_mix_transport_element_html_acd897d63c94070449821109a721b2726"><div class="ttname"><a href="struct_mix_transport_1_1_mix_transport_element.html#acd897d63c94070449821109a721b2726">MixTransport::MixTransportElement::getResistivity</a></div><div class="ttdeci">virtual MoFEMErrorCode getResistivity(const EntityHandle ent, const double x, const double y, const double z, MatrixDouble3by3 &amp;inv_k)</div><div class="ttdoc">natural (Dirichlet) boundary conditions (set values)</div><div class="ttdef"><b>Definition:</b> <a href="_mix_transport_element_8hpp_source.html#l00126">MixTransportElement.hpp:126</a></div></div>
<div class="ttc" id="astruct_mix_transport_1_1_mix_transport_element_html_ade9b21eb65ae4419dda4f8ab51b4fb55"><div class="ttname"><a href="struct_mix_transport_1_1_mix_transport_element.html#ade9b21eb65ae4419dda4f8ab51b4fb55">MixTransport::MixTransportElement::divergenceAtGaussPts</a></div><div class="ttdeci">VectorDouble divergenceAtGaussPts</div><div class="ttdoc">divergence at integration points on element</div><div class="ttdef"><b>Definition:</b> <a href="_mix_transport_element_8hpp_source.html#l00077">MixTransportElement.hpp:77</a></div></div>
<div class="ttc" id="astruct_mix_transport_1_1_mix_transport_element_html_ae4baeb3ccff530cacba43fd18969364d"><div class="ttname"><a href="struct_mix_transport_1_1_mix_transport_element.html#ae4baeb3ccff530cacba43fd18969364d">MixTransport::MixTransportElement::getSource</a></div><div class="ttdeci">virtual MoFEMErrorCode getSource(const EntityHandle ent, const double x, const double y, const double z, double &amp;flux)</div><div class="ttdoc">set source term</div><div class="ttdef"><b>Definition:</b> <a href="_mix_transport_element_8hpp_source.html#l00109">MixTransportElement.hpp:109</a></div></div>
<div class="ttc" id="astruct_mix_transport_1_1_mix_transport_element_html_aed25d2483c3ac9398c1914f4cd24c5ce"><div class="ttname"><a href="struct_mix_transport_1_1_mix_transport_element.html#aed25d2483c3ac9398c1914f4cd24c5ce">MixTransport::MixTransportElement::fluxesAtGaussPts</a></div><div class="ttdeci">MatrixDouble fluxesAtGaussPts</div><div class="ttdoc">fluxes at integration points on element</div><div class="ttdef"><b>Definition:</b> <a href="_mix_transport_element_8hpp_source.html#l00078">MixTransportElement.hpp:78</a></div></div>
<div class="ttc" id="astruct_op_error_html"><div class="ttname"><a href="struct_op_error.html">OpError</a></div><div class="ttdef"><b>Definition:</b> <a href="initial__diffusion_8cpp_source.html#l00061">initial_diffusion.cpp:61</a></div></div>
</div><!-- fragment --><p> The scheme in which how we implement is similar to those above, we integrate values, save them on volume tags, and aggregate errors from individual elements. Note that we read tag values of previously calculated error from adjacent to tetrahedra faces, summing them up to calculate  \(
\sum_{e \in \partial T} \eta_{e,R}^2
\).</p>
<h1><a class="anchor" id="mixtransport_meshrefinement"></a>
Mesh refinement</h1>
<p >We will build a refined mesh from scratch, each time we add the new level. Using bit refinement levels (see <a class="el" href="mix_transport.html#mix_mesh_refinement">Explaining mesh BitRefLevel</a>) we can do that efficiently.</p>
<p >Since we build mesh without hanging nodes, not all edges in coarse tetrahedra are always refined. Refining such tetrahedra in subsequent refinements would result in poorly shaped elements. We will show how to overcome this difficulty.</p>
<p >Implementation of mesh refinement is in ExampleMix::refineMesh. First, we have to create a set of edges which are going to be split. This set is built from edges which were refined in previous mesh refinement levels and new edges which are adjacent to tetrahedra which have error above threshold. We used the standard "greedy" strategy for h-adaptive refinements, i.e. all elements which contribute 25% of the maximum element contribution to the square of total error in energy norm are marked for the refinement.</p>
<p >To get edges which have been refined in previous steps we run </p><div class="fragment"><div class="line"><span class="keyword">const</span> RefEntity_multiIndex *ref_ents_ptr;</div>
<div class="line"><span class="comment">// get pointer to multi-index in databse having all entities</span></div>
<div class="line"><a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> mField.get_ref_ents(&amp;ref_ents_ptr); </div>
<div class="line"><span class="keyword">typedef</span> RefEntity_multiIndex::index&lt;Composite_EntType_and_ParentEntType_mi_tag&gt;::type RefEntsByComposite;</div>
<div class="line"><span class="keyword">const</span> RefEntsByComposite &amp;ref_ents = ref_ents_ptr-&gt;get&lt;Composite_EntType_and_ParentEntType_mi_tag&gt;();</div>
<div class="line">RefEntsByComposite::iterator rit,hi_rit;</div>
<div class="line"><span class="comment">// get all entities which parenrt are vertices and parent is edges.</span></div>
<div class="line">rit = ref_ents.lower_bound(boost::make_tuple(MBVERTEX,MBEDGE));</div>
<div class="line">hi_rit = ref_ents.upper_bound(boost::make_tuple(MBVERTEX,MBEDGE));</div>
<div class="line"><span class="comment">// get parent edges, those edges were refined in previous steps</span></div>
<div class="line"><a class="code hl_class" href="class_range.html">Range</a> refined_edges;</div>
<div class="line"><span class="comment">// thist loop is over vertices which parent is edge</span></div>
<div class="line"><span class="keywordflow">for</span>(;rit!=hi_rit;rit++) {</div>
<div class="line">  refined_edges.insert((*rit)-&gt;getParentEnt()); <span class="comment">// get parent edge</span></div>
<div class="line">}</div>
</div><!-- fragment --><p >To get entities which are deemed to refine at this level, we first get all elements which have error of 25% of the maximum element contribution </p><div class="fragment"><div class="line"><span class="comment">// get tets which has large error</span></div>
<div class="line"><a class="code hl_class" href="class_range.html">Range</a> tets_to_refine;</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> max_error = ufe.errorMap.rbegin()-&gt;first;</div>
<div class="line"><span class="keywordflow">for</span>(</div>
<div class="line">  map&lt;double,EntityHandle&gt;::iterator mit = ufe.errorMap.begin();</div>
<div class="line">  mit!=ufe.errorMap.end();</div>
<div class="line">  mit++</div>
<div class="line">) {</div>
<div class="line">  <span class="keywordflow">if</span>(mit-&gt;first&lt;0.25*max_error) <span class="keywordflow">continue</span>;</div>
<div class="line">  tets_to_refine.insert(mit-&gt;second);</div>
<div class="line">}</div>
</div><!-- fragment --><p> where <b>ufe.errorMap</b> is filled in <a class="el" href="struct_mix_transport_1_1_mix_transport_element_1_1_op_error.html" title="calculate error evaluator">MixTransport::MixTransportElement::OpError</a> .</p>
<p >Once we have elements, we can find adjacent edges </p><div class="fragment"><div class="line"><a class="code hl_class" href="class_range.html">Range</a> tets_to_refine_edges;</div>
<div class="line"><a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> mField.get_moab().get_adjacencies(</div>
<div class="line">  tets_to_refine,1,<span class="keyword">false</span>,tets_to_refine_edges,moab::Interface::UNION</div>
<div class="line">); </div>
</div><!-- fragment --><p> and merge edges into the set of all edges which are refined or going to be refined </p><div class="fragment"><div class="line">refined_edges.merge(tets_to_refine_edges);</div>
</div><!-- fragment --><p >At that point we have elements and edges to refine so we can do mesh refinement. Mesh refinement is managed by interface <a class="el" href="struct_mo_f_e_m_1_1_mesh_refinement.html" title="Mesh refinement interface.">MoFEM::MeshRefinement</a>, we can query for that interface as follows </p><div class="fragment"><div class="line"><a class="code hl_struct" href="struct_mo_f_e_m_1_1_mesh_refinement.html">MoFEM::MeshRefinement</a> *refine_ptr;</div>
<div class="line"><a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> mField.getInterface(refine_ptr); </div>
<div class="ttc" id="astruct_mo_f_e_m_1_1_mesh_refinement_html"><div class="ttname"><a href="struct_mo_f_e_m_1_1_mesh_refinement.html">MoFEM::MeshRefinement</a></div><div class="ttdoc">Mesh refinement interface.</div><div class="ttdef"><b>Definition:</b> <a href="_mesh_refinement_8hpp_source.html#l00026">MeshRefinement.hpp:26</a></div></div>
</div><!-- fragment --><p> with this interface at hand, we do </p><div class="fragment"><div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">int</span> ll = 0;ll!=<a class="code hl_variable" href="level__set_8cpp.html#a4a62410a15dcd5a702a26f8bff4ae683">nb_levels</a>;ll++) {</div>
<div class="line"> <span class="comment">// get edges from previous mesh level</span></div>
<div class="line">  <a class="code hl_class" href="class_range.html">Range</a> edges;</div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> mField.getInterface&lt;BitRefManager&gt;()-&gt;getEntitiesByTypeAndRefLevel(</div>
<div class="line">    BitRefLevel().set(ll),BitRefLevel().set(),MBEDGE,edges</div>
<div class="line">  ); </div>
<div class="line">  <span class="comment">// get intersection of all edges to refine and edges of previous level</span></div>
<div class="line">  edges = intersect(edges,refined_edges);</div>
<div class="line">  <span class="comment">// refine edges by creation of node in middle of edge, if node was previously created use that node, and set BitRefLevel to that node</span></div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> refine_ptr-&gt;<a class="code hl_function" href="struct_mo_f_e_m_1_1_mesh_refinement.html#aaed88f73c43b3030907ce108217c39e7">addVerticesInTheMiddleOfEdges</a>(edges,BitRefLevel().set(ll+1)); </div>
<div class="line">  <span class="comment">//  get all tetrahderals for current refined level</span></div>
<div class="line">  <a class="code hl_class" href="class_range.html">Range</a> tets;</div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> mField.getInterface&lt;BitRefManager&gt;()-&gt;getEntitiesByTypeAndRefLevel(</div>
<div class="line">    BitRefLevel().set(ll),BitRefLevel().set(),MBTET,tets</div>
<div class="line">  ); </div>
<div class="line">  <span class="comment">// refine those tetrahedrals using nodes in middle of refined edges</span></div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> refine_ptr-&gt;<a class="code hl_function" href="struct_mo_f_e_m_1_1_mesh_refinement.html#a7f731867b68b721d54096ceced3b9947">refineTets</a>(tets,BitRefLevel().set(ll+1)); </div>
<div class="line">  <span class="comment">// update meshsets with boundary conditons, etc.</span></div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> updateMeshsetsFieldsAndElements(ll+1); </div>
<div class="line">}</div>
<div class="ttc" id="astruct_mo_f_e_m_1_1_mesh_refinement_html_a7f731867b68b721d54096ceced3b9947"><div class="ttname"><a href="struct_mo_f_e_m_1_1_mesh_refinement.html#a7f731867b68b721d54096ceced3b9947">MoFEM::MeshRefinement::refineTets</a></div><div class="ttdeci">MoFEMErrorCode refineTets(const EntityHandle meshset, const BitRefLevel &amp;bit, int verb=QUIET, const bool debug=false)</div><div class="ttdoc">refine TET in the meshset</div><div class="ttdef"><b>Definition:</b> <a href="_mesh_refinement_8cpp_source.html#l00190">MeshRefinement.cpp:190</a></div></div>
<div class="ttc" id="astruct_mo_f_e_m_1_1_mesh_refinement_html_aaed88f73c43b3030907ce108217c39e7"><div class="ttname"><a href="struct_mo_f_e_m_1_1_mesh_refinement.html#aaed88f73c43b3030907ce108217c39e7">MoFEM::MeshRefinement::addVerticesInTheMiddleOfEdges</a></div><div class="ttdeci">MoFEMErrorCode addVerticesInTheMiddleOfEdges(const EntityHandle meshset, const BitRefLevel &amp;bit, const bool recursive=false, int verb=QUIET, EntityHandle start_v=0)</div><div class="ttdoc">make vertices in the middle of edges in meshset and add them to refinement levels defined by bit</div><div class="ttdef"><b>Definition:</b> <a href="_mesh_refinement_8cpp_source.html#l00042">MeshRefinement.cpp:42</a></div></div>
</div><!-- fragment --><h1><a class="anchor" id="mixtransport_future_work"></a>
Future work and contribution</h1>
<p >If you like to contribute to this module (or <a class="el" href="namespace_mo_f_e_m.html" title="implementation of Data Operators for Forces and Sources">MoFEM</a> library), you are very welcome. Please feel free to add changes, including improving this documentation. If you like to work and modify this user module, you can fork this repository, make your changes, and do pull request. <a class="el" href="struct_contact.html">Contact</a> us <a href="https://groups.google.com/forum/#!forum/mofem-group">mofem-group@googlegroups.com</a> or <a href="https://mofem.slack.com/">https://mofem.slack.com/</a> if you need any help or comments.</p>
<p >This is work in progress, and more stuff can be done. You could consider own paper or student project.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000079">Todo:</a></b></dt><dd>Make this documentation better</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000080">Todo:</a></b></dt><dd>hp-adaptive</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000081">Todo:</a></b></dt><dd>Problem tailored preconditioner for Krylov solver</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000082">Todo:</a></b></dt><dd>Convergence study, estimation of constants</dd></dl>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr cla ss="footer" />
<style>
  img[src="UoGLogo.png"] {
    height: 20px;
    padding-top: 0px;
    padding-right: 1px;
    padding-bottom: 3px;
    padding-left: 6px;
  }
</style>
<address class="footer">
  <small>
    Generated by
    <a href="http://www.doxygen.org/index.html"> Doxygen </a> 1.9.5
    and hosted at
    <a href="http://www.gla.ac.uk/schools/engineering/">
      <img class="footer" src="UoGLogo.png" alt="University of Glasgow" />
    </a>
  </small>
</address>
</body>
</html>