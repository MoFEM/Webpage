<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
  <meta http-equiv="X-UA-Compatible" content="IE=9"/>
  <meta name="generator" content="Doxygen 1.12.0"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>MoFEM: FUN-1: Integration on finite element mesh</title>
  <link href="tabs.css" rel="stylesheet" type="text/css"/>
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
  <script type="text/javascript " src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML "></script>
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        extensions: ["AMSmath.js"],
        TeX: { equationNumbers: { autoNumber: ["all"],
                                  useLabelIds: true
        } 
        }
    });
    </script>
  <link href="customdoxygen.css" rel="stylesheet" type="text/css" />
  <link href="extra_style.css" rel="stylesheet" type="text/css"/>
  <link rel="apple-touch-icon" sizes="57x57" href="apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192"  href="android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.png">
  <link rel="shortcut icon" type="image/png" href="favicon-32x32.png"/>
  <link rel="Bookmark" type="image/png" href="favicon-32x32.png"/>
  <link rel="manifest" href="manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div style="background-color:#011A40" id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 30px;">
  <td id="projectlogo"><img alt="Logo" src="MoFEMLogo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <td style="padding-left: 0.5em;" bgcolor="#011A40"
   <div id="projectbrief"><font color="#FFFFFF">v0.14.0</font></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!--Google analytics tags-->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-65236130-1', 'auto');
  ga('send', 'pageview');
</script>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-2J9RE2P3H5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-2J9RE2P3H5');
</script>
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div id="doc-content">
<div><div class="header">
  <div class="headertitle"><div class="title">FUN-1: Integration on finite element mesh</div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul>
  <li class="level1">
    <a href="#integration_intro">Introduction</a>
  </li>
  <li class="level1">
    <a href="#integration_start">Essentials</a>
    <ul>
      <li class="level2">
        <a href="#integration_notations">Notations</a>
      </li>
      <li class="level2">
        <a href="#integration_simplexes">Integration on simplexes</a>
      </li>
      <li class="level2">
        <a href="#integration_moments">Moments of inertia</a>
      </li>
    </ul>
  </li>
  <li class="level1">
    <a href="#integration_theory">Theory</a>
    <ul>
      <li class="level2">
        <a href="#integration_elements">Integral over elements</a>
      </li>
      <li class="level2">
        <a href="#integration_rule">Integration on the element</a>
      </li>
      <li class="level2">
        <a href="#integration_approx">Approximation of density field</a>
      </li>
      <li class="level2">
        <a href="#integration_jacobian">Jacobian</a>
      </li>
    </ul>
  </li>
  <li class="level1">
    <a href="#integration_implementation">Implementation</a>
    <ul>
      <li class="level2">
        <a href="#integration_installations">Installation</a>
      </li>
      <li class="level2">
        <a href="#running_lesson_1">Running code</a>
      </li>
      <li class="level2">
        <a href="#integration_programming">Editor</a>
      </li>
      <li class="level2">
        <a href="#basci_integration_main">Main function</a>
      </li>
      <li class="level2">
        <a href="#basci_integration_error_handling">Error handling</a>
      </li>
      <li class="level2">
        <a href="#integration_example_class">Example class</a>
        <ul>
          <li class="level3">
            <a href="#integration_example_setup">Setup problem</a>
          </li>
          <li class="level3">
            <a href="#integration_example_common_data">Common data structure</a>
          </li>
          <li class="level3">
            <a href="#integration_bc">Setting density field</a>
          </li>
          <li class="level3">
            <a href="#integration_operators">Operators and pipelines</a>
          </li>
        </ul>
      </li>
      <li class="level2">
        <a href="#integration_checking">Checking code validity</a>
      </li>
    </ul>
  </li>
  <li class="level1">
    <a href="#Debugging">Debugging</a>
  </li>
  <li class="level1">
    <a href="#basci_integration_code">Code</a>
  </li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="integration_intro"></a>
Introduction</h1>
<p>The first lesson is solely devoted to numerical integration. Integration is essential for most of the numerical methods (except for the collocation method) used to solve partial differential equations (PDEs).</p>
<p>The most straightforward interpretation of the finite element method is to consider it as a method for integration of functions on complex shapes. The integration domain is divided into elements with primitive shapes, e.g. edge, triangle, quad, tetrahedron, or hexahedron, and on each element integration rule for the primitive shape is evaluated. Thus a complex problem is broken into many simple elements, on which the same simple procedure is executed over and over. Such repeatable tasks make it a perfect method for a computer.</p>
<p>We will present the problem of numerical integration by calculating moments of inertia. Moments of inertia characterise the distribution and amount of the mass in the body and have various engineering applications.</p>
<p>First, we explain essential formulas and provide a definition of moments of inertia. Next section is dedicated to the theory, and finally we show details of implementation in <a class="el" href="namespace_mo_f_e_m.html" title="implementation of Data Operators for Forces and Sources">MoFEM</a>.</p>
<h1><a class="anchor" id="integration_start"></a>
Essentials</h1>
<dl class="section note"><dt>Note</dt><dd>In geometry, a simplex is a generalization of the notion of a triangle or tetrahedron to arbitrary dimensions. Note that an edge is also considered as a particular case of the simplex, see <a href="https://en.wikipedia.org/wiki/Simplex">Simplex</a> for more details.</dd></dl>
<h2><a class="anchor" id="integration_notations"></a>
Notations</h2>
<p>For future references we provide a table of some essential mathematical notations which will be used in this and following lessons:</p>
<a class="anchor" id="multi_row"></a>
<table class="doxtable">
<caption>Mathematical notations </caption>
<tr>
<th rowspan="2">Subscripts (lower indices) and <br  />
 superscripts (upper indices) </th><th colspan="3">Font style </th></tr>
<tr>
<th>normal </th><th>bold </th><th>normal with overline (bar) </th></tr>
<tr>
<th>without sub- or superscript </th><td style="text-align:center">scalar (0-rank tensor) <br  />
 <em>e.g</em>. \(\rho, M, v, a, \ell\) </td><td style="text-align:center">higher-rank (1,2, ...) tensor <br  />
 <em>e.g</em>. \(\mathbf{x}, \boldsymbol{\xi}, \boldsymbol{\lambda}, \mathbf{S}, \mathbf{I}, \mathbf{J}\) </td><td style="text-align:center">coefficients vector <br  />
 <em>e.g</em>. \(\bar{x}, \bar{\rho}\) </td></tr>
<tr>
<th>with subscript (lower index) </th><td style="text-align:center">scalar value at a point <br  />
 <em>e.g</em>. \(W_g, w_g, \rho_g \) </td><td style="text-align:center">tensor value at a point <br  />
 <em>e.g</em>. \(\mathbf{x}_i, \boldsymbol{\xi}_g, \mathbf{J}_g, \boldsymbol{\lambda}_i\) </td><td style="text-align:center">element of a coefficients vector <br  />
 <em>e.g</em>. \(\bar{\rho}_m\) </td></tr>
<tr>
<th>with superscript (upper), <br  />
 except \((.)^e\) and \((.)^h\) </th><td style="text-align:center">component of a tensor <br  />
 <em>e.g</em>. \(x^i, S^i, I^{ij}, \xi^i, \lambda^i, J^{ij}\) </td><td style="text-align:center">coordinate basis vector <br  />
 <em>e.g</em>. \(\mathbf{x}^i, \boldsymbol{\xi}^i\) </td><td style="text-align:center">spatial component of an element of <br  />
 a coefficients vector, <em>e.g</em>. \(\bar{x}_m^i\) </td></tr>
<tr>
<th>with superscript \((.)^e\) </th><td colspan="3" style="text-align:center">corresponding to \(e\)-th element <br  />
 <em>e.g</em>. \(\rho_g^e, \mathbf{J}_g^e, \mathcal{T}^e\) </td></tr>
<tr>
<th>with superscript \((.)^h\) </th><td colspan="2" style="text-align:center">reference to the approximation <br  />
 <em>e.g</em>. \(\Omega^h, \rho^h, \rho_g^h, \mathbf{x}^h, \mathbf{x}_g^h\) </td><td style="text-align:center">not used </td></tr>
</table>
<h2><a class="anchor" id="integration_simplexes"></a>
Integration on simplexes</h2>
<p>Numerical integration of a function \(\rho(x)\) by the means of the finite element method is given by the following general formula:      </p><p class="formulaDsp">
\[
\begin{align}
\label{eq:num_int}
  I(\rho) = \int_\Omega \rho\,\textrm{d}\Omega \approx \sum_{e=0}^{N-1} \sum_{g=0}^{G-1} W_g\|\mathbf{J}_g^e\|\rho^e_g
\end{align}
\]
</p>
<p> where \(W_g\) is the weight of the \(g\)-th integration point, \(\|\mathbf{J}_g^e\|\) is the determinant of the Jacobian of the \(e\)-th element's transformation from the physical (global) coordinate system to the reference (local) coordinate system (evaluated at the \(g\)-th integration point), and \(\rho^e_g\) is the value of the function at \(g\)-th integration point. Finally, \(G\) is the number of integration points per each element, and \(N\) is the total number of elements in a mesh. Typically, the sum of integration weights in each element equals to unity:     </p><p class="formulaDsp">
\[
\begin{align}
\sum_{g=0}^{G-1} W_g = 1.
\end{align}
\]
</p>
<p> Furthermore, for the case of simplexes the numerical integration formula \eqref{eq:num_int} takes a more straightforward form:</p>
<ul>
<li>For a tetrahedron     <p class="formulaDsp">
\[
\begin{align}
  I(\rho) \approx \sum_{e=0}^{N-1} \sum_{g=0}^{G-1} (W_g v) \, \rho^e_g,
\end{align}
\]
</p>
 where \(v\) is the volume of an element (tetrahedron);</li>
<li>For a triangle     <p class="formulaDsp">
\[
\begin{align}
  I(\rho) \approx \sum_{e=0}^{N-1} \sum_{g=0}^{G-1} (W_g a) \, \rho^e_g,
\end{align}
\]
</p>
 where \(a\) is the area of an element (triangle);</li>
<li>For an edge     <p class="formulaDsp">
\[
\begin{align}
  I(\rho) \approx \sum_{e=0}^{N-1} \sum_{g=0}^{G-1} (W_g \ell) \, \rho^e_g,
\end{align}
\]
</p>
 where \(\ell\) is the length of a line element (edge).</li>
</ul>
<p>In the following sections we explain how the above sums are evaluated and give additional details about the Jacobian. <br  />
</p>
<h2><a class="anchor" id="integration_moments"></a>
Moments of inertia</h2>
<p>The distribution of mass in the body can be characterised by moments of inertia. Moments of inertia have practical applications, they are used for analysis of motion of rigid bodies, or to characterise cross-section area in the structural analysis.</p>
<p>In general, moments of inertia are tensors. Zero moment is represented by a single scalar coefficient, first moment is a 1D array, i.e. a vector of coefficients, and second moment is a second-order tensor, coefficients of which for convenience can be organised in a 2D table, i.e. a matrix. Note that these coefficients depend on the observer, i.e. coordinate system, and the tensorial transformation rule describes how coefficients of moments of inertia change with the observer.</p>
<ul>
<li>Zero moment of inertia is the mass of the body:     <p class="formulaDsp">
\[
\begin{align}
M := \int_\Omega \rho(\mathbf{x}) \, \textrm{d}\Omega,
\end{align}
\]
</p>
 where \(\rho\) is the material density, and \(\Omega\) is the body domain. Mass characterises how much force is to be applied for a desired body acceleration \(\mathbf{a}=\{a^i\}\) as stated by the Newton's law:     <p class="formulaDsp">
\[
\begin{align}
a^i = M f^i,
\end{align}
\]
</p>
 where \(\mathbf{f}=\{f^i\}\) is the force. Moreover, the kinematic energy can be expressed as:     <p class="formulaDsp">
\[
\begin{align}
E_k = \frac{v^i M v^i}{2},
\end{align}
\]
</p>
 where \(\mathbf{v}=\{v^i\}\) is the velocity, and the summation over repeating indices is assumed. Note also, that for the zero moment the tensorial transformation rule is straightforward: the mass of an object cannot be changed by looking at it from different points and angles, so it is the same in every coordinate system.</li>
<li>First moment of inertia \(\mathbf{S}=\{S^i\}\) is given by:     <p class="formulaDsp">
\[
\begin{align}
S^i := \int_\Omega \rho(\mathbf{x}) \, x^i \textrm{d}\Omega
\end{align}
\]
</p>
 where \(x^i\) is the coordinate in the \(i\)-th direction. According to that, the center of gravity of the body can be calculated as:     <p class="formulaDsp">
\[
\begin{align}
x_c^i = \frac{S^i}{M},
\end{align}
\]
</p>
 where \(\mathbf{x}_c=\{x_c^i\}\) are the coordinates of the centre of gravity of the body, or system of bodies. Note that if the origin is placed at the centre of gravity, then the first moment of inertia is zero.</li>
<li>Second moment of inertia \(\mathbf{I}=\{I^{ij}\}\) is defined as:     <p class="formulaDsp">
\[
\begin{align}
I^{ij} := \int_\Omega \rho(\mathbf{x}) \left(x^ix^j\right) \textrm{d}\Omega,
\end{align}
\]
</p>
 where the term \((x^ix^j)\) represents the <a href="https://en.wikipedia.org/wiki/Outer_product">Outer product</a>. Second moment of inertia, analogously to mass, characterises how much torque is to be applied at the origin for desired body angular acceleration \(\boldsymbol\alpha=\{\alpha^i\}\), as follows:     <p class="formulaDsp">
\[
\begin{align}
\alpha^i = I^{ij} \tau^j = I^{ij} (\varepsilon^{jmn} x^m f^n)
\end{align}
\]
</p>
 where \(\boldsymbol\tau=\{\tau^j\}\) is the torque vector, and \(\varepsilon^{jmn}\) is the <a href="https://en.wikipedia.org/wiki/Levi-Civita_symbol">Levi-Civita symbol</a>, while the term in brackets is the cross product of the force vector and arm on which this force acts. Finally, the kinematic energy of the rotating body can be computed as     <p class="formulaDsp">
\[
\begin{align}
E_k = \frac{\omega^i I^{ij} \omega^j}{2}.
\end{align}
\]
</p>
</li>
</ul>
<h1><a class="anchor" id="integration_theory"></a>
Theory</h1>
<p>This section is not essential and can be skipped, you may move to implementation and come back later for a more in-depth understanding of the problem.</p>
<dl class="section note"><dt>Note</dt><dd>In this section formulas describing numerical integration are provided for the general case of 3D integration domains. At the same time, for clarity in figures we will show illustrative examples with 2D domains. Note that the program provided in this lesson is designed for a general 3D case, however, integration on 2D domains can be also performed after a small code alteration.</dd></dl>
<h2><a class="anchor" id="integration_elements"></a>
Integral over elements</h2>
<p>We start by dividing the integration domain \(\Omega\) into a union of non-overlapping primitive shapes (elements) \(\mathcal{T}^e\) such that:     </p><p class="formulaDsp">
\[
\begin{align}
\bigcup_{e=0}^{N-1}\mathcal{T}^e=\Omega^h,
\end{align}
\]
</p>
<p> where \(\Omega^h\) is termed as the discretisation (approximation) of the domain \(\Omega\), see <a class="el" href="#basic_l1_figure_1">Figure 1</a>. For the rest of the tutorials, we will be using \((\cdot)^h\) to indicate a reference of the given quantity the approximation. Note that subscript <em>h</em> historically refers to the lateral size of an element, e.g. maximal edge length.</p>
<p><a class="anchor" id="basic_l1_figure_1"></a></p><div class="image">
<img src="integration_discretisation.png" alt="" width="600px"/>
<div class="caption">
Figure 1: Discretisation of the integration domain</div></div>
<p>The integral of function the \(\rho(\mathbf{x})\), where coordinates \(\mathbf{x}\in \Omega\), can be computed approximately as a sum of integrals over all elements:     </p><p class="formulaDsp">
\[
\begin{align}
  I(\rho) = \int_\Omega \rho(\mathbf{x}) \textrm{d}\Omega \approx \int_{\Omega^h} \rho(\mathbf{x}) \textrm{d}\Omega = \sum_{e=0}^{N-1} \int_{\mathcal{T}^e} \rho(\mathbf{x}) \textrm{d}\Omega = \sum_{e=0}^{N-1} I_{\mathcal{T}^e},
\end{align}
\]
</p>
<p> where \(I_{\mathcal{T}^e}\) is the integral over the element \(\mathcal{T}^e\). The error in this computation is introduced by substituting the integration domain \(\Omega\) by a discrete mesh \(\Omega^h\). Taking a closer look at the domain \(\Omega\) in <a class="el" href="#basic_l1_figure_1">Figure 1</a>, you can see that geometry is complex and contains curved edges. In the discretised domain \(\Omega^h\) these edges are not represented precisely, since finite elements have straight edges, thus there is some difference between the mathematical model and its finite element discretisation. However, it is good news that the error, i.e. difference between the mathematical model and its discretised version, can be controlled. You can refine the mesh until error becomes small enough, as small as you need. From the other hand, if the surfaces of the domain \(\Omega\) are flat, i.e. edges are straight, then the geometry is approximated exactly. At the same time, one can also generalise and describe edges of elements by polynomials of second and higher orders, which enables even more control of the geometrical error. However, in this tutorial, we restrict ourselves to representing the geometry by linear <em>shape functions</em>.</p>
<h2><a class="anchor" id="integration_rule"></a>
Integration on the element</h2>
<p>Next we discuss how the integral over a single element \(\mathcal{T}^e\) is computed. The repeated task of integrating over elements can be simplified if we perform the change of coordinates for each element from the physical (global) coordinate system \(\{\mathbf{x}^0, \mathbf{x}^1, \mathbf{x}^2\}\) to a reference (local) coordinate system \(\{\boldsymbol{\xi}^0, \boldsymbol{\xi}^1, \boldsymbol{\xi}^2\}\). Thus, the integration can be performed on a reference element which will be the same for all physical elements, see <a class="el" href="#basic_l1_figure_2">Figure 2</a>.</p>
<p><a class="anchor" id="basic_l1_figure_2"></a></p><div class="image">
<img src="integration_reference_element.png" alt="" width="800px"/>
<div class="caption">
Figure 2: Integration on a reference element</div></div>
<p>For example, for a triangle element after such change of coordinates the integral can be computed as:      </p><p class="formulaDsp">
\[
\begin{align}
  I_\mathcal{T} = 
  \int_{\mathcal{T}} \rho(\mathbf{x})\, \textrm{d}x = \int\limits_{0}^{1}\int\limits_{0}^{1-\xi^0} \rho(\mathbf{x}(\boldsymbol{\xi})) \|\mathbf{J}\|\, \textrm{d}\xi^0\textrm{d}\xi^1,
\end{align}
\]
</p>
<p> where \(\mathbf{J}\) is the Jacobian of transformation of coordinates.</p>
<p>The integral \(I_\mathcal{T}\) is not to be computed analytically. Since the function \(\rho(\mathbf{x})\) in general can be arbitrary, numerical integration is used, in particular the <a href="https://en.wikipedia.org/wiki/Gaussian_quadrature">Gauss quadrature rule</a> is the most popular for the finite-element method. This approach requires evaluation of the integrated function \(\rho(\mathbf{x})\) at so-called integration (Gauss) points, locations of which are pre-defined for the reference element, see <a class="el" href="#basic_l1_figure_3">Figure 3</a>.</p>
<p>Integration on each element, applying integration formulae, is as follows:       </p><p class="formulaDsp">
\[
\begin{align}
  I_\mathcal{T} = 
  \int_{\mathcal{T}} \rho(\mathbf{x}) \textrm{d}\mathcal{T} \approx
  \sum_{g=0}^{G-1} W_g \rho\left(\mathbf{x}(\pmb\xi_g)\right) \|\mathbf{J}_g\|,
\end{align}
\]
</p>
<p> where \(\rho\left(\mathbf{x}(\pmb\xi_g)\right)\) is the value of the function at \(g\)-th integration point, \(W_g\) is the integration weight of this point and \(\mathbf{J}_g\) is the value of the Jacobian at the same integration point. Note that for brevity we will also use a notation \(w_g=\| \mathbf{J}_g \| W_g\). You can see that integral is expressed simply as the sum of function values at integration multiplied by weights, something which can be easily implemented as a computer program, see also <a class="el" href="#basic_l1_figure_3">Figure 3</a>. For a given <a href="https://en.wikipedia.org/wiki/Gaussian_quadrature">Gauss quadrature formula</a> polynomials can be calculated exactly up to order of integration rule \(r\), without any numerical error. Therefore, the only error of integration comes from the fact that integrated function is approximated by polynomials, i.e. \(\rho_g \approx \rho_g^h\). If the function is analytical (i.e. differentiable infinite number of times), the order of error is of \(O(h^r)\), where \(h\) is the size of the element. We will discuss how to choose the integration rule on an element in the following section.</p>
<p><a class="anchor" id="basic_l1_figure_3"></a></p><div class="image">
<img src="integration_integration_pt_lesson1.png" alt="" width="700px"/>
<div class="caption">
Figure 3: Integration points on an element</div></div>
<p>For integration on simplexes, i.e. (vertices), edges, triangles, tetrahedra, for convenience and efficiency integration points are often given by <a href="https://en.wikipedia.org/wiki/Barycentric_coordinate_system">barycentric coordinates</a> \(\pmb\lambda\), see <a class="el" href="#basic_l1_figure_2">Figure 2</a>. For quadrilaterals and hexahedra, quadrature points are constructed by the tensor product of integration rules in 1D, see right of <a class="el" href="#basic_l1_figure_4">Figure 4</a>. In the same way one can construct integration for other elements shapes, e.g. for prisms by the tensor product of integration on triangle and edge. For some element shapes like for the wedge, one can use Duffy transform. Duffy integration is constructed from hexahedron integration rule, and subsequently some of the nodes are collapsed. Such procedure degenerates a hexahedron to a wedge, in other words, the reference element is a hexahedron, but the physical element is a wedge.</p>
<p>Finally, in the example code below we will use the integration rule from the shelf. Moreover, at the moment, no matter what is the shape of a finite element, or how integration points and weights are calculated. We have to remember the numerical integration will be the sum of integration weights multiplied by function values at integration points, and we are using that in this lesson. Implementation of such integration is trivial with the use of a single loop.</p>
<h2><a class="anchor" id="integration_approx"></a>
Approximation of density field</h2>
<p>The remaining question is how to evaluate field \(\rho(\mathbf{x}(\pmb\xi_g))\) at integration points? In real-world problems the data such as the density field is not given by an analytical function, but is rather known from another simulation or an experiment only at nodes of the finite-element mesh. Therefore, to make our code more general, we will compute the values of the density field at integration points using the following interpolation: <a class="anchor" id="integration_approx_rho"></a>       </p><p class="formulaDsp">
\[
\begin{align}
  \label{eq:interp_rho}
  \rho_g = \rho(\mathbf{x}(\pmb\xi_g)) 
  \approx \rho^h_g = \sum_{m=0}^{M-1} \mathcal{N}_m(\pmb\xi_g) \bar{\rho}_m
\end{align}
\]
</p>
<p> where \(\rho^h_g\) is the interpolated value at integration point \(\pmb\xi_g\), \(\mathcal{N}_m\) is shape function at node \(m\), \(M\) is the number of nodes in the element, see <a class="el" href="#basic_l1_figure_4">Figure 4</a>, and \(\bar{\rho}_m\) is the value of the density field at node \(m\). Note that the same shape functions are used here for approximation of the geometry and for approximation of a field, this approach is known as the <em>isoparametric</em> finite element method. For linear shape functions, as in <a class="el" href="#basic_l1_figure_4">Figure 4</a>, approximation error is order of \(O(h^2)\), where \(h\) is size of element (e.g. maximal length of an edge). The <a href="https://en.wikipedia.org/wiki/Big_O_notation">symbol big \(O\)</a> is a mathematical notation which describes in this case how the error changes with the mesh size \(h\). In this particular case, it means that for every reduction of mesh size by ten times, approximation error reduces one hundred times. By making mesh smaller, the error of approximation can be controlled to achieve desired accuracy. Another way to improve the quality of the approximation and achieve arbitrary error order, is to use higher-order polynomials to approximate function \(\rho\), see <a class="el" href="hierarchical_approximation_1.html">FUN-2: Hierarchical approximation</a> for more details. Note that for a polynomial of order \(p\) the approximation error is of order \(O(h^{p+1})\).</p>
<p><a class="anchor" id="basic_l1_figure_4"></a></p><div class="image">
<img src="integration_shape_function_quad_and_tri.png" alt="" width="800px"/>
<div class="caption">
Figure 4: Shape functions on triangle and quadrilateral</div></div>
<dl class="section note"><dt>Note</dt><dd>A numerical method does not have to be exact (if it is that is great), but it is not the "Holy Grail". We always aim for the method to be consistent, i.e. solution must converge to the exact solution, converges should be fast, and method should be robust, i.e. can solve real-world problems, not only academic exercises.</dd></dl>
<h2><a class="anchor" id="integration_map"></a>
Mapping reference and physical element</h2>
<p>Here we present more details regarding the transformation between the physical and reference coordinate systems, while the next section is devoted to computation of the Jacobian.</p>
<p><a class="anchor" id="basic_l1_figure_5"></a></p><div class="image">
<img src="integration_map.png" alt="" width="800px"/>
<div class="caption">
Figure 5: Map reference element to physical element</div></div>
<p><a class="el" href="#basic_l1_figure_5">Figure 5</a> presents a map between the reference element (red triangle) and element in physical configuration (blue triangle). Maps transform, shift, rotate and stretch element, and establish one to one relation (at least for all points without element boundary) between coordinates in reference element \(\pmb\xi\) and physical coordinates \(\mathbf{x}\) as follows: <br  />
 <a class="anchor" id="integration_map"></a>       </p><p class="formulaDsp">
\[
\begin{align}
  \label{eq:interp_coord}
  \left(x^h\right)^i (\pmb\xi) = 
  \sum_{m=0}^{M-1} \mathcal{N}_m(\pmb\xi) \bar{x}_m^i 
\end{align}
\]
</p>
<p> Equation \eqref{eq:interp_coord} is not very different from equation \eqref{eq:interp_rho}, the only difference is that is evaluated for every coefficient \(i=0..(d-1)\), where \(d\) is the dimension of the problem, e.g. for 3D problem \(d=3\).</p>
<h2><a class="anchor" id="integration_jacobian"></a>
Jacobian</h2>
<p>Note that integration over the physical element is problematic; it is much easier to construct integration rule on the reference element and integrate on it. This way weights and integration point coordinates can be pre-calculated and stored in the table to be used for all elements on the mesh. To change the integration domain from physical element to the reference element, the concepts of a map, the tangent map and Jacobian are needed.</p>
<p>From <a class="el" href="#basic_l1_figure_5">Figure 5</a> we can see that an infinitesimal element in the reference configuration can be mapped to an infinitesimal element in the physical space by mapping infinitesimal vectors \(\textrm{d}\pmb\xi\) into \(\textrm{d}\mathbf{x}\). Expanding such map at any point \(\mathbf{q}\) into Taylor series, we get: <a class="anchor" id="basic_taylor_expansion"></a>       </p><p class="formulaDsp">
\[
  \begin{align}
  x_\mathbf{q}^i = 
  x_\mathbf{p}^i + \textrm{d}x^i = 
  x_\mathbf{p}^i + J^{ij}(\xi_\mathbf{P}) \textrm{d}\xi^j + O\left(\|\textrm{d}\xi\|^2\right),
  \end{align}
\]
</p>
<p> where Jacobian is        </p><p class="formulaDsp">
\[
  \begin{align}
  J^{ij}(\pmb\xi_\mathbf{P})  = 
  \sum_{m=0}^{M-1} \left.
  \frac{\partial \mathcal{N}_m}{\partial \xi^j}
  \right|_\mathbf{P} \bar{x}_m^i
  \end{align}
\]
</p>
<p> Therefore, the infinitesimal vector \(\textrm{d}\mathbf{x}\) can be computed as:     </p><p class="formulaDsp">
\[
  \begin{align}
  \textrm{d}x^i = J^{ij}(\xi_\mathbf{P}) \textrm{d}\xi^j,
  \end{align}
\]
</p>
<p> omitting higher-order terms on the right-hand side, since we focus our attention on infinitesimal elements in reference and physical configurations, and, consequently, it can be assumed that \(\|\textrm{d}\pmb\xi\|^2 = 0\) without making any error. Note that once the higher-order terms are omitted, equation mapping domain in the vicinity of a point in the reference element into the domain in the vicinity of a point in the physical element is linear. This is called the tangent map since it is accurate only in the vicinity of the tangent point. Like a tangent plane pinned to the earth, glob can represent distances accurately between locations only in the small range from where it is pinned.</p>
<p>Using above derivation for the Jacobian, in the general 3D case, i.e. for tetrahedron or hexahedron, infinitesimal element volume \(\textrm{d}v\) at any point in the physical configuration can be expressed as     </p><p class="formulaDsp">
\[
\begin{align}
\textrm{d}v = \varepsilon^{ijk} \textrm{d}x_0^i \textrm{d}x_1^j \textrm{d}x_2^k = \varepsilon^{ijk} J^{i\alpha}\textrm{d}\xi^\alpha_0 J^{j\beta}\textrm{d}\xi^\beta_1 J^{k\gamma}\textrm{d}\xi^\gamma_2
\end{align}
\]
</p>
<p> where \(\varepsilon^{ijk}\) is the <a href="https://en.wikipedia.org/wiki/Levi-Civita_symbol">Levi-Civita symbol</a> and the Einstein summation is assumed. Since in the reference configuration vectors \(\textrm{d}\pmb\xi_0, \textrm{d}\pmb\xi_1, \textrm{d}\pmb\xi_2\) are collinear with the coordinate base vectors \(\pmb\xi^0, \pmb\xi^1, \pmb\xi^2\) , respectively, only components with \(\alpha = 0, \beta = 1, \gamma = 2\) are non-zero. Therefore,      </p><p class="formulaDsp">
\[
\begin{align}
\textrm{d}v = \varepsilon^{ijk} J^{i0} J^{j1} J^{k2} \left(\textrm{d}\xi^0_0 \textrm{d}\xi^1_1 \textrm{d}\xi^2_2\right) = \varepsilon^{ijk}
J^{i0} J^{j1} J^{k2} \textrm{d}V,
\end{align}
\]
</p>
<p> where \(\textrm{d}V\) is the volume of the infinitesimal element in the reference configuration and \(J^{i0}\), \(J^{j1}\), and \(J^{k2}\) are columns of the Jacobian. Using the connection between the Levi-Civita symbol and the determinant of the Jacobian (see details <a href="https://en.wikipedia.org/wiki/Levi-Civita_symbol#Determinants">here</a>), we may write:     </p><p class="formulaDsp">
\[
\begin{align}
  \textrm{d}v = \| \mathbf{J} \| \textrm{d}V,
\end{align}
\]
</p>
<p> i.e. the determinant of the Jacobian provides the scaling value between infinitesimal element volumes in two configurations. Note that for lower dimensions above equation also holds. Finally, we have everything necessary to calculate the integral on the finite element mesh:     </p><p class="formulaDsp">
\[
\begin{align}
  I(f) \approx \sum_{e=0}^{N-1} \sum_{g=0}^{G-1} W_g \| \mathbf{J}_g^e \| \left(\rho^h_g\right)^e
\end{align}
\]
</p>
<dl class="section note"><dt>Note</dt><dd>You can learn more about integration from <a class="el" href="citelist.html#CITEREF_zienkiewicz1977finite">[79]</a>.</dd>
<dd>
No one person invented the finite element method, but it roots in the invention of <em>shape functions</em> and isoparametric finite elements by <a href="https://en.wikipedia.org/wiki/Bruce_Irons_(engineer)">B. M. Irons</a> along with Ian C. Taig.</dd></dl>
<h1><a class="anchor" id="integration_implementation"></a>
Implementation</h1>
<h2><a class="anchor" id="integration_installations"></a>
Installation</h2>
<p>If you want to develop code in <a class="el" href="namespace_mo_f_e_m.html" title="implementation of Data Operators for Forces and Sources">MoFEM</a>, and you probably do if you are reading this tutorial, you will need to install developer version of <a class="el" href="namespace_mo_f_e_m.html" title="implementation of Data Operators for Forces and Sources">MoFEM</a> following instructions <a class="el" href="install_spack.html">Installation with Spack (Advanced)</a>.</p>
<p>Executable files are located in </p><div class="fragment"><div class="line">$HOME/mofem_install/um/build_debug/tutorials/<a class="code hl_variable" href="dg__projection_8cpp.html#a47f5c9a54ebf753d18651f417f81f4e8">fun</a>-1</div>
<div class="ttc" id="adg__projection_8cpp_html_a47f5c9a54ebf753d18651f417f81f4e8"><div class="ttname"><a href="dg__projection_8cpp.html#a47f5c9a54ebf753d18651f417f81f4e8">fun</a></div><div class="ttdeci">auto fun</div><div class="ttdoc">Function to approximate.</div><div class="ttdef"><b>Definition</b> <a href="dg__projection_8cpp_source.html#l00036">dg_projection.cpp:36</a></div></div>
</div><!-- fragment --><p> whereas the source code is located in </p><div class="fragment"><div class="line">$HOME/mofem_install/mofem-cephas/mofem/users_modules/tutorials/<a class="code hl_variable" href="dg__projection_8cpp.html#a47f5c9a54ebf753d18651f417f81f4e8">fun</a>-1</div>
</div><!-- fragment --><p> This is called <em>out-of-source</em> <em>compilation</em> since code and programs are located in two different locations. It is a convenient way if you have different compilation options or linking different libraries, and you would like to test them all against the same source code. Code in <code>build_debug</code> is compiled with debugging flags and is not optimised. Using the debugger you can run such code line by line, which can help you understand how it works and find errors in your code. Information on how to debug code can be found <a href="https://code.visualstudio.com/docs/introvideos/debugging">here</a>.</p>
<dl class="section note"><dt>Note</dt><dd>In the default <a class="el" href="namespace_mo_f_e_m.html" title="implementation of Data Operators for Forces and Sources">MoFEM</a> installation you can create executables under another location which is <div class="fragment"><div class="line">$HOME/mofem_install/um/build_release/tutorials/<a class="code hl_variable" href="dg__projection_8cpp.html#a47f5c9a54ebf753d18651f417f81f4e8">fun</a>-1</div>
</div><!-- fragment --> Executable files in <code>build_release</code> location are optimised, and are running much faster but are also harder to inspect with the debugger.</dd></dl>
<h2><a class="anchor" id="running_lesson_1"></a>
Running code</h2>
<p>To run code type: </p><div class="fragment"><div class="line">cd $HOME/mofem_install/build_release/tutorials/<a class="code hl_variable" href="dg__projection_8cpp.html#a47f5c9a54ebf753d18651f417f81f4e8">fun</a>-1</div>
<div class="line">./integration -file_name <a class="code hl_function" href="nonlinear__poisson__2d_8cpp.html#af4080b4104d18fe9035d130afdcc2a9c">cube</a>.h5m</div>
<div class="ttc" id="anonlinear__poisson__2d_8cpp_html_af4080b4104d18fe9035d130afdcc2a9c"><div class="ttname"><a href="nonlinear__poisson__2d_8cpp.html#af4080b4104d18fe9035d130afdcc2a9c">cube</a></div><div class="ttdeci">double cube(const double x)</div><div class="ttdef"><b>Definition</b> <a href="nonlinear__poisson__2d_8cpp_source.html#l00013">nonlinear_poisson_2d.cpp:13</a></div></div>
</div><!-- fragment --><p>Code is executed for the mesh of a cube, see <a class="el" href="#integration_figure5">Figure 6</a>, which has unit size for all edges and the coordinates origin is in the centre of the cube. <a class="anchor" id="integration_figure5"></a></p><div class="image">
<img src="integration_cube.png" alt="" width="700px"/>
<div class="caption">
Figure 6: Cube</div></div>
<p>Code output should be similar to the following: </p><div class="fragment"><div class="line">[0] &lt;inform&gt; <a class="code hl_namespace" href="namespace_mo_f_e_m.html">MoFEM</a> version 0.10.0 (MOAB 5.1.0 Petsc Release Version 3.11.3, Jun, 26, 2019 )</div>
<div class="line">[0] &lt;inform&gt; git commit <span class="keywordtype">id</span> b92c8e15a8778955152f75a61e3b67a4e6c9bb3a</div>
<div class="line">[0] &lt;inform&gt; Local time: 2020-Sep-12 19:55:14</div>
<div class="line">[0] &lt;inform&gt; UTC time: 2020-Sep-12 18:55:14</div>
<div class="line">[0] &lt;inform&gt; [FieldCore] Add field <a class="code hl_variable" href="plastic_8cpp.html#a3ed57096651b587c2bf716fa78048153">rho</a> field_id 1 space <a class="code hl_enumvalue" href="definitions_8h.html#a5ed4cb303bab8cd0673ae12e5bc73c12a7ec6526640e5add74fe4b322e6343120">H1</a> approximation base <a class="code hl_enumvalue" href="definitions_8h.html#a2ed4ed94b56d2843840bb7c55adcf0c5a54a26843865f4712f50a74fa4f8d025d">AINSWORTH_LEGENDRE_BASE</a> rank 1 meshset 12682136550675316765</div>
<div class="line">[0] &lt;inform&gt; [FECore] Add finite element dFE</div>
<div class="line">[0] &lt;inform&gt; [ProblemCore] Add problem SimpleProblem</div>
<div class="line">[0] &lt;inform&gt; [FieldCore] Number of dofs 64</div>
<div class="line">[0] &lt;inform&gt; [FECore] Finite element dFE added. Nb. of elements added 162</div>
<div class="line">[0] &lt;inform&gt; [FECore] Number of adjacencies 648</div>
<div class="line">[0] &lt;inform&gt; [ProblemsManager] SimpleProblem Nb. local dof 64 by 64 nb global dofs 64 by 64</div>
<div class="line">[0] &lt;inform&gt; [ProblemsManager]  FEs ghost dofs on problem SimpleProblem Nb. ghost dof 0 by 0 Nb. local dof 64 by 64</div>
<div class="line">[0] &lt;inform&gt; Mass 1.0000e+00</div>
<div class="line">[0] &lt;inform&gt; First moment of inertia [ -4.3368e-19, -1.4095e-17, -1.3878e-17 ]</div>
<div class="line">[0] &lt;inform&gt; Second moment of inertia [ 8.3333e-02, -2.1684e-19, 4.3368e-19; 8.3333e-02 -5.7463e-18; 8.3333e-02 ]</div>
<div class="ttc" id="adefinitions_8h_html_a2ed4ed94b56d2843840bb7c55adcf0c5a54a26843865f4712f50a74fa4f8d025d"><div class="ttname"><a href="definitions_8h.html#a2ed4ed94b56d2843840bb7c55adcf0c5a54a26843865f4712f50a74fa4f8d025d">AINSWORTH_LEGENDRE_BASE</a></div><div class="ttdeci">@ AINSWORTH_LEGENDRE_BASE</div><div class="ttdoc">Ainsworth Cole (Legendre) approx. base nme:nme847.</div><div class="ttdef"><b>Definition</b> <a href="definitions_8h_source.html#l00061">definitions.h:60</a></div></div>
<div class="ttc" id="adefinitions_8h_html_a5ed4cb303bab8cd0673ae12e5bc73c12a7ec6526640e5add74fe4b322e6343120"><div class="ttname"><a href="definitions_8h.html#a5ed4cb303bab8cd0673ae12e5bc73c12a7ec6526640e5add74fe4b322e6343120">H1</a></div><div class="ttdeci">@ H1</div><div class="ttdoc">continuous field</div><div class="ttdef"><b>Definition</b> <a href="definitions_8h_source.html#l00085">definitions.h:85</a></div></div>
<div class="ttc" id="anamespace_mo_f_e_m_html"><div class="ttname"><a href="namespace_mo_f_e_m.html">MoFEM</a></div><div class="ttdoc">implementation of Data Operators for Forces and Sources</div><div class="ttdef"><b>Definition</b> <a href="_common_8hpp_source.html#l00010">Common.hpp:10</a></div></div>
<div class="ttc" id="aplastic_8cpp_html_a3ed57096651b587c2bf716fa78048153"><div class="ttname"><a href="plastic_8cpp.html#a3ed57096651b587c2bf716fa78048153">rho</a></div><div class="ttdeci">double rho</div><div class="ttdef"><b>Definition</b> <a href="plastic_8cpp_source.html#l00140">plastic.cpp:140</a></div></div>
</div><!-- fragment --><p>At the beginning the code prints the version of the <a class="el" href="namespace_mo_f_e_m.html" title="implementation of Data Operators for Forces and Sources">MoFEM</a> library. In the same line, versions of MOAB and PETSc libraries are printed respectively. This will enable to reproduce errors if occurred and fix bugs. Next information printed is about the name of finite elements being added, i.e. <code>dFE</code>, which stands for "domain finite element", and the name given to the density field, i.e. <code>rho</code>. For this field DOFs are added only on vertices, thus the linear approximation of density is considered. After that, the information about the number of finite elements is printed, i.e. <code>Nb. FEs 162</code>, the name of the problem itself, i.e. <code>SimplePrblem</code>, the number of DOFs on rows &amp; columns, i.e. <code>row dofs 64</code>, <code>col dofs 64</code>, and other information related to mesh partitioning. Finally, the results are printed.</p>
<h2><a class="anchor" id="integration_programming"></a>
Editor</h2>
<p>You can use your favourite editor if you have one, e.g. <code>vim</code>, <code>emacs</code>, <code>sublime</code>, <code>atom.io</code>, etc, however, if you have no preferences, we recommend <a href="https://code.visualstudio.com">VS Code</a>. We have some tips on how you can configure it to make it work well with <a class="el" href="namespace_mo_f_e_m.html" title="implementation of Data Operators for Forces and Sources">MoFEM</a>, see <a class="el" href="faqs.html#configure_vs_code">How to configure MoFEM in Visual Studio Code?</a></p>
<dl class="section note"><dt>Note</dt><dd>We have some programming conventions, and follow a certain style of programming, see <a class="el" href="coding_practice.html">Coding practice</a>. You do not have to learn these conventions right away; it usually comes natural to pick up the style on the way like children pick up cultural conventions when they grow up. In <a class="el" href="namespace_mo_f_e_m.html" title="implementation of Data Operators for Forces and Sources">MoFEM</a>, we are using <code>clang-format</code> to help us unify programming style. Most of the editors support <code>clang-format</code>, for example, how to do that in <code>VS Code</code> is described <a href="https://code.visualstudio.com/docs/cpp/cpp-ide">here</a>. Keeping the same style, learning and following programming conventions is essential for the long-term development. <a class="el" href="namespace_mo_f_e_m.html" title="implementation of Data Operators for Forces and Sources">MoFEM</a> is an open community code, and if everyone follows the agreed style, it improves code readability, and people understand each other better.</dd></dl>
<h2><a class="anchor" id="basci_integration_main"></a>
Main function</h2>
<p>The main function is relatively short and looks the same for each program in this set of tutorials: </p><div class="fragment"><div class="line"><span class="comment"></span><span class="keywordtype">int</span> <a class="code hl_function" href="adol-c__atom_8cpp.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a>(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[]) {</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Initialisation of MoFEM/PETSc and MOAB data structures</span></div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">char</span> param_file[] = <span class="stringliteral">&quot;param_file.petsc&quot;</span>;</div>
<div class="line">  <a class="code hl_function" href="struct_mo_f_e_m_1_1_core_tmp_3_010_01_4.html#a137f1f2092d00ef0c1ec679db94b8cb0">MoFEM::Core::Initialize</a>(&amp;argc, &amp;argv, param_file, <a class="code hl_variable" href="activate__deactivate__dofs_8cpp.html#a29680e68c64040f4884f60691a193226">help</a>);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Error handling</span></div>
<div class="line">  <span class="keywordflow">try</span> {</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">    //! [Register MoFEM discrete manager in PETSc]</span></div>
<div class="line"><span class="comment"></span>    DMType dm_name = <span class="stringliteral">&quot;DMMOFEM&quot;</span>;</div>
<div class="line">    <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> <a class="code hl_function" href="group__dm.html#ga899ec9d1ad35488bbe4273731f6d5c90">DMRegister_MoFEM</a>(dm_name);<span class="comment"></span></div>
<div class="line"><span class="comment">    //! [Register MoFEM discrete manager in PETSc]</span></div>
<div class="line"><span class="comment"></span><span class="comment"></span> </div>
<div class="line"><span class="comment">    //! [Create MoAB]</span></div>
<div class="line"><span class="comment"></span>    moab::Core mb_instance;              <span class="comment">///&lt; mesh database</span></div>
<div class="line">    moab::Interface &amp;moab = mb_instance; <span class="comment">///&lt; mesh database interface</span><span class="comment"></span></div>
<div class="line"><span class="comment">    //! [Create MoAB]</span></div>
<div class="line"><span class="comment"></span><span class="comment"></span> </div>
<div class="line"><span class="comment">    //! [Create MoFEM]</span></div>
<div class="line"><span class="comment"></span>    <a class="code hl_struct" href="struct_mo_f_e_m_1_1_core_tmp_3_010_01_4.html">MoFEM::Core</a> core(moab);           <span class="comment">///&lt; finite element database</span></div>
<div class="line">    <a class="code hl_struct" href="struct_mo_f_e_m_1_1_deprecated_core_interface.html">MoFEM::Interface</a> &amp;m_field = core; <span class="comment">///&lt; finite element database interface</span><span class="comment"></span></div>
<div class="line"><span class="comment">    //! [Create MoFEM]</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line">    <a class="code hl_struct" href="struct_example.html">Example</a> ex(m_field);</div>
<div class="line">    <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> ex.runProblem();</div>
<div class="line">  }</div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#a1e74d797bf522e2b291419cddab27835">CATCH_ERRORS</a>;</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> <a class="code hl_function" href="struct_mo_f_e_m_1_1_core_tmp_3_010_01_4.html#aa5abe3b5d998e2dc50e4ef6916915eb1">MoFEM::Core::Finalize</a>();</div>
<div class="line">}<span class="comment"></span></div>
</div><!-- fragment --><p>You can use the above snippet to start your code. The main function is responsible for kick-starting the job, and it has following stages:</p>
<ul>
<li>The main program begins with registering <a class="el" href="namespace_mo_f_e_m.html" title="implementation of Data Operators for Forces and Sources">MoFEM</a> Discrete Manager (DM) interface in PETSc data structures. That enables transparent control of <a class="el" href="namespace_mo_f_e_m.html" title="implementation of Data Operators for Forces and Sources">MoFEM</a> database by PETSc solvers, and vice-versa: to use PETSc standard interface to create matrices, vectors, and other PETSc objects;</li>
<li>Next, the MOAB database is created and connected to the interface. A similar approach is used for the <a class="el" href="namespace_mo_f_e_m.html" title="implementation of Data Operators for Forces and Sources">MoFEM</a> database. MOAB database stores data about the mesh, whereas <a class="el" href="namespace_mo_f_e_m.html" title="implementation of Data Operators for Forces and Sources">MoFEM</a> database stores data related to the finite element method, e.g. approximation bases, finite elements and problems. Therefore, <a class="el" href="namespace_mo_f_e_m.html" title="implementation of Data Operators for Forces and Sources">MoFEM</a> is another level of abstraction on top of the MOAB database, since finite element data is stored on data tags created on mesh entities;</li>
<li>Finally, problem-specific example class is created, and calculations are executed in <a class="el" href="struct_example.html#a9bc8db5cd1e1c4dc349ea7f0c1ec6bae" title="[Run problem]">Example::runProblem</a>.</li>
</ul>
<h2><a class="anchor" id="basci_integration_error_handling"></a>
Error handling</h2>
<p>Errors are caught at the end using the following code: </p><div class="fragment"><div class="line"><span class="keywordflow">try</span> {</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Some code here</span></div>
<div class="line"> </div>
<div class="line">}</div>
<div class="line"><a class="code hl_define" href="definitions_8h.html#a1e74d797bf522e2b291419cddab27835">CATCH_ERRORS</a>;</div>
<div class="ttc" id="adefinitions_8h_html_a1e74d797bf522e2b291419cddab27835"><div class="ttname"><a href="definitions_8h.html#a1e74d797bf522e2b291419cddab27835">CATCH_ERRORS</a></div><div class="ttdeci">#define CATCH_ERRORS</div><div class="ttdoc">Catch errors.</div><div class="ttdef"><b>Definition</b> <a href="definitions_8h_source.html#l00385">definitions.h:385</a></div></div>
</div><!-- fragment --><p> This part of the code is responsible for handling all errors initiated inside PETSc, MOAB, Boost, standard library, and <a class="el" href="namespace_mo_f_e_m.html" title="implementation of Data Operators for Forces and Sources">MoFEM</a> or developer functions. PETSc, MOAB, and <a class="el" href="namespace_mo_f_e_m.html" title="implementation of Data Operators for Forces and Sources">MoFEM</a> functions return error codes, to handle them properly the following macro is used: </p><div class="fragment"><div class="line"><a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> PetscFunction();   <span class="comment">// PETSc function</span></div>
<div class="line"><a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> moab.function();   <span class="comment">// MOAB function</span></div>
<div class="line"><a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> m_field.function(); <span class="comment">// MoFEM function</span></div>
<div class="ttc" id="adefinitions_8h_html_add80e5ef5f847b2d4b637029f0f671c3"><div class="ttname"><a href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a></div><div class="ttdeci">#define CHKERR</div><div class="ttdoc">Inline error check.</div><div class="ttdef"><b>Definition</b> <a href="definitions_8h_source.html#l00548">definitions.h:548</a></div></div>
</div><!-- fragment --><p> Catching errors will make searching for runtime errors easier, and in case of the problem appearing see <a class="el" href="guidelines_bug_reporting.html">Guidelines for bug reporting</a> for seeking help. <code>CHKERR</code> is a macro which checks error code returned by the function, and if returned code indicates an error, program stops and prints the corresponding error.</p>
<dl class="section note"><dt>Note</dt><dd>In programming you can encounter two types of error, <em>compilation errors</em> and <em>runtime errors</em>. <em>Compilation errors</em> are most often syntax errors, which prevent the compiler from making program, i.e. you see them when you run <em>make</em> for your program. <em>Runtime errors</em> are caused by bugs in the program code such as segmentation fault, overflow, bad algorithm or you run out of computer resources, e.g. memory. Those errors need to be handled to properly indicate user what and where the problem is.</dd></dl>
<h2><a class="anchor" id="integration_example_class"></a>
Example class</h2>
<p>Each lesson in the tutorial series has an example class which has a very similar structure to the following: </p><div class="fragment"><div class="line"><span class="comment"></span><span class="keyword">struct </span><a class="code hl_struct" href="struct_example.html">Example</a> {</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_function" href="struct_example.html#a8d161cbfd4fedcd73fbbebf5760a4c69">Example</a>(<a class="code hl_struct" href="struct_mo_f_e_m_1_1_deprecated_core_interface.html">MoFEM::Interface</a> &amp;m_field) : <a class="code hl_variable" href="struct_example.html#ab79afebe5c16553d0c38e3ec022f868f">mField</a>(m_field) {}</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_typedef" href="namespace_mo_f_e_m_1_1_exceptions.html#a8fb6351034eac301fc47fdf2748c1b45">MoFEMErrorCode</a> <a class="code hl_function" href="struct_example.html#a9bc8db5cd1e1c4dc349ea7f0c1ec6bae">runProblem</a>();</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <a class="code hl_struct" href="struct_mo_f_e_m_1_1_deprecated_core_interface.html">MoFEM::Interface</a> &amp;<a class="code hl_variable" href="struct_example.html#ab79afebe5c16553d0c38e3ec022f868f">mField</a>;</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_typedef" href="namespace_mo_f_e_m_1_1_exceptions.html#a8fb6351034eac301fc47fdf2748c1b45">MoFEMErrorCode</a> <a class="code hl_function" href="struct_example.html#a4f638fb3f3e04b410627f11476f1fb74">setUp</a>();</div>
<div class="line">  <a class="code hl_typedef" href="namespace_mo_f_e_m_1_1_exceptions.html#a8fb6351034eac301fc47fdf2748c1b45">MoFEMErrorCode</a> <a class="code hl_function" href="struct_example.html#a717e41915fd8c44f6eebeff08d6fa381">createCommonData</a>();</div>
<div class="line">  <a class="code hl_typedef" href="namespace_mo_f_e_m_1_1_exceptions.html#a8fb6351034eac301fc47fdf2748c1b45">MoFEMErrorCode</a> <a class="code hl_function" href="struct_example.html#ada2df6216e12e1434ae8dbad981fa130">setFieldValues</a>();</div>
<div class="line">  <a class="code hl_typedef" href="namespace_mo_f_e_m_1_1_exceptions.html#a8fb6351034eac301fc47fdf2748c1b45">MoFEMErrorCode</a> <a class="code hl_function" href="struct_example.html#a06acd214d6979fdb2d0f2e519727e12c">pushOperators</a>();</div>
<div class="line">  <a class="code hl_typedef" href="namespace_mo_f_e_m_1_1_exceptions.html#a8fb6351034eac301fc47fdf2748c1b45">MoFEMErrorCode</a> <a class="code hl_function" href="struct_example.html#afe986014c24e23ce20b757ac12906ace">integrateElements</a>();</div>
<div class="line">  <a class="code hl_typedef" href="namespace_mo_f_e_m_1_1_exceptions.html#a8fb6351034eac301fc47fdf2748c1b45">MoFEMErrorCode</a> <a class="code hl_function" href="struct_example.html#abf1476c965357f99692a8f231723aaab">postProcess</a>();</div>
<div class="line">  <a class="code hl_typedef" href="namespace_mo_f_e_m_1_1_exceptions.html#a8fb6351034eac301fc47fdf2748c1b45">MoFEMErrorCode</a> <a class="code hl_function" href="struct_example.html#a6eda930af795f95e64047fbc35d80826">checkResults</a>();</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">struct </span><a class="code hl_struct" href="struct_common_data.html">CommonData</a>;</div>
<div class="line"> </div>
<div class="line">  boost::shared_ptr&lt;CommonData&gt; <a class="code hl_variable" href="struct_example.html#a3d51ec4713edafe2234ee9f970373015">commonDataPtr</a>;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">struct </span>OpZero;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">struct </span>OpFirst;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">struct </span>OpSecond;</div>
<div class="line">};<span class="comment"></span></div>
</div><!-- fragment --><p>Function <a class="el" href="struct_example.html#a9bc8db5cd1e1c4dc349ea7f0c1ec6bae" title="[Run problem]">Example::runProblem</a> called by the main program has the following code: </p><div class="fragment"><div class="line"><span class="comment"></span><a class="code hl_typedef" href="namespace_mo_f_e_m_1_1_exceptions.html#a8fb6351034eac301fc47fdf2748c1b45">MoFEMErrorCode</a> <a class="code hl_function" href="struct_example.html#a9bc8db5cd1e1c4dc349ea7f0c1ec6bae">Example::runProblem</a>() {</div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#a6c0b52978f1abc88bf8a1ba70b7308e3">MoFEMFunctionBegin</a>;</div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> <a class="code hl_function" href="struct_example.html#a4f638fb3f3e04b410627f11476f1fb74">setUp</a>();</div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> <a class="code hl_function" href="struct_example.html#a717e41915fd8c44f6eebeff08d6fa381">createCommonData</a>();</div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> <a class="code hl_function" href="struct_example.html#ada2df6216e12e1434ae8dbad981fa130">setFieldValues</a>();</div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> <a class="code hl_function" href="struct_example.html#a06acd214d6979fdb2d0f2e519727e12c">pushOperators</a>();</div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> <a class="code hl_function" href="struct_example.html#afe986014c24e23ce20b757ac12906ace">integrateElements</a>();</div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> <a class="code hl_function" href="struct_example.html#abf1476c965357f99692a8f231723aaab">postProcess</a>();</div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> <a class="code hl_function" href="struct_example.html#a6eda930af795f95e64047fbc35d80826">checkResults</a>();</div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#acb0a46d159695a01bf667313b7788b45">MoFEMFunctionReturn</a>(0);</div>
<div class="line">}<span class="comment"></span></div>
</div><!-- fragment --><p>Note that every function starts and ends with error handling </p><div class="fragment"><div class="line"><a class="code hl_define" href="definitions_8h.html#a6c0b52978f1abc88bf8a1ba70b7308e3">MoFEMFunctionBegin</a>;</div>
<div class="line"><span class="comment">// function body</span></div>
<div class="line"><a class="code hl_define" href="definitions_8h.html#acb0a46d159695a01bf667313b7788b45">MoFEMFunctionReturn</a>(0);</div>
<div class="ttc" id="adefinitions_8h_html_a6c0b52978f1abc88bf8a1ba70b7308e3"><div class="ttname"><a href="definitions_8h.html#a6c0b52978f1abc88bf8a1ba70b7308e3">MoFEMFunctionBegin</a></div><div class="ttdeci">#define MoFEMFunctionBegin</div><div class="ttdoc">First executable line of each MoFEM function, used for error handling. Final line of MoFEM functions ...</div><div class="ttdef"><b>Definition</b> <a href="definitions_8h_source.html#l00359">definitions.h:359</a></div></div>
<div class="ttc" id="adefinitions_8h_html_acb0a46d159695a01bf667313b7788b45"><div class="ttname"><a href="definitions_8h.html#acb0a46d159695a01bf667313b7788b45">MoFEMFunctionReturn</a></div><div class="ttdeci">#define MoFEMFunctionReturn(a)</div><div class="ttdoc">Last executable line of each PETSc function used for error handling. Replaces return()</div><div class="ttdef"><b>Definition</b> <a href="definitions_8h_source.html#l00429">definitions.h:429</a></div></div>
</div><!-- fragment --><p> This enables stacking functions calls in case of problems. We use function stacks to see which functions, and on which lines, have been called prior to the error.</p>
<h3><a class="anchor" id="integration_example_setup"></a>
Setup problem</h3>
<p>Before calculation can be performed, some bookkeeping has to be done to manage complexities related to the finite element method. <a class="el" href="namespace_mo_f_e_m.html" title="implementation of Data Operators for Forces and Sources">MoFEM</a> does most of this boring job "in the back-end" and only needs to be provided with initial information:</p>
<div class="fragment"><div class="line"><span class="comment"></span><a class="code hl_typedef" href="namespace_mo_f_e_m_1_1_exceptions.html#a8fb6351034eac301fc47fdf2748c1b45">MoFEMErrorCode</a> <a class="code hl_function" href="struct_example.html#a4f638fb3f3e04b410627f11476f1fb74">Example::setUp</a>() {</div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#a6c0b52978f1abc88bf8a1ba70b7308e3">MoFEMFunctionBegin</a>;</div>
<div class="line">  <a class="code hl_struct" href="struct_mo_f_e_m_1_1_simple.html">Simple</a> *<a class="code hl_function" href="acoustic_8cpp.html#ad68ed57e17c71816ecfad0ea6746c8d3">simple</a> = <a class="code hl_variable" href="struct_example.html#ab79afebe5c16553d0c38e3ec022f868f">mField</a>.<a class="code hl_function" href="struct_mo_f_e_m_1_1_unknown_interface.html#a7ab248ec45fca778800dcd92e5171beb">getInterface</a>&lt;<a class="code hl_struct" href="struct_mo_f_e_m_1_1_simple.html">Simple</a>&gt;();</div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> <a class="code hl_function" href="acoustic_8cpp.html#ad68ed57e17c71816ecfad0ea6746c8d3">simple</a>-&gt;getOptions();</div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> <a class="code hl_function" href="acoustic_8cpp.html#ad68ed57e17c71816ecfad0ea6746c8d3">simple</a>-&gt;loadFile();</div>
<div class="line">  <span class="comment">// Add field</span></div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> <a class="code hl_function" href="acoustic_8cpp.html#ad68ed57e17c71816ecfad0ea6746c8d3">simple</a>-&gt;addDomainField(<span class="stringliteral">&quot;rho&quot;</span>, <a class="code hl_enumvalue" href="definitions_8h.html#a5ed4cb303bab8cd0673ae12e5bc73c12a7ec6526640e5add74fe4b322e6343120">H1</a>, <a class="code hl_enumvalue" href="definitions_8h.html#a2ed4ed94b56d2843840bb7c55adcf0c5a54a26843865f4712f50a74fa4f8d025d">AINSWORTH_LEGENDRE_BASE</a>, 1);</div>
<div class="line">  <span class="keyword">constexpr</span> <span class="keywordtype">int</span> <a class="code hl_variable" href="dg__projection_8cpp.html#ad7eceded84ace5678d9df3e44f47d475">order</a> = 1;</div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> <a class="code hl_function" href="acoustic_8cpp.html#ad68ed57e17c71816ecfad0ea6746c8d3">simple</a>-&gt;setFieldOrder(<span class="stringliteral">&quot;rho&quot;</span>, <a class="code hl_variable" href="dg__projection_8cpp.html#ad7eceded84ace5678d9df3e44f47d475">order</a>);</div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> <a class="code hl_function" href="acoustic_8cpp.html#ad68ed57e17c71816ecfad0ea6746c8d3">simple</a>-&gt;setUp();</div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#acb0a46d159695a01bf667313b7788b45">MoFEMFunctionReturn</a>(0);</div>
<div class="line">}<span class="comment"></span></div>
</div><!-- fragment --><p>We use <a class="el" href="struct_mo_f_e_m_1_1_simple.html" title="Simple interface for fast problem set-up.">MoFEM::Simple</a> interface to read command line options, load mesh file, add a field and set its order. Note that the field is added by function <code>addDomainField</code> and is defined by name, space, approximation base and rank. To approximate density, we choose space <code>H1</code> of square-integrable functions with square-integrable derivatives and use a recipe from <a class="el" href="citelist.html#CITEREF_nme:nme847">[1]</a> to construct base functions, while the rank (number of coefficients) of the base is one since density is a scalar field. The order of approximation is set to one, i.e. linear base functions are used.</p>
<h3><a class="anchor" id="integration_example_common_data"></a>
Common data structure</h3>
<p>The common data structure is used to group the data evaluated at integration points of an element, and also to aggregate data from all elements to be used later by other parts of the code. You will find common data in all examples for the following lessons, and other parts of <a class="el" href="namespace_mo_f_e_m.html" title="implementation of Data Operators for Forces and Sources">MoFEM</a> implementation.</p>
<p>Common data structure is defined as follows: </p><div class="fragment"><div class="line"><span class="comment"></span><span class="keyword">struct </span><a class="code hl_struct" href="struct_example_1_1_common_data.html">Example::CommonData</a></div>
<div class="line">    : <span class="keyword">public</span> boost::enable_shared_from_this&lt;Example::CommonData&gt; {</div>
<div class="line"> </div>
<div class="line">  VectorDouble <a class="code hl_variable" href="struct_example_1_1_common_data.html#ab08e51835ec34dd14f90e42ed7c7a17c">rhoAtIntegrationPts</a>; <span class="comment">///&lt; Storing density at integration points</span></div>
<div class="line"> </div>
<div class="line">  <span class="keyword">inline</span> boost::shared_ptr&lt;VectorDouble&gt; <a class="code hl_function" href="struct_example_1_1_common_data.html#a17a5e8f2053c72cca60ed526480dc5ad">getRhoAtIntegrationPtsPtr</a>() {</div>
<div class="line">    <span class="keywordflow">return</span> boost::shared_ptr&lt;VectorDouble&gt;(shared_from_this(),</div>
<div class="line">                                           &amp;<a class="code hl_variable" href="struct_example_1_1_common_data.html#ab08e51835ec34dd14f90e42ed7c7a17c">rhoAtIntegrationPts</a>);</div>
<div class="line">  }</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">  /**</span></div>
<div class="line"><span class="comment">   * @brief Vector to indicate indices for storing zero, first and second</span></div>
<div class="line"><span class="comment">   * moments of inertia.</span></div>
<div class="line"><span class="comment">   *</span></div>
<div class="line"><span class="comment">   */</span></div>
<div class="line">  <span class="keyword">enum</span> <a class="code hl_enumeration" href="struct_example_1_1_common_data.html#aa2c35df835c021bdbc4f0c64d37bf66f">VecElements</a> {</div>
<div class="line">    <a class="code hl_enumvalue" href="struct_example_1_1_common_data.html#aa2c35df835c021bdbc4f0c64d37bf66fa1c9cf51d3c94d1e9f9811cfd9ffe0f70">ZERO</a> = 0,</div>
<div class="line">    <a class="code hl_enumvalue" href="struct_example_1_1_common_data.html#aa2c35df835c021bdbc4f0c64d37bf66fa35a8e93a704a8646c97c4bce760aac9e">FIRST_X</a>,</div>
<div class="line">    <a class="code hl_enumvalue" href="struct_example_1_1_common_data.html#aa2c35df835c021bdbc4f0c64d37bf66fa026863406fd2004ee06ab936db4af78e">FIRST_Y</a>,</div>
<div class="line">    <a class="code hl_enumvalue" href="struct_example_1_1_common_data.html#aa2c35df835c021bdbc4f0c64d37bf66fae2a1b91f617aa89858d1632162669131">FIRST_Z</a>,</div>
<div class="line">    <a class="code hl_enumvalue" href="struct_example_1_1_common_data.html#aa2c35df835c021bdbc4f0c64d37bf66fa9ee8e21dd1ab77620fc756d35df31300">SECOND_XX</a>,</div>
<div class="line">    <a class="code hl_enumvalue" href="struct_example_1_1_common_data.html#aa2c35df835c021bdbc4f0c64d37bf66faf728e56b28141d1ec533528b26e129f0">SECOND_XY</a>,</div>
<div class="line">    <a class="code hl_enumvalue" href="struct_example_1_1_common_data.html#aa2c35df835c021bdbc4f0c64d37bf66fa41253069e409e5079d5642a8f236f10a">SECOND_XZ</a>,</div>
<div class="line">    <a class="code hl_enumvalue" href="struct_example_1_1_common_data.html#aa2c35df835c021bdbc4f0c64d37bf66fab7792033026ec3146c04e9e160fa4e2c">SECOND_YY</a>,</div>
<div class="line">    <a class="code hl_enumvalue" href="struct_example_1_1_common_data.html#aa2c35df835c021bdbc4f0c64d37bf66fa5e761046bc8cd47c8c14ebe0068ea822">SECOND_YZ</a>,</div>
<div class="line">    <a class="code hl_enumvalue" href="struct_example_1_1_common_data.html#aa2c35df835c021bdbc4f0c64d37bf66fa5464cebcdf703892cfc92a8deb9a3cf4">SECOND_ZZ</a>,</div>
<div class="line">    <a class="code hl_enumvalue" href="struct_example_1_1_common_data.html#aa2c35df835c021bdbc4f0c64d37bf66fa00b72985c8afae8c58098ba3ca37900c">LAST_ELEMENT</a></div>
<div class="line">  };</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_struct" href="struct_mo_f_e_m_1_1_smart_petsc_obj.html">SmartPetscObj&lt;Vec&gt;</a></div>
<div class="line">      <a class="code hl_variable" href="struct_example_1_1_common_data.html#aad1717441a2871e7eea75d0838652da4">petscVec</a>; <span class="comment">///&lt; Smart pointer which stores PETSc distributed vector</span></div>
<div class="line">};<span class="comment"></span></div>
</div><!-- fragment --><p>while an instance of <a class="el" href="struct_example_1_1_common_data.html" title="[Example]">Example::CommonData</a> class is created by the following method: </p><div class="fragment"><div class="line"><span class="comment"></span><a class="code hl_typedef" href="namespace_mo_f_e_m_1_1_exceptions.html#a8fb6351034eac301fc47fdf2748c1b45">MoFEMErrorCode</a> <a class="code hl_function" href="struct_example.html#a717e41915fd8c44f6eebeff08d6fa381">Example::createCommonData</a>() {</div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#a6c0b52978f1abc88bf8a1ba70b7308e3">MoFEMFunctionBegin</a>;</div>
<div class="line">  <a class="code hl_variable" href="struct_example.html#a3d51ec4713edafe2234ee9f970373015">commonDataPtr</a> = boost::make_shared&lt;CommonData&gt;();</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">int</span> local_size;</div>
<div class="line">  <span class="keywordflow">if</span> (<a class="code hl_variable" href="struct_example.html#ab79afebe5c16553d0c38e3ec022f868f">mField</a>.<a class="code hl_function" href="struct_mo_f_e_m_1_1_core_interface.html#af2224ce77b33637b5cfad66a275a2ffb">get_comm_rank</a>() == 0) <span class="comment">// get_comm_rank() gets processor number</span></div>
<div class="line">    <span class="comment">// processor 0</span></div>
<div class="line">    local_size = <a class="code hl_enumvalue" href="struct_example_1_1_common_data.html#aa2c35df835c021bdbc4f0c64d37bf66fa00b72985c8afae8c58098ba3ca37900c">CommonData::LAST_ELEMENT</a>; <span class="comment">// last element gives size of vector</span></div>
<div class="line">  <span class="keywordflow">else</span></div>
<div class="line">    <span class="comment">// other processors (e.g. 1, 2, 3, etc.)</span></div>
<div class="line">    local_size = 0; <span class="comment">// local size of vector is zero on other processors</span></div>
<div class="line"> </div>
<div class="line">  <a class="code hl_variable" href="struct_example.html#a3d51ec4713edafe2234ee9f970373015">commonDataPtr</a>-&gt;petscVec = <a class="code hl_function" href="namespace_mo_f_e_m.html#a77d94d2111c0c988bc3100b3910cc25c">createVectorMPI</a>(<a class="code hl_variable" href="struct_example.html#ab79afebe5c16553d0c38e3ec022f868f">mField</a>.<a class="code hl_function" href="struct_mo_f_e_m_1_1_core_interface.html#a9b2bc8c1b980f49d31a0b5f7fbe756f5">get_comm</a>(), local_size,</div>
<div class="line">                                                 <a class="code hl_enumvalue" href="struct_example_1_1_common_data.html#aa2c35df835c021bdbc4f0c64d37bf66fa00b72985c8afae8c58098ba3ca37900c">CommonData::LAST_ELEMENT</a>);</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#acb0a46d159695a01bf667313b7788b45">MoFEMFunctionReturn</a>(0);</div>
<div class="line">}<span class="comment"></span></div>
</div><!-- fragment --><p>where memory for <a class="el" href="struct_example_1_1_common_data.html" title="[Example]">Example::CommonData</a> is allocated and handled by a <a href="https://www.boost.org/doc/libs/1_61_0/libs/smart_ptr/shared_ptr.htm">shared pointer</a>. Moreover, using <a href="https://www.boost.org/doc/libs/1_64_0/libs/smart_ptr/enable_shared_from_this.html">enable_shared_from_this</a> and function <a class="el" href="struct_example_1_1_common_data.html#a17a5e8f2053c72cca60ed526480dc5ad">Example::CommonData::getRhoAtIntegrationPtsPtr</a> a shared pointer to a vector <code>rhoAtIntegrationPtsPtr</code> can be obtained. Finally, a PETSc vector is created and stored using <a class="el" href="struct_mo_f_e_m_1_1_smart_petsc_obj.html" title="intrusive_ptr for managing petsc objects">MoFEM::SmartPetscObj</a>, which is a special smart pointer for handling PETSc objects.</p>
<p>Smart pointers, such as <a href="https://www.boost.org/doc/libs/1_72_0/libs/smart_ptr/doc/html/smart_ptr.html#shared_ptr">boost::shared_ptr</a> and <a class="el" href="struct_mo_f_e_m_1_1_smart_petsc_obj.html" title="intrusive_ptr for managing petsc objects">MoFEM::SmartPetscObj</a>, are used to maintain the life of dynamically allocated objects. You can think about smart pointers as regular C/C++ pointers, and to understand the following code you do not have to know more about them. However, more explanation is needed for the following code: </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> local_size;</div>
<div class="line"><span class="keywordflow">if</span> (mField.get_comm_rank() == 0) <span class="comment">// get_comm_rank() gets processor number</span></div>
<div class="line">  <span class="comment">// processor 0</span></div>
<div class="line">  local_size = CommonData::LAST_ELEMENT; <span class="comment">// last element gives size of vector</span></div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">  <span class="comment">// other processors (e.g. 1, 2, 3, etc.)</span></div>
<div class="line">  local_size = 0; <span class="comment">// local size of vector is zero on other processors</span></div>
<div class="line"> </div>
<div class="line">commonDataPtr-&gt;petscVec = createVectorMPI(mField.get_comm(), local_size,</div>
<div class="line">                                               CommonData::LAST_ELEMENT);</div>
</div><!-- fragment --><p> <code>commonDataPtr-&gt;petscVec</code> is a smart pointer to a PETSc MPI Vector, which supports access from multiple processes and is useful for parallel computing. Function <a class="el" href="namespace_mo_f_e_m.html#a77d94d2111c0c988bc3100b3910cc25c" title="Create MPI Vector.">MoFEM::createVectorMPI</a> needs to be provided with a communicator, e.g. <code>mField.get_comm()</code>, which is a communicator of <a class="el" href="namespace_mo_f_e_m.html" title="implementation of Data Operators for Forces and Sources">MoFEM</a>. Communicator holds a group of processes that can communicate with each other. Next, we determine the local size of the vector which will be used to store mass, three coefficients for the first moment and six coefficients for the second moment of inertia, i.e. 10 coefficients in total in the order defined in <a class="el" href="struct_example_1_1_common_data.html#aa2c35df835c021bdbc4f0c64d37bf66f" title="Vector to indicate indices for storing zero, first and second moments of inertia.">Example::CommonData::VecElements</a>. Note that the local size of the vector is 10 on the processor 0, and zero on other processors. It means that all data will be accumulated on processor 0 as shown in <a class="el" href="#basic_l1_figure_7">Figure 7</a>. The global size of the vector is a sum of all local sizes, and thus is also 10.</p>
<p>Note that in all following lessons, including this one, we implemented code to make it work with distributed meshes.</p>
<p><a class="anchor" id="basic_l1_figure_7"></a></p><div class="image">
<img src="integration_partitioning.png" alt="" width="800px"/>
<div class="caption">
Figure 7: Mesh partitioning</div></div>
<h3><a class="anchor" id="integration_bc"></a>
Setting density field</h3>
<div class="fragment"><div class="line"><span class="comment"></span><a class="code hl_typedef" href="namespace_mo_f_e_m_1_1_exceptions.html#a8fb6351034eac301fc47fdf2748c1b45">MoFEMErrorCode</a> <a class="code hl_function" href="struct_example.html#ada2df6216e12e1434ae8dbad981fa130">Example::setFieldValues</a>() {</div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#a6c0b52978f1abc88bf8a1ba70b7308e3">MoFEMFunctionBegin</a>;</div>
<div class="line">  <span class="keyword">auto</span> set_density = [&amp;](VectorAdaptor &amp;&amp;field_data, <span class="keywordtype">double</span> *xcoord,</div>
<div class="line">                         <span class="keywordtype">double</span> *ycoord, <span class="keywordtype">double</span> *zcoord) {</div>
<div class="line">    <a class="code hl_define" href="definitions_8h.html#aee32377dce975c9a64ed73bd3a003404">MoFEMFunctionBeginHot</a>;</div>
<div class="line">    field_data[0] = 1;</div>
<div class="line">    <a class="code hl_define" href="definitions_8h.html#a59cd650c2f6d3e0dc1ad1c29821e8692">MoFEMFunctionReturnHot</a>(0);</div>
<div class="line">  };</div>
<div class="line">  <a class="code hl_struct" href="struct_mo_f_e_m_1_1_field_blas.html">FieldBlas</a> *field_blas;</div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> <a class="code hl_variable" href="struct_example.html#ab79afebe5c16553d0c38e3ec022f868f">mField</a>.<a class="code hl_function" href="struct_mo_f_e_m_1_1_unknown_interface.html#a7ab248ec45fca778800dcd92e5171beb">getInterface</a>(field_blas);</div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> field_blas-&gt;<a class="code hl_function" href="struct_mo_f_e_m_1_1_field_blas.html#a1a08c9a8a4f85bd89b07e9d882165952">setVertexDofs</a>(set_density, <span class="stringliteral">&quot;rho&quot;</span>);</div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#acb0a46d159695a01bf667313b7788b45">MoFEMFunctionReturn</a>(0);</div>
<div class="line">}<span class="comment"></span></div>
</div><!-- fragment --><p>For simplicity, density is set to unity at each node of the mesh, which represents a uniform density field. However, an arbitrary density field can be set using a small modification. Namely, function <code>set_density</code> in <a class="el" href="struct_example.html#ada2df6216e12e1434ae8dbad981fa130" title="[Create common data]">Example::setFieldValues</a> gets coordinates as its arguments, thus you could set any density distribution you would like. Note that the <a class="el" href="namespace_mo_f_e_m.html" title="implementation of Data Operators for Forces and Sources">MoFEM</a> Core function <a class="el" href="struct_mo_f_e_m_1_1_field_blas.html#a1a08c9a8a4f85bd89b07e9d882165952" title="Set DOFs on vertices using user function.">MoFEM::FieldBlas::setVertexDofs</a> is doing the hard work of setting field values to the mesh nodes. This function iterates over all nodes, gets each node's coordinates and calls the function provided by the user, i.e. <code>set_density</code>.</p>
<h3><a class="anchor" id="integration_operators"></a>
Operators and pipelines</h3>
<p>For computing moments of inertia, as well as for solving a multitude of other problems, a <a class="el" href="namespace_mo_f_e_m.html" title="implementation of Data Operators for Forces and Sources">MoFEM</a> developer only needs to provide the code with operators which are executed on finite element entities of the mesh. Operators can do various tasks, for example, evaluate field values at integration points, e.g. calculating \(\rho_g^h\). You will use operators as well to compute integrals when you calculate mass, the first and second moments of inertia. In other examples operators are used for calculating differential operators, e.g. gradient, divergence, etc., or assemble internal forces vector.</p>
<p>You would not have to write explicitly the code which integrates over finite element entities of the mesh, <a class="el" href="namespace_mo_f_e_m.html" title="implementation of Data Operators for Forces and Sources">MoFEM</a> will do that for you once you provide sequences (pipelines) of operators to use. There is a reason for this approach since we aim to write a finite element code which is generic and can be used in different contexts. For example, for solving a variety of problems described by Partial Differential Equations (PDEs) different solvers may be required: linear solvers, non-linear Newton-Raphson solvers, or implicit/explicit time solvers. Each solver does its own tasks iterating over finite elements. However, in <a class="el" href="namespace_mo_f_e_m.html" title="implementation of Data Operators for Forces and Sources">MoFEM</a> approach, a solver only has to be provided with problem specific set of operators, while the implementation of operators is independent of the type of solver.</p>
<p>Thus, a developer provides <a class="el" href="namespace_mo_f_e_m.html" title="implementation of Data Operators for Forces and Sources">MoFEM</a> with operators which are executed on each element. More precisely, these operators are executed on each sub-entity of each element, since, for example, a triangle element consists of nodes, three edges and triangle face itself. In this lesson, since density field is exclusively defined on nodes, operators are run for nodes only. However, note that this is a special case.</p>
<p>On each finite element, several operators can be run in a sequence. In principle, operators are used to break down a complex problem into simpler tasks. Each operator is implemented such that it iterates over integration points of an element. User-defined operators are derived from a base class <code><a class="el" href="class_user_data_operator.html">UserDataOperator</a></code> and have by default several basic functions which slightly vary for different element shapes. However, they always provide integration points, values of shape functions and their gradients at integrations points and finite element measures (length, area, or volume). Note that writing an operator for your problem, you do not have to make it specific for any particular element shape. In other words, the implementation of user-defined operators is independent of element shape, approximation order, and other fields used on the element, if there are any.</p>
<p>Shape functions on each finite element can be different, depending on approximation spaces you choose to use. Moreover, shape functions will depend on base and approximation order. Similarly, the number of DOFs and DOFs values on element entities depend on the field type. In this lesson, in function <a class="el" href="struct_example.html#ad089fd70d7ad8751df5a798e0914d0b1" title="[Run problem]">Example::setupProblem</a> we have defined density field as follows: </p><div class="fragment"><div class="line"><a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> <a class="code hl_function" href="acoustic_8cpp.html#ad68ed57e17c71816ecfad0ea6746c8d3">simple</a>-&gt;addDomainField(<span class="stringliteral">&quot;rho&quot;</span>, <a class="code hl_enumvalue" href="definitions_8h.html#a5ed4cb303bab8cd0673ae12e5bc73c12a7ec6526640e5add74fe4b322e6343120">H1</a>, <a class="code hl_enumvalue" href="definitions_8h.html#a2ed4ed94b56d2843840bb7c55adcf0c5a54a26843865f4712f50a74fa4f8d025d">AINSWORTH_LEGENDRE_BASE</a>, 1);</div>
<div class="line"><a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> <a class="code hl_function" href="acoustic_8cpp.html#ad68ed57e17c71816ecfad0ea6746c8d3">simple</a>-&gt;setFieldOrder(<span class="stringliteral">&quot;rho&quot;</span>, 1);</div>
<div class="ttc" id="aacoustic_8cpp_html_ad68ed57e17c71816ecfad0ea6746c8d3"><div class="ttname"><a href="acoustic_8cpp.html#ad68ed57e17c71816ecfad0ea6746c8d3">simple</a></div><div class="ttdeci">void simple(double P1[], double P2[], double P3[], double c[], const int N)</div><div class="ttdef"><b>Definition</b> <a href="acoustic_8cpp_source.html#l00069">acoustic.cpp:69</a></div></div>
</div><!-- fragment --><p> where the choice of space <code>H1</code> means that standard conforming elements are used, while the approximation order is set to one. Conforming elements have base functions that are continuous across element edges and faces. Mathematically speaking, function in space <code>H1</code> is piecewise continuous, i.e. it is square-integrable and gradients of the function are also square-integrable. Square-integrable means that when you calculate integral of the square of the function, it gives a finite value, rather than \(\pm\infty\), i.e. the result is a real number. Approximation order 1 means that base functions are linear piecewise continuous. To build approximation base, we are using recipe <code>AINSWORTH_LEGENDRE_BASE</code>, which is described in details in <a class="el" href="citelist.html#CITEREF_ainsworth2001essential">[4]</a>. However, since we use only the first order, shape functions are no different from those presented in <a class="el" href="#basic_l1_figure_4">Figure 4</a>.</p>
<p>Our main task in this lesson is to calculate the mass, the first moment of inertia and the second moment of inertia. In order to do that, on each element we have to first calculate density at integration points, and then integrate it to obtain moments of inertia. That is depicted in <a class="el" href="#basic_l1_figure_8">Figure 8</a> by user data operators (UDOs) shown by four green boxes. <a class="el" href="#basic_l1_figure_8">Figure 8</a> also depicts the flow of data between operators through <code><a class="el" href="struct_example_1_1_common_data.html" title="[Example]">Example::CommonData</a></code> structure.</p>
<p><a class="anchor" id="basic_l1_figure_8"></a></p><div class="image">
<img src="integration_ops.png" alt="" width="800px"/>
<div class="caption">
Figure 8: Operators and common data</div></div>
<p>On each element, first operator <a class="el" href="struct_mo_f_e_m_1_1_op_calculate_scalar_field_values.html" title="Get value at integration points for scalar field.">MoFEM::OpCalculateScalarFieldValues</a> is used to calculate values of density at integration points and store them in <a class="el" href="struct_example_1_1_common_data.html#ab08e51835ec34dd14f90e42ed7c7a17c" title="Storing density at integration points.">Example::CommonData::rhoAtIntegrationPts</a>, which is a vector with a size equal to the number of integration points on the element. Then operators <a class="el" href="struct_example_1_1_op_zero.html" title="[Common data]">Example::OpZero</a>, <a class="el" href="struct_example_1_1_op_first.html">Example::OpFirst</a>, and <a class="el" href="struct_example_1_1_op_second.html" title="[Operator]">Example::OpSecond</a> are used to evaluate moments, assembling their values to <a class="el" href="struct_example_1_1_common_data.html#aad1717441a2871e7eea75d0838652da4" title="Smart pointer which stores PETSc distributed vector.">Example::CommonData::petscVec</a>. Once all elements are iterated, vector <a class="el" href="struct_example_1_1_common_data.html#aad1717441a2871e7eea75d0838652da4" title="Smart pointer which stores PETSc distributed vector.">Example::CommonData::petscVec</a> results are printed at the end of the program.</p>
<p>To compute moments of inertia in <a class="el" href="namespace_mo_f_e_m.html" title="implementation of Data Operators for Forces and Sources">MoFEM</a>, you can use the <a class="el" href="struct_mo_f_e_m_1_1_pipeline_manager.html" title="PipelineManager interface.">MoFEM::PipelineManager</a> interface, which provides pipelines where the discussed above operators can be pushed. More precisely, <a class="el" href="struct_mo_f_e_m_1_1_pipeline_manager.html" title="PipelineManager interface.">MoFEM::PipelineManager</a> has several streams of pipelines to evaluate matrices and vectors for a more general class of problems, and these pipelines can be executed on domain or boundary (skin) elements. In the present tutorial we evaluate a vector by iterating domain elements, see <a class="el" href="#basic_l1_figure_8">Figure 8</a>, red box on the left. Operators are pushed to the pipeline by executing the following code:</p>
<div class="fragment"><div class="line"><span class="comment"></span><a class="code hl_typedef" href="namespace_mo_f_e_m_1_1_exceptions.html#a8fb6351034eac301fc47fdf2748c1b45">MoFEMErrorCode</a> <a class="code hl_function" href="struct_example.html#a06acd214d6979fdb2d0f2e519727e12c">Example::pushOperators</a>() {</div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#a6c0b52978f1abc88bf8a1ba70b7308e3">MoFEMFunctionBegin</a>;</div>
<div class="line">  <a class="code hl_struct" href="struct_mo_f_e_m_1_1_pipeline_manager.html">PipelineManager</a> *pipeline_mng = <a class="code hl_variable" href="struct_example.html#ab79afebe5c16553d0c38e3ec022f868f">mField</a>.<a class="code hl_function" href="struct_mo_f_e_m_1_1_unknown_interface.html#a7ab248ec45fca778800dcd92e5171beb">getInterface</a>&lt;<a class="code hl_struct" href="struct_mo_f_e_m_1_1_pipeline_manager.html">PipelineManager</a>&gt;();</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Push an operator which calculates values of density at integration points</span></div>
<div class="line">  pipeline_mng-&gt;<a class="code hl_function" href="group__mofem__basic__interface.html#gac52cdc08eaadd124e0224d7d9e0a13f5">getOpDomainRhsPipeline</a>().push_back(</div>
<div class="line">      <span class="keyword">new</span> <a class="code hl_struct" href="struct_mo_f_e_m_1_1_op_calculate_scalar_field_values.html">OpCalculateScalarFieldValues</a>(</div>
<div class="line">          <span class="stringliteral">&quot;rho&quot;</span>, <a class="code hl_variable" href="struct_example.html#a3d51ec4713edafe2234ee9f970373015">commonDataPtr</a>-&gt;getRhoAtIntegrationPtsPtr()));</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Push an operator to pipeline to calculate zero moment of inertia (mass)</span></div>
<div class="line">  pipeline_mng-&gt;<a class="code hl_function" href="group__mofem__basic__interface.html#gac52cdc08eaadd124e0224d7d9e0a13f5">getOpDomainRhsPipeline</a>().push_back(<span class="keyword">new</span> OpZero(<a class="code hl_variable" href="struct_example.html#a3d51ec4713edafe2234ee9f970373015">commonDataPtr</a>));</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Push an operator to the pipeline to calculate first moment of inertaia</span></div>
<div class="line">  pipeline_mng-&gt;<a class="code hl_function" href="group__mofem__basic__interface.html#gac52cdc08eaadd124e0224d7d9e0a13f5">getOpDomainRhsPipeline</a>().push_back(<span class="keyword">new</span> OpFirst(<a class="code hl_variable" href="struct_example.html#a3d51ec4713edafe2234ee9f970373015">commonDataPtr</a>));</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Push an operator to the pipeline to calculate second moment of inertaia</span></div>
<div class="line">  pipeline_mng-&gt;<a class="code hl_function" href="group__mofem__basic__interface.html#gac52cdc08eaadd124e0224d7d9e0a13f5">getOpDomainRhsPipeline</a>().push_back(<span class="keyword">new</span> OpSecond(<a class="code hl_variable" href="struct_example.html#a3d51ec4713edafe2234ee9f970373015">commonDataPtr</a>));</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Set integration rule. Integration rule is equal to the polynomial order of</span></div>
<div class="line">  <span class="comment">// the density field plus 2, since under the integral of the second moment of</span></div>
<div class="line">  <span class="comment">// inertia term x*x is present</span></div>
<div class="line">  <span class="keyword">auto</span> <a class="code hl_variable" href="free__surface_8cpp.html#a28f0c075108bbb02a47f54fccb48ea1a">integration_rule</a> = [](int, int, <span class="keywordtype">int</span> p_data) { <span class="keywordflow">return</span> p_data + 2; };</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Add integration rule to the element</span></div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> pipeline_mng-&gt;<a class="code hl_function" href="struct_mo_f_e_m_1_1_pipeline_manager.html#a74a8e58051a774d8259456da159cba23">setDomainRhsIntegrationRule</a>(<a class="code hl_variable" href="free__surface_8cpp.html#a28f0c075108bbb02a47f54fccb48ea1a">integration_rule</a>);</div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#acb0a46d159695a01bf667313b7788b45">MoFEMFunctionReturn</a>(0);</div>
<div class="line">}<span class="comment"></span></div>
</div><!-- fragment --><p>In the snippet above, you can see four operators pushed into the pipeline, as described in <a class="el" href="#basic_l1_figure_8">Figure 8</a>. Operators are pushed to <code>pipeline_mng-&gt;getOpDomainRhsPipeline</code>, which is a pipeline to calculate vectors on domain finite elements. Note that operators are executed on each finite element in the order that they are pushed to the pipeline.</p>
<p>To set integration points at which base functions are evaluated, the user needs to specify integration rule, which is done by the following code: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> <a class="code hl_variable" href="free__surface_8cpp.html#a28f0c075108bbb02a47f54fccb48ea1a">integration_rule</a> = [](int, int, <span class="keywordtype">int</span> p_data) { <span class="keywordflow">return</span> p_data + 2; };</div>
<div class="line"><a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> pipeline_mng-&gt;setDomainRhsIntegrationRule(<a class="code hl_variable" href="free__surface_8cpp.html#a28f0c075108bbb02a47f54fccb48ea1a">integration_rule</a>);</div>
<div class="ttc" id="afree__surface_8cpp_html_a28f0c075108bbb02a47f54fccb48ea1a"><div class="ttname"><a href="free__surface_8cpp.html#a28f0c075108bbb02a47f54fccb48ea1a">integration_rule</a></div><div class="ttdeci">auto integration_rule</div><div class="ttdef"><b>Definition</b> <a href="free__surface_8cpp_source.html#l00185">free_surface.cpp:185</a></div></div>
</div><!-- fragment --><p> Function <code>integration_rule</code> provides this rule, which is defined as the highest polynomial order under the integral for a given problem. Here the integration rule equals to the approximation order of the density field plus 2: for the second moment of inertia the function under integral is a polynomial of order \(p+2\), where p is the order of the polynomial used to approximate density, and 2 emerge from the term \(x^ix^j\). This is the highest polynomial evaluated out of three operators, therefore the integration rule set as above enables to calculate three moments of inertia exactly, and the only errors come from geometry approximation and approximation of the density by a piecewise polynomial.</p>
<p>Since we use a piecewise linear polynomial to approximate density, i.e. \(p=1\), the integration rule set by the code will be 3. Note that setting integration rule to a higher value would increase the number of integration points, and that will not change results. However, setting higher integration rule than is needed makes code slower since functions have to be evaluated in more points, and CPU has to do more operations.</p>
<p>Once the problem is set up and user operators are pushed to an appropriate pipeline, the calculation can be triggered in the function</p>
<div class="fragment"><div class="line"><span class="comment"></span><a class="code hl_typedef" href="namespace_mo_f_e_m_1_1_exceptions.html#a8fb6351034eac301fc47fdf2748c1b45">MoFEMErrorCode</a> <a class="code hl_function" href="struct_example.html#afe986014c24e23ce20b757ac12906ace">Example::integrateElements</a>() {</div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#a6c0b52978f1abc88bf8a1ba70b7308e3">MoFEMFunctionBegin</a>;</div>
<div class="line">  <span class="comment">// Zero global vector</span></div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> VecZeroEntries(<a class="code hl_variable" href="struct_example.html#a3d51ec4713edafe2234ee9f970373015">commonDataPtr</a>-&gt;petscVec);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Integrate elements by executing operators in the pipeline</span></div>
<div class="line">  <a class="code hl_struct" href="struct_mo_f_e_m_1_1_pipeline_manager.html">PipelineManager</a> *pipeline_mng = <a class="code hl_variable" href="struct_example.html#ab79afebe5c16553d0c38e3ec022f868f">mField</a>.<a class="code hl_function" href="struct_mo_f_e_m_1_1_unknown_interface.html#a7ab248ec45fca778800dcd92e5171beb">getInterface</a>&lt;<a class="code hl_struct" href="struct_mo_f_e_m_1_1_pipeline_manager.html">PipelineManager</a>&gt;();</div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> pipeline_mng-&gt;<a class="code hl_function" href="group__mofem__basic__interface.html#ga41f2fac8fb98a931dc7fc9e2239b2909">loopFiniteElements</a>();</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Assemble MPI vector</span></div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> VecAssemblyBegin(<a class="code hl_variable" href="struct_example.html#a3d51ec4713edafe2234ee9f970373015">commonDataPtr</a>-&gt;petscVec);</div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> VecAssemblyEnd(<a class="code hl_variable" href="struct_example.html#a3d51ec4713edafe2234ee9f970373015">commonDataPtr</a>-&gt;petscVec);</div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#acb0a46d159695a01bf667313b7788b45">MoFEMFunctionReturn</a>(0);</div>
<div class="line">}<span class="comment"></span></div>
</div><!-- fragment --><p>in particular, by <a class="el" href="group__mofem__basic__interface.html#ga41f2fac8fb98a931dc7fc9e2239b2909" title="Iterate finite elements.">MoFEM::PipelineManager::loopFiniteElements</a>. This is where all computations are happening, while the rest of the code is declaration and definition of the problem. The snippet above shows as well that vector of moments, i.e. <a class="el" href="struct_example_1_1_common_data.html#aad1717441a2871e7eea75d0838652da4" title="Smart pointer which stores PETSc distributed vector.">Example::CommonData::petscVec</a>, is zeroed before the loop over all elements is performed, and finally PETSCc functions are called to appropriately finalise assembly of an MPI Vector.</p>
<p>Operator <a class="el" href="struct_example_1_1_op_second.html" title="[Operator]">Example::OpSecond</a> is defined as follows:</p>
<div class="fragment"><div class="line"><span class="comment"></span><span class="keyword">struct </span><a class="code hl_struct" href="struct_example_1_1_op_second.html">Example::OpSecond</a> : <span class="keyword">public</span> <a class="code hl_struct" href="struct_mo_f_e_m_1_1_volume_element_forces_and_sources_core_1_1_user_data_operator.html">OpElement</a> {</div>
<div class="line">  <a class="code hl_function" href="struct_example_1_1_op_second.html#a7266132f9c78449217a6aea2966deec7">OpSecond</a>(boost::shared_ptr&lt;CommonData&gt; &amp;common_data_ptr)</div>
<div class="line">      : <a class="code hl_struct" href="struct_mo_f_e_m_1_1_volume_element_forces_and_sources_core_1_1_user_data_operator.html">OpElement</a>(<span class="stringliteral">&quot;rho&quot;</span>, <a class="code hl_enumvalue" href="struct_mo_f_e_m_1_1_forces_and_sources_core_1_1_user_data_operator.html#ac99de5ec6fa9bad3ccc5c5d60bc48e40a2d8d202342fada158e521ef00be491e1">OPROW</a>), <a class="code hl_variable" href="struct_example_1_1_op_second.html#a6d44f7f767d421f2059f67ef063750ea">commonDataPtr</a>(common_data_ptr) {</div>
<div class="line">    std::fill(&amp;<a class="code hl_variable" href="struct_mo_f_e_m_1_1_data_operator.html#a0148ef31d9d6961f3e0db8b833dc496d">doEntities</a>[MBEDGE], &amp;<a class="code hl_variable" href="struct_mo_f_e_m_1_1_data_operator.html#a0148ef31d9d6961f3e0db8b833dc496d">doEntities</a>[MBMAXTYPE], <span class="keyword">false</span>);</div>
<div class="line">  }</div>
<div class="line">  <a class="code hl_typedef" href="namespace_mo_f_e_m_1_1_exceptions.html#a8fb6351034eac301fc47fdf2748c1b45">MoFEMErrorCode</a> <a class="code hl_function" href="struct_example_1_1_op_second.html#a1a5b73c0275e60a3c9dd562841d737e2">doWork</a>(<span class="keywordtype">int</span> side, EntityType type, <a class="code hl_struct" href="struct_mo_f_e_m_1_1_entities_field_data_1_1_ent_data.html">EntData</a> &amp;data);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  boost::shared_ptr&lt;CommonData&gt; <a class="code hl_variable" href="struct_example_1_1_op_second.html#a6d44f7f767d421f2059f67ef063750ea">commonDataPtr</a>;</div>
<div class="line">};<span class="comment"></span></div>
</div><!-- fragment --><p>Operators are derived classes, where essential part is an overloaded function <a class="el" href="struct_example_1_1_op_second.html#a1a5b73c0275e60a3c9dd562841d737e2" title="[FirstOp]">Example::OpSecond::doWork</a>, which is called by <a class="el" href="group__mofem__basic__interface.html#ga41f2fac8fb98a931dc7fc9e2239b2909" title="Iterate finite elements.">MoFEM::PipelineManager::loopFiniteElements</a> on each finite element:</p>
<div class="fragment"><div class="line"><span class="comment"></span><a class="code hl_typedef" href="namespace_mo_f_e_m_1_1_exceptions.html#a8fb6351034eac301fc47fdf2748c1b45">MoFEMErrorCode</a> <a class="code hl_function" href="struct_example_1_1_op_second.html#a1a5b73c0275e60a3c9dd562841d737e2">Example::OpSecond::doWork</a>(<span class="keywordtype">int</span> side, EntityType type,</div>
<div class="line">                                         <a class="code hl_struct" href="struct_mo_f_e_m_1_1_entities_field_data_1_1_ent_data.html">EntData</a> &amp;data) {</div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#a6c0b52978f1abc88bf8a1ba70b7308e3">MoFEMFunctionBegin</a>;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_integration_pts = getGaussPts().size2();</div>
<div class="line">  <span class="keyword">auto</span> t_w = getFTensor0IntegrationWeight();</div>
<div class="line">  <span class="keyword">auto</span> t_rho = <a class="code hl_function" href="namespace_mo_f_e_m.html#aa464ad90a188180427136b22e078ec7d">getFTensor0FromVec</a>(<a class="code hl_variable" href="struct_example.html#a3d51ec4713edafe2234ee9f970373015">commonDataPtr</a>-&gt;rhoAtIntegrationPts);</div>
<div class="line">  <span class="keyword">auto</span> t_x = getFTensor1CoordsAtGaussPts();</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> volume = getMeasure();</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Create storage for a symmetric tensor</span></div>
<div class="line">  std::array&lt;double, 6&gt; element_local_value;</div>
<div class="line">  std::fill(element_local_value.begin(), element_local_value.end(), 0.0);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Create symmetric tensor using pointers to the storage</span></div>
<div class="line">  <a class="code hl_class" href="class_f_tensor_1_1_tensor2__symmetric.html">FTensor::Tensor2_symmetric&lt;FTensor::PackPtr&lt;double *, 0&gt;</a>, 3&gt; t_I(</div>
<div class="line">      &amp;element_local_value[0], &amp;element_local_value[1], &amp;element_local_value[2],</div>
<div class="line">      &amp;element_local_value[3], &amp;element_local_value[4],</div>
<div class="line">      &amp;element_local_value[5]);</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_class" href="class_f_tensor_1_1_index.html">FTensor::Index</a>&lt;<span class="charliteral">&#39;i&#39;</span>, 3&gt; <a class="code hl_variable" href="shallow__wave_8cpp.html#aa3c03159c72fab888f2581d95640c6e3">i</a>;</div>
<div class="line">  <a class="code hl_class" href="class_f_tensor_1_1_index.html">FTensor::Index</a>&lt;<span class="charliteral">&#39;j&#39;</span>, 3&gt; <a class="code hl_variable" href="shallow__wave_8cpp.html#a8191f28ba278df9c5d32a75cadb2bbd5">j</a>;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Integrate</span></div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> gg = 0; gg != nb_integration_pts; ++gg) {</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Symbol &quot;^&quot; indicates outer product which yields a symmetric tensor</span></div>
<div class="line">    t_I(<a class="code hl_variable" href="shallow__wave_8cpp.html#aa3c03159c72fab888f2581d95640c6e3">i</a>, <a class="code hl_variable" href="shallow__wave_8cpp.html#a8191f28ba278df9c5d32a75cadb2bbd5">j</a>) += (t_w * t_rho * volume) * (t_x(<a class="code hl_variable" href="shallow__wave_8cpp.html#aa3c03159c72fab888f2581d95640c6e3">i</a>) ^ t_x(<a class="code hl_variable" href="shallow__wave_8cpp.html#a8191f28ba278df9c5d32a75cadb2bbd5">j</a>));</div>
<div class="line"> </div>
<div class="line">    ++t_w;   <span class="comment">// move weight pointer to the next integration point</span></div>
<div class="line">    ++t_rho; <span class="comment">// move density pointer</span></div>
<div class="line">    ++t_x;   <span class="comment">// move coordinate pointer</span></div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Set array of indices</span></div>
<div class="line">  <span class="keyword">constexpr</span> std::array&lt;int, 6&gt; indices = {</div>
<div class="line">      <a class="code hl_enumvalue" href="struct_example_1_1_common_data.html#aa2c35df835c021bdbc4f0c64d37bf66fa9ee8e21dd1ab77620fc756d35df31300">CommonData::SECOND_XX</a>, <a class="code hl_enumvalue" href="struct_example_1_1_common_data.html#aa2c35df835c021bdbc4f0c64d37bf66faf728e56b28141d1ec533528b26e129f0">CommonData::SECOND_XY</a>, <a class="code hl_enumvalue" href="struct_example_1_1_common_data.html#aa2c35df835c021bdbc4f0c64d37bf66fa41253069e409e5079d5642a8f236f10a">CommonData::SECOND_XZ</a>,</div>
<div class="line">      <a class="code hl_enumvalue" href="struct_example_1_1_common_data.html#aa2c35df835c021bdbc4f0c64d37bf66fab7792033026ec3146c04e9e160fa4e2c">CommonData::SECOND_YY</a>, <a class="code hl_enumvalue" href="struct_example_1_1_common_data.html#aa2c35df835c021bdbc4f0c64d37bf66fa5e761046bc8cd47c8c14ebe0068ea822">CommonData::SECOND_YZ</a>, <a class="code hl_enumvalue" href="struct_example_1_1_common_data.html#aa2c35df835c021bdbc4f0c64d37bf66fa5464cebcdf703892cfc92a8deb9a3cf4">CommonData::SECOND_ZZ</a>};</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Assemble second moment of inertia</span></div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> <a class="code hl_function" href="namespace_mo_f_e_m.html#aef01d33cbe1d8ed916ce789bd25c4495">VecSetValues</a>(<a class="code hl_variable" href="struct_example.html#a3d51ec4713edafe2234ee9f970373015">commonDataPtr</a>-&gt;petscVec, 6, indices.data(),</div>
<div class="line">                      &amp;element_local_value[0], ADD_VALUES);</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#acb0a46d159695a01bf667313b7788b45">MoFEMFunctionReturn</a>(0);</div>
<div class="line">}<span class="comment"></span></div>
</div><!-- fragment --><p>We will discuss this operator since it is the most complex one among all three operators. We will dissect this code to understand it better. We start by getting a number of integration points, which depends on the previously set integration rule. In the following lines, three tensors are declared: two rank zero (scalar) tensors are set to integration weights and density values, respectively, and a tensor of rank one (vector) is set to coordinates of integration points. Note that we use here <a class="el" href="namespace_f_tensor.html" title="Tensors class implemented by Walter Landry.">FTensor</a> library, providing special tools to simplify data storage and operations with tensors, you can find more details <a href="http://mofem.eng.gla.ac.uk/mofem/html/group__ftensor.html">here</a>. In particular, three tensors declared above initially point to the respective values at the first integration point, however, subsequently they will iterate through all the integration points of the element using the following code: </p><div class="fragment"><div class="line">++t_w;</div>
<div class="line">++t_rho;</div>
<div class="line">++t_x;</div>
</div><!-- fragment --><p>Next, we create an array to store local values of the second moment of inertia. The second moment of inertia is a symmetric tensor of rank two, which in three dimensions has six independent components. The array is continuous in the memory, it takes the shape of the rank two tensor when the following code is run: </p><div class="fragment"><div class="line"><a class="code hl_class" href="class_f_tensor_1_1_tensor2__symmetric.html">FTensor::Tensor2_symmetric&lt;FTensor::PackPtr&lt;double *, 0&gt;</a>, 3&gt; t_I(</div>
<div class="line">  &amp;element_local_value[0], &amp;element_local_value[1], &amp;element_local_value[2],</div>
<div class="line">  &amp;element_local_value[3], &amp;element_local_value[4],</div>
<div class="line">  &amp;element_local_value[5]);</div>
<div class="ttc" id="aclass_f_tensor_1_1_tensor2__symmetric_html"><div class="ttname"><a href="class_f_tensor_1_1_tensor2__symmetric.html">FTensor::Tensor2_symmetric</a></div><div class="ttdef"><b>Definition</b> <a href="_tensor2__symmetric__value_8hpp_source.html#l00013">Tensor2_symmetric_value.hpp:14</a></div></div>
</div><!-- fragment --><p>With all above at hand finally the loop over all integration points is performed, and the components of the second order tensor are computed. Note that at the following line: </p><div class="fragment"><div class="line">t_I(<a class="code hl_variable" href="hcurl__divergence__operator__2d_8cpp.html#a4c0436605284b64f6b0b5482594d86bc">i</a>, <a class="code hl_variable" href="matrix__function_8cpp.html#a8191f28ba278df9c5d32a75cadb2bbd5">j</a>) += (t_w * t_rho * volume) * (t_x(<a class="code hl_variable" href="hcurl__divergence__operator__2d_8cpp.html#a4c0436605284b64f6b0b5482594d86bc">i</a>) ^ t_x(<a class="code hl_variable" href="matrix__function_8cpp.html#a8191f28ba278df9c5d32a75cadb2bbd5">j</a>));</div>
<div class="ttc" id="ahcurl__divergence__operator__2d_8cpp_html_a4c0436605284b64f6b0b5482594d86bc"><div class="ttname"><a href="hcurl__divergence__operator__2d_8cpp.html#a4c0436605284b64f6b0b5482594d86bc">i</a></div><div class="ttdeci">FTensor::Index&lt; 'i', SPACE_DIM &gt; i</div><div class="ttdef"><b>Definition</b> <a href="hcurl__divergence__operator__2d_8cpp_source.html#l00027">hcurl_divergence_operator_2d.cpp:27</a></div></div>
<div class="ttc" id="amatrix__function_8cpp_html_a8191f28ba278df9c5d32a75cadb2bbd5"><div class="ttname"><a href="matrix__function_8cpp.html#a8191f28ba278df9c5d32a75cadb2bbd5">j</a></div><div class="ttdeci">FTensor::Index&lt; 'j', 3 &gt; j</div><div class="ttdef"><b>Definition</b> <a href="matrix__function_8cpp_source.html#l00019">matrix_function.cpp:19</a></div></div>
</div><!-- fragment --><p> iteration over all 6 components of the symmetric second order tensor is performed using the special <a class="el" href="namespace_f_tensor.html" title="Tensors class implemented by Walter Landry.">FTensor</a> indices <code>i</code> and <code>j</code> defined before integration points loop as: </p><div class="fragment"><div class="line"><a class="code hl_class" href="class_f_tensor_1_1_index.html">FTensor::Index</a>&lt;<span class="charliteral">&#39;i&#39;</span>, 3&gt; <a class="code hl_variable" href="hcurl__divergence__operator__2d_8cpp.html#a4c0436605284b64f6b0b5482594d86bc">i</a>;</div>
<div class="line"><a class="code hl_class" href="class_f_tensor_1_1_index.html">FTensor::Index</a>&lt;<span class="charliteral">&#39;j&#39;</span>, 3&gt; <a class="code hl_variable" href="matrix__function_8cpp.html#a8191f28ba278df9c5d32a75cadb2bbd5">j</a>;</div>
<div class="ttc" id="aclass_f_tensor_1_1_index_html"><div class="ttname"><a href="class_f_tensor_1_1_index.html">FTensor::Index</a></div><div class="ttdef"><b>Definition</b> <a href="_index_8hpp_source.html#l00023">Index.hpp:24</a></div></div>
</div><!-- fragment --><p>After the loop over integration points is finished, local element vector <code>element_local_value</code> is assembled into a global vector <a class="el" href="struct_example_1_1_common_data.html#aad1717441a2871e7eea75d0838652da4" title="Smart pointer which stores PETSc distributed vector.">Example::CommonData::petscVec</a>. Note that vector <a class="el" href="struct_example_1_1_common_data.html#aad1717441a2871e7eea75d0838652da4" title="Smart pointer which stores PETSc distributed vector.">Example::CommonData::petscVec</a> stores all moments of inertia: first index stores the zero moment, i.e. mass, next three indices store the first moment, and last six indices store the second moment. For clarity, indices are enumerated by <a class="el" href="struct_example_1_1_common_data.html#aa2c35df835c021bdbc4f0c64d37bf66f" title="Vector to indicate indices for storing zero, first and second moments of inertia.">Example::CommonData::VecElements</a>.</p>
<dl class="section note"><dt>Note</dt><dd>At this point, you might feel that you are overwhelmed with information. This is natural, you can play with the code, make changes, or debug it. You do not have too understand all of it at once, and starting with the part you can more easily understand and control could be helpful. Each of current <a class="el" href="namespace_mo_f_e_m.html" title="implementation of Data Operators for Forces and Sources">MoFEM</a> contributors and developers was at the same stage where you are right now.</dd></dl>
<h2><a class="anchor" id="integration_checking"></a>
Checking code validity</h2>
<p>The whole <a class="el" href="namespace_mo_f_e_m.html" title="implementation of Data Operators for Forces and Sources">MoFEM</a> code is tested every time changes are pushed into the repository. The user can also trigger the test locally using the following command: </p><div class="fragment"><div class="line">ctest -VV</div>
</div><!-- fragment --><p>In particular, the code in this tutorial is tested by executing </p><div class="fragment"><div class="line">./integration -file_name <a class="code hl_function" href="nonlinear__poisson__2d_8cpp.html#af4080b4104d18fe9035d130afdcc2a9c">cube</a>.h5m -test</div>
</div><!-- fragment --><p> and code is validated in function <a class="el" href="struct_example.html#a6eda930af795f95e64047fbc35d80826" title="[Postprocess results]">Example::checkResults</a>.</p>
<p>In function <a class="el" href="struct_example.html#a6eda930af795f95e64047fbc35d80826" title="[Postprocess results]">Example::checkResults</a> test is run for a well-known solution for mesh in <code>cube.h5m</code>. Test like this verifies if mass (or volume in case of unit density), first moment and the second moment are calculated correctly. Function testing the code is as follows </p><div class="fragment"><div class="line"><span class="comment"></span><a class="code hl_typedef" href="namespace_mo_f_e_m_1_1_exceptions.html#a8fb6351034eac301fc47fdf2748c1b45">MoFEMErrorCode</a> <a class="code hl_function" href="struct_example.html#a6eda930af795f95e64047fbc35d80826">Example::checkResults</a>() {</div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#a6c0b52978f1abc88bf8a1ba70b7308e3">MoFEMFunctionBegin</a>;</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> *array;</div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> VecGetArrayRead(<a class="code hl_variable" href="struct_example.html#a3d51ec4713edafe2234ee9f970373015">commonDataPtr</a>-&gt;petscVec, &amp;array);</div>
<div class="line"> </div>
<div class="line">  PetscBool test = PETSC_FALSE;</div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> <a class="code hl_function" href="namespace_mo_f_e_m.html#a55db6ee7b037f883685d61baabd7ace4">PetscOptionsGetBool</a>(PETSC_NULL, <span class="stringliteral">&quot;&quot;</span>, <span class="stringliteral">&quot;-test&quot;</span>, &amp;test, PETSC_NULL);</div>
<div class="line">  <span class="keywordflow">if</span> (<a class="code hl_variable" href="struct_example.html#ab79afebe5c16553d0c38e3ec022f868f">mField</a>.<a class="code hl_function" href="struct_mo_f_e_m_1_1_core_interface.html#af2224ce77b33637b5cfad66a275a2ffb">get_comm_rank</a>() == 0 &amp;&amp; test) {</div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keywordtype">double</span> <a class="code hl_variable" href="check__base__functions__derivatives__on__tet_8cpp.html#a3d8c24629d725b9ef8c238cf27c9b158">eps</a> = 1e-8;</div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keywordtype">double</span> expected_volume = 1.;</div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keywordtype">double</span> expected_first_moment = 0.;</div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keywordtype">double</span> expected_second_moment = 1. / 12.;</div>
<div class="line">    <span class="keywordflow">if</span> (std::abs(array[<a class="code hl_enumvalue" href="struct_example_1_1_common_data.html#aa2c35df835c021bdbc4f0c64d37bf66fa1c9cf51d3c94d1e9f9811cfd9ffe0f70">CommonData::ZERO</a>] - expected_volume) &gt; <a class="code hl_variable" href="check__base__functions__derivatives__on__tet_8cpp.html#a3d8c24629d725b9ef8c238cf27c9b158">eps</a>)</div>
<div class="line">      SETERRQ2(PETSC_COMM_SELF, <a class="code hl_enumvalue" href="definitions_8h.html#a980bf270a5c3f2f984262f7e74786a2eab22230d41f866f427f7fa9496875bcc9">MOFEM_ATOM_TEST_INVALID</a>,</div>
<div class="line">               <span class="stringliteral">&quot;Wrong area %6.4e != %6.4e&quot;</span>, expected_volume,</div>
<div class="line">               array[<a class="code hl_enumvalue" href="struct_example_1_1_common_data.html#aa2c35df835c021bdbc4f0c64d37bf66fa1c9cf51d3c94d1e9f9811cfd9ffe0f70">CommonData::ZERO</a>]);</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> <a class="code hl_variable" href="shallow__wave_8cpp.html#aa3c03159c72fab888f2581d95640c6e3">i</a> :</div>
<div class="line">         {<a class="code hl_enumvalue" href="struct_example_1_1_common_data.html#aa2c35df835c021bdbc4f0c64d37bf66fa35a8e93a704a8646c97c4bce760aac9e">CommonData::FIRST_X</a>, <a class="code hl_enumvalue" href="struct_example_1_1_common_data.html#aa2c35df835c021bdbc4f0c64d37bf66fa026863406fd2004ee06ab936db4af78e">CommonData::FIRST_Y</a>, <a class="code hl_enumvalue" href="struct_example_1_1_common_data.html#aa2c35df835c021bdbc4f0c64d37bf66fae2a1b91f617aa89858d1632162669131">CommonData::FIRST_Z</a>}) {</div>
<div class="line">      <span class="keywordflow">if</span> (std::abs(array[<a class="code hl_variable" href="shallow__wave_8cpp.html#aa3c03159c72fab888f2581d95640c6e3">i</a>] - expected_first_moment) &gt; <a class="code hl_variable" href="check__base__functions__derivatives__on__tet_8cpp.html#a3d8c24629d725b9ef8c238cf27c9b158">eps</a>)</div>
<div class="line">        SETERRQ2(PETSC_COMM_SELF, <a class="code hl_enumvalue" href="definitions_8h.html#a980bf270a5c3f2f984262f7e74786a2eab22230d41f866f427f7fa9496875bcc9">MOFEM_ATOM_TEST_INVALID</a>,</div>
<div class="line">                 <span class="stringliteral">&quot;Wrong first moment %6.4e != %6.4e&quot;</span>, expected_first_moment,</div>
<div class="line">                 array[<a class="code hl_variable" href="shallow__wave_8cpp.html#aa3c03159c72fab888f2581d95640c6e3">i</a>]);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> <a class="code hl_variable" href="shallow__wave_8cpp.html#aa3c03159c72fab888f2581d95640c6e3">i</a> : {<a class="code hl_enumvalue" href="struct_example_1_1_common_data.html#aa2c35df835c021bdbc4f0c64d37bf66fa9ee8e21dd1ab77620fc756d35df31300">CommonData::SECOND_XX</a>, <a class="code hl_enumvalue" href="struct_example_1_1_common_data.html#aa2c35df835c021bdbc4f0c64d37bf66fab7792033026ec3146c04e9e160fa4e2c">CommonData::SECOND_YY</a>,</div>
<div class="line">                   <a class="code hl_enumvalue" href="struct_example_1_1_common_data.html#aa2c35df835c021bdbc4f0c64d37bf66fa5464cebcdf703892cfc92a8deb9a3cf4">CommonData::SECOND_ZZ</a>}) {</div>
<div class="line">      <span class="keywordflow">if</span> (std::abs(array[<a class="code hl_variable" href="shallow__wave_8cpp.html#aa3c03159c72fab888f2581d95640c6e3">i</a>] - expected_second_moment) &gt; <a class="code hl_variable" href="check__base__functions__derivatives__on__tet_8cpp.html#a3d8c24629d725b9ef8c238cf27c9b158">eps</a>)</div>
<div class="line">        SETERRQ2(PETSC_COMM_SELF, <a class="code hl_enumvalue" href="definitions_8h.html#a980bf270a5c3f2f984262f7e74786a2eab22230d41f866f427f7fa9496875bcc9">MOFEM_ATOM_TEST_INVALID</a>,</div>
<div class="line">                 <span class="stringliteral">&quot;Wrong second moment %6.4e != %6.4e&quot;</span>, expected_second_moment,</div>
<div class="line">                 array[<a class="code hl_variable" href="shallow__wave_8cpp.html#aa3c03159c72fab888f2581d95640c6e3">i</a>]);</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> VecRestoreArrayRead(<a class="code hl_variable" href="struct_example.html#a3d51ec4713edafe2234ee9f970373015">commonDataPtr</a>-&gt;petscVec, &amp;array);</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#acb0a46d159695a01bf667313b7788b45">MoFEMFunctionReturn</a>(0);</div>
<div class="line">}<span class="comment"></span></div>
</div><!-- fragment --><p>You can see that at line </p><div class="fragment"><div class="line"><a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> PetscOptionsGetBool(PETSC_NULL, <span class="stringliteral">&quot;&quot;</span>, <span class="stringliteral">&quot;-test&quot;</span>, &amp;test, PETSC_NULL);</div>
</div><!-- fragment --><p> we check if the test option is set in the command line. Code in brackets verifies if prescribed values are equal to calculated values. For example </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> <a class="code hl_variable" href="hcurl__divergence__operator__2d_8cpp.html#a4c0436605284b64f6b0b5482594d86bc">i</a> : {CommonData::SECOND_XX, CommonData::SECOND_YY,</div>
<div class="line">                   CommonData::SECOND_ZZ}) {</div>
<div class="line">      <span class="keywordflow">if</span> (std::abs(array[<a class="code hl_variable" href="hcurl__divergence__operator__2d_8cpp.html#a4c0436605284b64f6b0b5482594d86bc">i</a>] - expected_second_moment) &gt; <a class="code hl_variable" href="check__base__functions__derivatives__on__tet_8cpp.html#a3d8c24629d725b9ef8c238cf27c9b158">eps</a>)</div>
<div class="line">        SETERRQ2(PETSC_COMM_SELF, <a class="code hl_enumvalue" href="definitions_8h.html#a980bf270a5c3f2f984262f7e74786a2eab22230d41f866f427f7fa9496875bcc9">MOFEM_ATOM_TEST_INVALID</a>,</div>
<div class="line">                 <span class="stringliteral">&quot;Wrong second moment %6.4e != %6.4e&quot;</span>, expected_second_moment,</div>
<div class="line">                 array[<a class="code hl_variable" href="hcurl__divergence__operator__2d_8cpp.html#a4c0436605284b64f6b0b5482594d86bc">i</a>]);</div>
<div class="line">    }</div>
<div class="ttc" id="acheck__base__functions__derivatives__on__tet_8cpp_html_a3d8c24629d725b9ef8c238cf27c9b158"><div class="ttname"><a href="check__base__functions__derivatives__on__tet_8cpp.html#a3d8c24629d725b9ef8c238cf27c9b158">eps</a></div><div class="ttdeci">static const double eps</div><div class="ttdef"><b>Definition</b> <a href="check__base__functions__derivatives__on__tet_8cpp_source.html#l00011">check_base_functions_derivatives_on_tet.cpp:11</a></div></div>
<div class="ttc" id="adefinitions_8h_html_a980bf270a5c3f2f984262f7e74786a2eab22230d41f866f427f7fa9496875bcc9"><div class="ttname"><a href="definitions_8h.html#a980bf270a5c3f2f984262f7e74786a2eab22230d41f866f427f7fa9496875bcc9">MOFEM_ATOM_TEST_INVALID</a></div><div class="ttdeci">@ MOFEM_ATOM_TEST_INVALID</div><div class="ttdef"><b>Definition</b> <a href="definitions_8h_source.html#l00040">definitions.h:40</a></div></div>
</div><!-- fragment --><p> iterates over diagonal values of the second order tensor, and if the calculated value is not equal to expected value,program throws an error using PTESc function <a href="https://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/Sys/SETERRQ2.html">SETERRQ2</a>. The test is written for a cube volume, of size one by one and coordinate system in the centre of the cube. Zero moment, i.e. volume in case of unit density, should be 1. First moments should be zero since the cube centre is placed at the origin. Diagonal values of the second-order moment should be \(1/12\), and off-diagonal terms of second-order should be zero since the sides of the cube are aligned with the axis of the coordinate system.</p>
<p>Writing a test for each part of the code is essential. <a class="el" href="namespace_mo_f_e_m.html" title="implementation of Data Operators for Forces and Sources">MoFEM</a> is a complex system with multiple contributors, and most of them focus their attention on one part of the code. Running tests like this one, contributors know that they have not broken anything. That makes code development sustainable. Also, writing tests makes code development faster and simpler, since once you have written the code, it will need refactoring and improvement. The test will reassure you that optimisations and changes do not break a working code. Moreover, once your commits are submitted to the repository, <a class="el" href="namespace_mo_f_e_m.html" title="implementation of Data Operators for Forces and Sources">MoFEM</a> Jenkins server will run the test independently, validating if your code is running on other systems and computers. Results of that test are available here <a href="http://cdash.eng.gla.ac.uk/cdash/index.php">http://cdash.eng.gla.ac.uk/cdash/index.php</a>.</p>
<h1><a class="anchor" id="Debugging"></a>
Debugging</h1>
<p>Debugging is a method used to find errors or to understand what code does. A debugger is a program for debugging, which enables the user to execute code line by line and observe, or break (stop) program at desired lines of the source code. When you work in Linux, you can use GDB to debug code. If you work on macOS, you can instead use LLDB debugger.</p>
<p>Code has to be compiled with debugging flags, and when you installed <a class="el" href="namespace_mo_f_e_m.html" title="implementation of Data Operators for Forces and Sources">MoFEM</a> using <a href="http://mofem.eng.gla.ac.uk/mofem/html/install_spack.html#installation_scripts">script for developer</a>, code with debugging flags is available in <em>$HOME/mofem_install/um/build_debug/tutorials/fun-1</em>.</p>
<p>VS Code has built-in functionality to debug code, both on Linux and macOS, for details on how to use it, see <a href="https://code.visualstudio.com/docs/editor/debugging">https://code.visualstudio.com/docs/editor/debugging</a>. Here is an example of the launch (in VS Code) configuration for LLDB and example from this lesson </p><div class="fragment"><div class="line">{</div>
<div class="line">  <span class="stringliteral">&quot;type&quot;</span>: <span class="stringliteral">&quot;lldb&quot;</span>,</div>
<div class="line">  <span class="stringliteral">&quot;request&quot;</span>: <span class="stringliteral">&quot;launch&quot;</span>,</div>
<div class="line">  <span class="stringliteral">&quot;name&quot;</span>: <span class="stringliteral">&quot;integration&quot;</span>,</div>
<div class="line">  <span class="stringliteral">&quot;program&quot;</span>: <span class="stringliteral">&quot;integration&quot;</span>,</div>
<div class="line">  <span class="stringliteral">&quot;args&quot;</span>: [</div>
<div class="line">    <span class="stringliteral">&quot;-file_name&quot;</span>, <span class="stringliteral">&quot;cube.h5m&quot;</span></div>
<div class="line">  ],</div>
<div class="line">  <span class="stringliteral">&quot;cwd&quot;</span>: <span class="stringliteral">&quot;$HOME/mofem_install/um/build_debug/tutorials/fun-1&quot;</span>  </div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="basci_integration_code"></a>
Code</h1>
<p>The full source code is available here <a class="el" href="integration_8cpp.html">integration.cpp</a> . </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr cla ss="footer" />
<style>
  img[src="UoGLogo.png"] {
    height: 20px;
    padding-top: 0px;
    padding-right: 1px;
    padding-bottom: 3px;
    padding-left: 6px;
  }
</style>
<address class="footer">
  <small>
    Generated by
    <a href="http://www.doxygen.org/index.html"> Doxygen </a> 1.12.0
    and hosted at
    <a href="http://www.gla.ac.uk/schools/engineering/">
      <img class="footer" src="UoGLogo.png" alt="University of Glasgow" />
    </a>
  </small>
</address>
</body>
</html>
