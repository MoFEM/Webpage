<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
  <meta http-equiv="X-UA-Compatible" content="IE=9"/>
  <meta name="generator" content="Doxygen 1.8.17"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>MoFEM: Periodic boundary conditions with Nitsche&#39;s method</title>
  <link href="tabs.css" rel="stylesheet" type="text/css"/>
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
  <script type="text/javascript " src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML "></script>
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        extensions: ["AMSmath.js"],
        TeX: { equationNumbers: { autoNumber: ["all"],
                                  useLabelIds: true
        } 
        }
    });
    </script>
  <link href="customdoxygen.css" rel="stylesheet" type="text/css" />
  <link href="extra_style.css" rel="stylesheet" type="text/css"/>
  <link rel="apple-touch-icon" sizes="57x57" href="apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192"  href="android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.png">
  <link rel="shortcut icon" type="image/png" href="favicon-32x32.png"/>
  <link rel="Bookmark" type="image/png" href="favicon-32x32.png"/>
  <link rel="manifest" href="manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div style="background-color:#011A40" id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 30px;">
  <td id="projectlogo"><img alt="Logo" src="MoFEMLogo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <td style="padding-left: 0.5em;" bgcolor="#011A40"
   <div id="projectbrief"><font color="#FFFFFF">v0.14.0</font></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!--Google analytics tags-->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-65236130-1', 'auto');
  ga('send', 'pageview');
</script>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-2J9RE2P3H5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-2J9RE2P3H5');
</script><!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="runningprograms.html">Programs</a></li>  </ul>
</div>
</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Periodic boundary conditions with Nitsche's method </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#Introduction">Introduction</a></li>
<li class="level1"><a href="#nitsche_method_periodic_formulation">Formulation of Nitsche&#39;s method</a><ul><li class="level2"><a href="#general">A general Nitsche-based finite element method</a></li>
<li class="level2"><a href="#consistency">Consistency of Nitsche&#39;s method</a></li>
<li class="level2"><a href="#nitsche_posedness">Well-posedness</a></li>
</ul>
</li>
<li class="level1"><a href="#periodic_bc">Periodic boundary conditions</a></li>
<li class="level1"><a href="#Implementation">Implementation</a></li>
<li class="level1"><a href="#nitsche_method_periodic_example">Numerical example</a></li>
<li class="level1"><a href="#nitsche_conclusions">Conclusions</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="Introduction"></a>
Introduction</h1>
<p>In this document we will study a material example which contains periodically distributed voids. In the case of a material with a periodic structure, one can choose the smallest possible unit cell such that in repeating this cell in the array, the material microstructure is reproduced without additional gaps. Note, it is not unique how the unit cell is constructed, i.e. the void can be placed perfectly in the centre or frame of the unit cell or it can be arbitrarily shifted leaving the void off centre. In the figure below the red frames represent some subjectively selected unit cells. If periodic boundary conditions are applied to these unit cell, homogenised overall stress and a material tangent matrix are invariant to the selection of the unit cell frame and results are objective.</p>
<p><a class="el" href="faqs.html#mofem_citation">How to cite us?</a></p>
<p> 
<a href="https://doi.org/10.5281/zenodo.439368"><img src="https://zenodo.org/badge/DOI/10.5281/zenodo.439368.svg" alt="DOI"></a>
</p>
<div class="image">
<img src="nitshce_periodic_microstrutue.png" alt=""/>
<div class="caption">
Unit Cell and periodic micro-structure</div></div>
<p>For periodic boundary conditions, displacements on the opposite sides of the representative volume element (RVE) are constrained as follows </p><p class="formulaDsp">
\[ \mathbf{u}_+-\mathbf{u}_-={\boldsymbol \varepsilon}^M(\mathbf{x}_+-\mathbf{x}_-) \]
</p>
<p> where \(+\) and \(-\), denote opposite sides of the RVE, \(\mathbf{u}\) is the displacement vector and \({\boldsymbol \varepsilon}^M\) represents macro-strain. Here for simplicity we restrict ourselves to small strain. Such constrains enforce that </p><p class="formulaDsp">
\[ {\boldsymbol \varepsilon}^M = \frac{1}{V} \int_\Omega {\boldsymbol \varepsilon} \textrm{d}\Omega = \frac{1}{V} \int_\Gamma \textrm{sym}[\mathbf{n}\otimes\mathbf{u}] \textrm{d}\Gamma. \]
</p>
<p> Moreover, periodic boundary conditions satisfy the Hill-Mandel condition meaning that the energy expressed in terms macro quantities is equal to energy expressed in terms micro quantities </p><p class="formulaDsp">
\[ {\boldsymbol \varepsilon}^M:{\boldsymbol \sigma}^M = \frac{1}{V} \int_\Omega {\boldsymbol \varepsilon}:{\boldsymbol \sigma} \textrm{d}\Omega = \frac{1}{V} \int_\Gamma \mathbf{u}\cdot\mathbf{n}{\boldsymbol \sigma} \textrm{d}\Gamma, \]
</p>
<p> where \(\mathbf{n}\) is the unit normal to the surface. All above equations and boundary integrals are true assuming that the equilibrium equation </p><p class="formulaDsp">
\[ \textrm{div}[{\boldsymbol \sigma}] = \mathbf{0} \]
</p>
<p> is satisfied for all points within the RVE. See <a class="el" href="citelist.html#CITEREF_NME:NME2188">[36]</a> for details. In this paper the equilibrium equation is satisfied in the weak sense.</p>
<p>Applying periodic constraints to a discreet problem requires that surface meshes on opposite sides must have matching geometry, i.e. nodal positions and topology. In general for simple geometries such meshes can be generated easily, however for more complex microstructures (for example in crystallography) generation of periodic meshes is non-trivial. Nitsche's method enables the user to apply periodic constraints on non-periodic meshes, however in this document we focus on problem formulation, where technicalities related to numerical integration on non-matching meshes are not discussed.</p>
<p>In the first part we will derive the unified Nitsche's method with generic multipoint constrains. Next a special case of periodic constraints is shown. After that, implementation aspects of the method are briefly discussed. finally at the end a simple numerical example is presented.</p>
<p>If you would like to add a more sophisticated example to this documentation, please contact us at <a href="#" onclick="location.href='mai'+'lto:'+'cma'+'tg'+'u@g'+'oo'+'gle'+'gr'+'oup'+'s.'+'com'; return false;">cmatg<span style="display: none;">.nosp@m.</span>u@go<span style="display: none;">.nosp@m.</span>ogleg<span style="display: none;">.nosp@m.</span>roup<span style="display: none;">.nosp@m.</span>s.com</a>. We will help you to install <a class="el" href="namespaceMoFEM.html" title="implementation of Data Operators for Forces and Sources">MoFEM</a> and guide you on how to use it. Implementation of Nitsche's method is general (see <a class="el" href="group__nitsche__method.html">Nitsche Method</a>), and could be extended to other problems, for example, contact at a cohesive interface, general contact problems, sliding boundary conditions etc. If you are interested in solving kinds of problems, we can help you with the implementation.</p>
<h1><a class="anchor" id="nitsche_method_periodic_formulation"></a>
Formulation of Nitsche's method</h1>
<p>In the course of learning Nitsche's method we typically follow two papers, see <a class="el" href="citelist.html#CITEREF_nitsche_method_hal">[27]</a> and <a class="el" href="citelist.html#CITEREF_juntunen2009nitsche">[35]</a>, this is an excellent starting point from which one can discover a vast pool literature on the subject. In the following document and implementation (see <a class="el" href="group__nitsche__method.html">Nitsche Method</a>), general symmetric and non-symmetric variants of the method are presented.</p>
<p>Dirichlet constraints need to be satisfied <em>a</em> <em>priori</em> by proper choice of approximation basis. This can be done easily when point constrains are applied; by erasing rows and columns in the stiffness matrix. In the case of multi-point constraints such as those found when using periodic boundary conditions, a Lagrange multiplier method can be used (see <a href="homo_final_document.pdf" target="_blank"><b>this link</b></a>) or projection operators can be constructed (see <a class="el" href="citelist.html#CITEREF_NME:NME2188">[36]</a>) to enforce constraints.</p>
<p>The Nitsche's method on the other hand enforces kinematic constrains in the weak sense by replacing Dirichlet constrains with additional Neumann terms in bilinear form. This method allows for greater flexibility which extends far beyond the simple application presented here. In this paper we focus on enforcing periodic constraints of an arbitrary shaped convex RVE.</p>
<h2><a class="anchor" id="general"></a>
A general Nitsche-based finite element method</h2>
<p>In the following section for convenience we using Voigt (vector-matrix) notation, where </p><p class="formulaDsp">
\[ \boldsymbol\varepsilon = \{ \varepsilon_{xx},\, \varepsilon_{yy},\, \varepsilon_{zz},\, 2\varepsilon_{xy},\, 2\varepsilon_{yz},\, 2\varepsilon_{xz} \}. \]
</p>
<p> The considered problem is restricted to a RVE, therefore body forces or any boundary conditions are neglected, only kinematic constraints enforced on the RVE boundary are factored in. In this section we do not intended to give a formal and precise prerequisite, defining the considered function spaces and detailed proofs, our focus is on the application and simplicity of the document.</p>
<p>We consider an elastic body in the reference domain \(\Omega\) with a sufficiently smooth boundary \(\Gamma\). For simplicity, we restrict formulation to linear elasticity, however implementation in <a class="el" href="namespaceMoFEM.html" title="implementation of Data Operators for Forces and Sources">MoFEM</a> is general and extends to non-linear cases. The considered weak problem takes the well known form </p><p class="formulaDsp">
\[ \begin{equation} a(\mathbf{u},\mathbf{v}) - \int_\Gamma {\boldsymbol\sigma}^\textrm{T}(\mathbf{u})\mathbf{n}^\textrm{T}\mathbf{v} \textrm{d}\Gamma = 0, \quad \forall \mathbf{v} \end{equation} \]
</p>
<p> where \(\mathbf{n}\) is a normal on the surface \(\Gamma\), \(\boldsymbol\sigma\) is a stress calculated from the hyperelastic physical equation, \(\mathbf{u}\) and \(\mathbf{v}\) are displacement and test functions respectively. We will now consider a case in which both displacements and test functions belong to the standard Lagrange finite element space such that weak form can be expressed by a system of algebraic equations. Note that the Lagrange finite element approximation space is a dense and finite subspace of \(H^1(\Omega)\).</p>
<p>The traction force on the RVE boundary \(\Gamma\) in the spirit of Nitsche's method is given by </p><p class="formulaDsp">
\[ \mathbf{t}(\mathbf{u}) = \mathbf{n}{\boldsymbol\sigma} = -\frac{1}{\gamma} \mathcal{R}(\mathcal{C}\mathbf{u}-\mathbf{g}-\gamma\mathcal{C}\mathbf{t}(\mathbf{u})) \quad\textrm{on}\,\Gamma \]
</p>
<p> where \(\gamma := \gamma(x) &gt; 0\) is some bounded (continuity condition) positive function defined on the RVE boundary, \(\mathcal{C}\) is a linear constraint operator and \(\mathbf{g}\) is a constraint function. Since we restrict ourselves to Lagrange finite element spaces constraints can be written as an algebraic condition. Taking this into account the operator \(\mathcal{R}\) is defined by </p><p class="formulaDsp">
\[ \mathcal{R} = \mathcal{C}^\textrm{T}(\mathcal{C}\mathcal{C}^\textrm{T})^{-1}, \]
</p>
<p> and the constraint projection operator is given by </p><p class="formulaDsp">
\[ \mathcal{P} = \mathcal{R}\mathcal{C}. \]
</p>
<p> Note that the projection operator has the well-known property, \(\mathcal{P} = \mathcal{P}\mathcal{P}\). The constraint operator \(\mathcal{C}\), gives a well posed problem if constraints are not too restrictive and matrix \(\mathcal{C}\) is full rank. See <a class="el" href="citelist.html#CITEREF_ainsworth2001essential">[4]</a> for details on how algebraic projection operators are constructed. Here operator \(\mathcal{C}\) and dependent operators are acting on approximation functions rather than on the function value at a specific point in space. Here we are simply considering the finite element approximation, thus \(\mathcal{C}\) can be seen as a matrix which operates on multiple degrees of freedom potentially on multiple nodes (entities). Now let \(\phi\) be some fixed real value parameter and noting that </p><p class="formulaDsp">
\[ \mathbf{v} = \mathcal{R}(\mathcal{C}\mathbf{v}-\phi\gamma\mathcal{C}\mathbf{t}(\mathbf{v})) +\phi\gamma\mathcal{P}\mathbf{t}(\mathbf{v}) + \mathcal{Q}\mathbf{v} \]
</p>
<p> where \(\mathcal{Q}=\mathcal{I}-\mathcal{P}\). To show that the above relationship is true, see that \(\mathcal{R}\mathcal{C}=\mathcal{P}\) and \(\mathcal{P}+\mathcal{Q}=\mathcal{I}\). After <a class="el" href="citelist.html#CITEREF_nitsche_method_hal">[27]</a> and <a class="el" href="citelist.html#CITEREF_juntunen2009nitsche">[35]</a> is proposed, \(\gamma\) turns out to be a positive constant function on the RVE face. </p><p class="formulaDsp">
\[ \gamma(x) = \gamma_0. \]
</p>
<p> Having definition of tractions and test functions, the weak problem takes on the form of a generalised Nitsche's method. </p><p class="formulaDsp">
\[ \begin{split} a(\mathbf{u},\mathbf{v}) - \sum_E \int_\Gamma \phi \gamma_0 \mathbf{t}^{\textrm{T}}(\mathbf{u}) \mathcal{P}\mathbf{t}(\mathbf{v}) \textrm{d}\Gamma + \sum_E \int_\Gamma \frac{1}{\gamma_0} \mathcal{R}(\mathcal{C}\mathbf{v}-\phi \gamma_0\mathcal{C}\mathbf{t}(\mathbf{v})) \textrm{d}\Gamma = 0 \quad \forall \mathbf{v} \end{split} \]
</p>
 <p class="formulaDsp">
\[ \begin{split} a(\mathbf{u},\mathbf{v}) - \sum_E \int_\Gamma \phi \gamma_0 \mathbf{t}^{\textrm{T}}(\mathbf{u}) \mathcal{P}\mathbf{t}(\mathbf{v}) \textrm{d}\Gamma + \sum_E \int_\Gamma \frac{1}{\gamma_0} \left\{ \mathbf{u}-\gamma_0\mathbf{t}(\mathbf{u})) \right\}^\textrm{T} \mathcal{P} (\mathbf{v}-\phi \gamma_0\mathbf{t}(\mathbf{v})) \textrm{d}\Gamma = \sum_E \int_\Gamma \frac{1}{\gamma_0} \mathbf{g}^\textrm{T}\mathcal{R}^\textrm{T} (\mathbf{v}-\phi \gamma_0\mathbf{t}(\mathbf{v})) \textrm{d}\Gamma \quad \forall \mathbf{v} \end{split} \]
</p>
<p> which some simplifications this lead to </p><p class="formulaDsp">
\[ \begin{split} a(\mathbf{u},\mathbf{v}) - \sum_E \int_\Gamma \left\{ \mathbf{t}^\textrm{T}(\mathbf{u})\mathcal{P}\mathbf{v} + \phi\mathbf{u}^\textrm{T}\mathcal{P}\mathbf{t}(\mathbf{v}) \right\} \textrm{d}\Gamma + \sum_E \int_\Gamma \frac{1}{\gamma_0} \mathbf{u}^\textrm{T}\mathcal{P}\mathbf{v} \textrm{d}\Gamma = \sum_E \int_\Gamma \frac{1}{\gamma_0} \mathbf{g}^\textrm{T}\mathcal{R}^\textrm{T} \mathbf{v} \textrm{d}\Gamma - \phi \int_\Gamma \mathbf{t}^\textrm{T}(\mathbf{v}) \mathcal{R}\mathbf{g} \textrm{d}\Gamma \quad \forall \mathbf{v} \end{split} \]
</p>
<p> Since we restrict ourselves to standard finite element approximation, the above equation can be expressed in in algebraic form, </p><p class="formulaDsp">
\[ \left[ \mathbf{A} - (\mathbf{A}_\sigma+\phi\mathbf{A}^\textrm{T}_\sigma) + \frac{1}{\gamma_0}\mathbf{A}_{\gamma_0} \right] \mathbf{q} = \frac{1}{\gamma_0}\mathbf{f}_{\gamma_0}-\phi\mathbf{f}_\phi \]
</p>
<p> where \(\mathbf{q}\) is a vector of unknown degrees of freedom, in addition we define the auxiliary matrix </p><p class="formulaDsp">
\[ \mathbf{A}_\phi = (\mathbf{A}_\sigma+\phi\mathbf{A}^\textrm{T}_\sigma) \]
</p>
<p> and finally we get </p><p class="formulaDsp">
\[ \left[ \mathbf{A} - \mathbf{A}_\phi + \frac{1}{\gamma_0}\mathbf{A}_{\gamma_0} \right] \mathbf{q} = \frac{1}{\gamma_0}\mathbf{f}_{\gamma_0}-\phi\mathbf{f}_\phi \]
</p>
<p> where matrices are defined as follows </p><p class="formulaDsp">
\[ \mathbf{A} = \int_\Omega \mathbf{B}^\textrm{T}\mathbf{D}\mathbf{B} \textrm{d}\Omega, \quad \mathbf{A}_\sigma = \sum_E \int_\Gamma \mathbf{N}^\textrm{T} \mathcal{P} \mathbf{n}\mathbf{D}\mathbf{B} \textrm{d}\Gamma, \quad \mathbf{A}_{\gamma_0} = \sum_E \int_\Gamma \mathbf{N}^\textrm{T} \mathcal{P} \mathbf{N} \textrm{d}\Gamma, \]
</p>
<p> where \(\mathbf{N}\) is a matrix of shape functions, \(\mathbf{B}\) is the standard differential operator, such that \(\boldsymbol\varepsilon(\mathbf{u})=\mathbf{B}\mathbf{u}\), \(\mathbf{D}\) is the material stiffness matrix and \(\boldsymbol\sigma(\mathbf{u})=\mathbf{D}\mathbf{B}\mathbf{u}\) where </p><p class="formulaDsp">
\[ \mathbf{n}= \left[ \begin{array}{cccccc} n_1 &amp; 0 &amp; 0 &amp; n_2 &amp; 0 &amp; n_3 \\ 0 &amp; n_2 &amp; 0 &amp; n_1 &amp; n_3 &amp; 0 \\ 0 &amp; 0 &amp; n_3 &amp; 0 &amp; n_2 &amp; n_3 \end{array} \right], \]
</p>
<p> In which \(n_1\), \(n_2\) and \(n_3\) are components of the unit normal vector on the body surface. The right hand side vectors are defined as follows </p><p class="formulaDsp">
\[ \mathbf{f}_{\gamma_0} = \sum_E \int_\Gamma \mathbf{N}^\textrm{T}\mathcal{R}\mathbf{g} \quad \mathbf{f}_\phi = \phi \sum_E \int_\Gamma \mathbf{B}^\textrm{T}\mathbf{D}\mathbf{n}^\textrm{T} \mathcal{R}\mathbf{g} \textrm{d}\Gamma. \]
</p>
<p> After <a class="el" href="citelist.html#CITEREF_nitsche_method_hal">[27]</a> introduction of the numerical parameter \(\phi\), allows for us to include some variants acting on the symmetry / skew-symmetry / non-symmetry of the discrete formulation.</p>
<h2><a class="anchor" id="consistency"></a>
Consistency of Nitsche's method</h2>
<p>Suppose that the exact solution of a continuous problem with constraints ( \(\mathcal{C}\mathbf{u} - \mathbf{g} = \mathbf{0}\)), is exactly interpolated on the finite element approximation space. We show that Nitsche's method is consistent with such an exact solution. Taking the weak equation </p><p class="formulaDsp">
\[ \begin{split} a(\mathbf{u},\mathbf{v}) - \sum_E \int_\Gamma \mathbf{t}^{\textrm{T}}(\mathbf{u}) \phi\gamma\mathcal{P}\mathbf{t}(\mathbf{v}) \textrm{d}\Gamma + \sum_E \int_\Gamma \frac{1}{\gamma_0} \left\{ \mathcal{R}(\mathcal{C}\mathbf{u}-\mathbf{g}-\gamma\mathcal{C}\mathbf{t}(\mathbf{u})) \right\}^\textrm{T} \mathcal{R}(\mathcal{C}\mathbf{v}-\phi\gamma\mathcal{C}\mathbf{t}(\mathbf{v})) \textrm{d}\Gamma = 0 \end{split} \]
</p>
<p> and substituting the tractions approximation </p><p class="formulaDsp">
\[ \mathbf{t}(\mathbf{u}) = -\frac{1}{\gamma} \mathcal{R}(\mathcal{C}\mathbf{u}-\mathbf{g}-\gamma\mathcal{C}\mathbf{t}(\mathbf{u})), \]
</p>
<p> as a result of simple algebraic manipulations, the standard weak from is recovered </p><p class="formulaDsp">
\[ a(\mathbf{u},\mathbf{v}) - \int_\Gamma {\boldsymbol\sigma}^\textrm{T}(\mathbf{u})\mathbf{N}^\textrm{T}\mathbf{v} \textrm{d} \Gamma = 0. \]
</p>
<p>This shows the solution of Nitsche's method is a solution of original problem with constraints. In other words, as long as the problem is well-posed, solution of Nitsche's method converges to the original problem with the given constraints. Note that penalty method solution is not consistent, in a sense that the solution of the original problem with constraints is not a solution when penalty terms enforce constraints.</p>
<p>In using the classical penalty method, to verify correctness of the results one needs to show that results converge for both increasing mesh density (approximation order) and for \(\gamma_0 \to 0\). Since Nitsche's method is consistent, it is only necessary to demonstrate solution convergence when we refining mesh or increasing approximation order. Here \(\gamma_0\) is understood as the stabilisation parameter which controls the convergence rate. However, since we work with finite precision arithmetics, \(\gamma_0\) cannot be too small to have well a conditioned matrix.</p>
<h2><a class="anchor" id="nitsche_posedness"></a>
Well-posedness</h2>
<p>If a problem is considered 'well posed' it means that a solution exist, this is a unique characteristic which depends continuously on the boundary conditions. In the example below we will detail a coercive problem, this implies that the stiffness matrix is positively defined. Note that this does not imply symmetry of the operator on right hand side. Our focus here is on simplicity of the argumentation rather than on strict formal mathematical proof.</p>
<p>After <a class="el" href="citelist.html#CITEREF_nitsche_method_hal">[27]</a> we use following property (*) </p><p class="formulaDsp">
\[ \int_\Gamma \mathbf{t}^\textrm{T}(\mathbf{v}) \mathcal{P} \mathbf{t}(\mathbf{v}) \textrm{d}\Gamma \leq C_I a(\mathbf{v},\mathbf{v}) \]
</p>
<p> and using that finite element approximation is applied, i.e. \(\mathbf{v} = \mathbf{N}\mathbf{q}\), we get </p><p class="formulaDsp">
\[ \int_\Gamma \mathbf{t}^\textrm{T}(\mathbf{v}) \mathcal{P} \mathbf{t}(\mathbf{v}) \textrm{d}\Gamma \leq C_I \mathbf{q}^\textrm{T} \mathbf{A} \mathbf{q} \]
</p>
<p>Moreover, we assume that the initial problem without constraints is well posed, i.e. rigid body motion is restricted, below we can see that matrix \(\mathbf{A}\) is positively defined </p><p class="formulaDsp">
\[ \mathbf{q}^\textrm{T} \mathbf{A} \mathbf{q} \geq C \mathbf{q}^\textrm{T}\mathbf{q} \]
</p>
<p> In addition, using properties of the projection matrix \(\mathcal{P}\), it is noted that matrix \(\mathbf{A}_{\gamma_0}\) is semi-positively defined.</p>
<p>To show that the problem is coercive, the following methodology from <a class="el" href="citelist.html#CITEREF_nitsche_method_hal">[27]</a> and <a class="el" href="citelist.html#CITEREF_juntunen2009nitsche">[35]</a>, for given equality </p><p class="formulaDsp">
\[ \mathbf{q}^\textrm{T} (\mathbf{A}-\mathbf{A}_\phi+\frac{1}{\gamma_0}\mathbf{A}_{\gamma_0}) \mathbf{q} = \mathbf{q}^\textrm{T} \mathbf{A} \mathbf{q} - \int_\Gamma \left\{ \mathbf{t}^\textrm{T}(\mathbf{v})\mathcal{P}\mathbf{v} + \phi\mathbf{v}^\textrm{T}\mathcal{P}\mathbf{t}(\mathbf{v}) \right\} \textrm{d}\Gamma + \gamma_0 \mathbf{q}^\textrm{T} \mathbf{A}_{\gamma_0} \mathbf{q} \]
</p>
<p> and using property (*) and applying Young's inequality in above we get </p><p class="formulaDsp">
\[ \mathbf{q}^\textrm{T} (\mathbf{A}-\mathbf{A}_\phi+\frac{1}{\gamma_0}\mathbf{A}_{\gamma_0}) \mathbf{q} \geq \mathbf{q}^\textrm{T} \left\{ \mathbf{A} - C_I\epsilon\frac{1+\phi}{2} \mathbf{A} - \frac{(1+\phi)}{2\epsilon} \mathbf{A}_{\gamma_0} + \gamma_0\mathbf{A}_{\gamma_0} \right\} \mathbf{q}. \]
</p>
 <p class="formulaDsp">
\[ \mathbf{q}^\textrm{T} (\mathbf{A}-\mathbf{A}_\phi+\frac{1}{\gamma_0}\mathbf{A}_{\gamma_0}) \mathbf{q} \geq \mathbf{q}^\textrm{T} \left\{ \left(1-C_I\epsilon\frac{1+\phi}{2}\right)\mathbf{A} + \left(\frac{1}{\gamma_0}-\frac{(1+\phi)}{2\epsilon}\right)\mathbf{A}_{\gamma_0} \right\} \mathbf{q}. \]
</p>
<p> where \(\epsilon&gt;0\). Having the above inequality at hand we can consider following variants,</p>
<ul>
<li>for \(\phi=1\) we get a symmetric variant of the matrix \(\mathbf{A}_\phi\), taking \(\epsilon &lt; 1/C_I\) and \(1/\gamma_0&gt;C_I\), the matrix is positively defined and the problem has a unique solution.</li>
<li>for \(\phi=0\) we get non-symmetric variant of \(\mathbf{A}_\phi\), taking \(\epsilon &lt; 1/2C_I\) and \(1/\gamma_0&gt;2C_I\), the matrix is positively defined and the problem has a unique solution.</li>
<li>for \(\phi=-1\) we get a skew-symmetry version of \(\mathbf{A}_\phi\), which has the remarkable characteristic of being well-posed and convergent irrespective of the value of \(\gamma_0&gt;0\).</li>
</ul>
<p>We note that matrix \(\mathbf{A}\) doesn't necessary has to restrict translation or rotation, if matrix \(\mathbf{A}_{\gamma_0}\) constrains translation or rotation, respectively. In other words, the sum of matrices \(\mathbf{A}\) and \(\mathbf{A}_{\gamma_0}\) has to be a full rank matrix.</p>
<h1><a class="anchor" id="periodic_bc"></a>
Periodic boundary conditions</h1>
<p>In this section we consider periodic boundary conditions which are applied by Nitsche's method by specifying appropriate constraint matrices and vectors. Let constraint matrix be given by </p><p class="formulaDsp">
\[ \mathcal{C} = [\mathbf{I},-\mathbf{I}], \]
</p>
<p> where \(\mathbf{I}\) is unit matrix (3x3). The auxiliary matrix is given by </p><p class="formulaDsp">
\[ \mathcal{R} = \frac{1}{2} \left\{ \begin{array}{c} \mathbf{I}\\ -\mathbf{I} \end{array} \right\} \]
</p>
<p> and the projection matrix has the form </p><p class="formulaDsp">
\[ \mathcal{P} = \frac{1}{2} \left[ \begin{array}{cc} \mathbf{I} &amp; -\mathbf{I}\\ -\mathbf{I} &amp; \mathbf{I} \end{array} \right] \]
</p>
<p> In addition, we define matrices </p><p class="formulaDsp">
\[ \mathbf{E}(\mathbf{x}) = \frac{1}{2} \left[ \begin{array}{cccccc} 2x &amp; 0 &amp; 0 &amp; y &amp; 0 &amp; z \\ 0 &amp; 2y &amp; 0 &amp; x &amp; z &amp; 0 \\ 0 &amp; 0 &amp; 2z &amp; z &amp; 0 &amp; x \end{array} \right] \]
</p>
<p> and get the constraint vector as follows </p><p class="formulaDsp">
\[ \mathbf{g} = \mathcal{P}\mathbf{D}{\boldsymbol\varepsilon}^M = (\mathbf{E}_{+}-\mathbf{E}_{-}){\boldsymbol\varepsilon^M}. \]
</p>
<p> where \({\boldsymbol\varepsilon}^M\) is the macroscopic stress vector in Voigt notation. Finally, the constraint matrix has the form, </p><p class="formulaDsp">
\[ \mathcal{C}\left\{ \mathbf{q}_+, \mathbf{q}_- \right\} = \mathbf{g} \]
</p>
<p> where \(+\) and \(-\) indicate points the on boundary of the RVE on opposite sides. We assume an arbitrary convex RVE shape and in the case periodic material we assume that the array of unit cells will fill the space without holes. This results in the following matrices which are specific for periodic boundary conditions </p><p class="formulaDsp">
\[ \mathbf{A}_\sigma = \sum_{E_+} \int_{\Gamma} \left\{ \mathbf{N}^\textrm{T}_+ - \mathbf{N}^\textrm{T}_- \right\} \mathbf{n}\mathbf{D}\mathbf{B}_+ \textrm{d}\Gamma + \sum_{E_-} \int_{\Gamma} \left\{ \mathbf{N}^\textrm{T}_- - \mathbf{N}^\textrm{T}_+ \right\} \mathbf{n}\mathbf{D}\mathbf{B}_- \textrm{d}\Gamma \quad \mathbf{A}_{\gamma_0} = \sum_{E_+} \int_{\Gamma} \mathbf{N}^\textrm{T}_+ \left\{ \mathbf{N}^\textrm{T}_+ - \mathbf{N}^\textrm{T}_- \right\} \textrm{d}\Gamma + \sum_{E_-} \int_{\Gamma} \mathbf{N}^\textrm{T}_- \left\{ \mathbf{N}^\textrm{T}_- - \mathbf{N}^\textrm{T}_+ \right\} \textrm{d}\Gamma \]
</p>
<p> where \(E_+\) and \(E_-\) indicate edges on opposite sides of the RVE boundary, i.e. same the normal direction but opposite signs. Analogically the right hand side vector takes the form </p><p class="formulaDsp">
\[ \mathbf{f}_{\gamma_0} = \left\{ \sum_{E_+} \int_\Gamma \mathbf{N}^\textrm{T}_+\mathbf{E}_+ \textrm{d}\Gamma - \sum_{E_-} \int_\Gamma \mathbf{N}^\textrm{T}_-\mathbf{E}_- \textrm{d}\Gamma \right\} {\boldsymbol\varepsilon}^M \quad \mathbf{f}_\phi = \phi\left\{ \sum_{E_+} \int_\Gamma \mathbf{B}^\textrm{T}_+\mathbf{D}\mathbf{n}^\textrm{T} \mathbf{E}_- \textrm{d}\Gamma - \sum_{E_-} \int_\Gamma \mathbf{B}^\textrm{T}_-\mathbf{D}\mathbf{n}^\textrm{T} \mathbf{E}_- \textrm{d}\Gamma \right\} {\boldsymbol\varepsilon}^M. \]
</p>
<p> Note that periodic boundary conditions restrict rotations, however translation is still possible. In order to get a unique solution translation needs to be restricted.</p>
<h1><a class="anchor" id="Implementation"></a>
Implementation</h1>
<p>The following methodology is implemented in <a class="el" href="NitscheMethod_8hpp.html">NitscheMethod.hpp</a>. Integration of matrices and vectors specific to periodic constrains on the RVE surface is implemented in <a class="el" href="NitschePeriodicMethod_8hpp.html">NitschePeriodicMethod.hpp</a>.</p>
<p>For current implementation, the integration points on opposite faces are calculated using AdaptiveKDTree from MoAB library. An intersection of ray with the opposite RVE surface is calculated, where ray emanating from the given integration point has a direction set by surface normal. As a result, each integration point has a unique and opposite integration point. The user does not need to specify faces on the opposite side and an arbitrary convex shape of RVE is allowed. At the current stage of development, the integration scheme assumes that meshes on opposite sides are aligned. In case of non-aligned meshes the implemented algorithm works, however that leads to some inexact integrals.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000083">Todo:</a></b></dt><dd><p class="startdd">Implement integration for Nitsche's method with periodic constraints where faces on opposite sides do not align. </p>
<p class="enddd">Implement interface in main MoAB library for projecting surface/volume meshes, such that the resulting mesh encapsulates all entities of both meshes.</p>
</dd></dl>
<p>Neumann terms in Nitsche's are calculated using ADOL-C, i.e. automatic differentiation. This allows for calculations with arbitrary nonlinear materials without modifications of the Nitche's method implementation. Stresses and stress derivatives over the deformation gradient are implemented in generic nonlinear element, see <a class="el" href="NonLinearElasticElement_8hpp.html">NonLinearElasticElement.hpp</a>, where currently several material models are available <a class="el" href="Hooke_8hpp.html">Hooke.hpp</a>, <a class="el" href="NeoHookean_8hpp-example.html">NeoHookean.hpp</a>, <a class="el" href="SmallTransverselyIsotropic_8hpp.html">SmallTransverselyIsotropic.hpp</a> and more can be easily added on demand.</p>
<p>The example of usage is in <a class="el" href="rve__mechanical_8cpp.html">rve_mechanical.cpp</a>. In this implementation only elastic materials are considered.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000084">Todo:</a></b></dt><dd>Implement example for RVE with nonlinear material.</dd></dl>
<h1><a class="anchor" id="nitsche_method_periodic_example"></a>
Numerical example</h1>
<p>We consider periodic microstructure for which two unit cells are defined, with a central void (c) and with an off centre void (o). It is assumed that the material is elastic and subjected to small strains only. </p><div class="image">
<img src="nitshce_center_mesh.png" alt=""/>
<div class="caption">
RVE Void in center</div></div>
 <div class="image">
<img src="nitshce_off_mesh.png" alt=""/>
<div class="caption">
RVE Void off center</div></div>
<p>The unit cell geometry and material properties are defined by the following Cubit journal file. </p><div class="fragment"><div class="line">#!python</div>
<div class="line">autofactor=5; </div>
<div class="line">cubit.cmd(&#39;set duplicate block elements on&#39;)    </div>
<div class="line"> </div>
<div class="line">#============================================================= </div>
<div class="line">#Geometry</div>
<div class="line">#============================================================= </div>
<div class="line"> </div>
<div class="line">cubit.cmd(&#39;reset&#39;)</div>
<div class="line"> </div>
<div class="line">cubit.cmd(&#39;brick x 1 y 1 z 1&#39;)</div>
<div class="line">cubit.cmd(&#39;create sphere radius 0.3&#39;)</div>
<div class="line">#cubit.cmd(&#39;move Volume 2 x 0.14 y 0.14 z 0.14&#39;)</div>
<div class="line">cubit.cmd(&#39;subtract volume 2 from volume 1 &#39;)</div>
<div class="line">cubit.cmd(&#39;delete volume 2&#39;)</div>
<div class="line"> </div>
<div class="line">#============================================================= </div>
<div class="line">#Defining blocks for elastic, transversely-isotropic and potential flow problems  </div>
<div class="line">#============================================================= </div>
<div class="line"> </div>
<div class="line">vol=[&#39;all&#39;]  </div>
<div class="line">mat=[&#39;MAT_ELASTIC_1&#39;]  </div>
<div class="line">for i in range(0, 1):  </div>
<div class="line">    str1=&#39;block  &#39; + str(i+1) +&#39; volume &#39;+vol[i]; cubit.cmd(str1)  </div>
<div class="line">    str1=&#39;block  &#39; + str(i+1) +&#39; name &quot;&#39;+mat[i] + &#39;&quot;&#39;; cubit.cmd(str1)  </div>
<div class="line"> </div>
<div class="line">#============================================================= </div>
<div class="line">#Surface elements</div>
<div class="line">#============================================================= </div>
<div class="line">cubit.cmd(&#39;sideset 103 surface 1 4 3 2 6 5&#39;)  # all boundary surfaces  </div>
<div class="line">cubit.cmd(&#39;sideset 102 surface 1 5 6 &#39;)  # all -ve boundary surfaces</div>
<div class="line">cubit.cmd(&#39;sideset 101 surface 2 4 3  &#39;)  # all +ve boundary surfaces</div>
<div class="line"> </div>
<div class="line">#============================================================= </div>
<div class="line">#Material properties for matrix part  </div>
<div class="line">#============================================================= </div>
<div class="line">  </div>
<div class="line">cubit.cmd(&#39;block 1 attribute count 2&#39;)  </div>
<div class="line">Em=3.5e3; Enu=0.3;  #giga to mega as we used dimension in mm  </div>
<div class="line"> </div>
<div class="line">Elastic=[str(Em), str(Enu)]  </div>
<div class="line">for i in range(0, 2):  </div>
<div class="line">    str1=&#39;block 1 attribute index &#39; + str(i+1) +&#39; &#39;+Elastic[i]; cubit.cmd(str1)  </div>
<div class="line">  </div>
<div class="line">#============================================================= </div>
<div class="line">#Defining surfaces for dispacement, traction and periodic boundary conditions  </div>
<div class="line">#============================================================= </div>
<div class="line"> </div>
<div class="line">cubit.cmd(&#39;surface 1 scheme trimesh&#39;) </div>
<div class="line">str1=&#39;surface 1  size auto factor &#39;+str(autofactor); cubit.cmd(str1)</div>
<div class="line">cubit.cmd(&#39;mesh surface 1&#39;) </div>
<div class="line">cubit.cmd(&#39;surface 4 scheme trimesh&#39;) </div>
<div class="line">str1=&#39;surface 4  size auto factor &#39;+str(autofactor); cubit.cmd(str1)</div>
<div class="line">cubit.cmd(&#39;mesh surface 4&#39;) </div>
<div class="line">cubit.cmd(&#39;surface 3 scheme trimesh&#39;) </div>
<div class="line">str1=&#39;surface 3  size auto factor &#39;+str(autofactor); cubit.cmd(str1)</div>
<div class="line">cubit.cmd(&#39;mesh surface 3&#39;) </div>
<div class="line"> </div>
<div class="line">cubit.cmd(&#39;surface 2  scheme copy source surface 1  source vertex 2  target vertex 5  source curve 1  target curve 5  nosmoothing&#39;)</div>
<div class="line">cubit.cmd(&#39;mesh surface 2&#39;)</div>
<div class="line">cubit.cmd(&#39;surface 6  scheme copy source surface 4  source vertex 3  target vertex 2  source curve 3  target curve 1  nosmoothing&#39;)</div>
<div class="line">cubit.cmd(&#39;mesh surface 6&#39;)</div>
<div class="line">cubit.cmd(&#39;surface 5  scheme copy source surface 3  source vertex 7  target vertex 8  source curve 9  target curve 11  nosmoothing&#39;)</div>
<div class="line">cubit.cmd(&#39;mesh surface 5&#39;)</div>
<div class="line"> </div>
<div class="line">#mesh</div>
<div class="line">str1=&#39;volume all size auto factor &#39;+str(autofactor); cubit.cmd(str1)</div>
<div class="line">cubit.cmd(&#39;volume all scheme tetmesh&#39;)  </div>
<div class="line">cubit.cmd(&#39;mesh volume all&#39;)  </div>
<div class="line"> </div>
<div class="line">#============================================================= </div>
<div class="line">#High order geomety approximation</div>
<div class="line">#============================================================= </div>
<div class="line">cubit.cmd(&#39;block 5 tet all&#39;)         </div>
<div class="line">cubit.cmd(&#39;block 5 element type tetra10&#39;)    </div>
<div class="line"> </div>
</div><!-- fragment --><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000085">Todo:</a></b></dt><dd><a class="el" href="structExample.html" title="[Example]">Example</a> for mesh generated by TetGen/NetGen</dd></dl>
<p>In the following figures you can see that both unit cells with void in the centre and off-centre led to the same overall material response. Once the unit cell is repeated and subjected to deformation, both solutions led to the same overall stress distribution. </p><div class="image">
<img src="nitshce_periodic_center.png" alt=""/>
<div class="caption">
Solution for void in the center</div></div>
 <div class="image">
<img src="nitshce_off_preriodic.png" alt=""/>
<div class="caption">
Solution for void off the ceneter</div></div>
<p>The solution error is calculated from </p><p class="formulaDsp">
\[ err = \frac{|\sigma_{xx}^{M,\textrm{ref}}-\sigma^M_{xx}|}{|\sigma_{xx}^{M,\textrm{ref}}|} \]
</p>
<p> where \(\sigma^M_{xx}\) is the homogenised macroscopic stress, \(\sigma_{xx}^{M,\textrm{ref}}\) is the reference macroscopic stress. Such an error measure is equivalent to the seminorm in \(H^1(\Omega)\). The macro-stress is calculated by averaging micro-stresses as follows </p><p class="formulaDsp">
\[ {\boldsymbol\sigma}^M = \frac{1}{V}\int_\Omega {\boldsymbol\sigma} \textrm{d}V = \frac{1}{V}\int_\Gamma \mathbf{x}\otimes\mathbf{t} \textrm{d}\Gamma \]
</p>
<p> where \({\boldsymbol\sigma}\) is the micro-stress, \(\mathbf{t}\) is the traction on RVE boundary and \(\mathbf{x}\) is the spatial position on RVE surface. The reference solution has been calculated case of the unit cell with a central void, with periodic boundary conditions enforced by the Lagrange multiplier method on tetrahedral mesh with 29010 nodes and using 3rd order polynomial, this gives in total 738144 DOF. The following figure is focussed on convergence, with \(\gamma=10^{-4}\) and \(\phi=-1\).</p>
<div class="image">
<img src="nitshce_conv_plot1.png" alt=""/>
<div class="caption">
Convergence, void in center and off-ceneter</div></div>
<p>In the above figure it is shown that two types of unit cell converge to the same solution, moreover the slope of convergence for macro-stress is approximately ~0.4 for h-refined meshes. However, it is noted that mesh refinement is not-uniform and subsequent mesh refinements improve geometry approximations of the void surface. In <a class="el" href="citelist.html#CITEREF_nitsche_method_hal">[27]</a> and <a class="el" href="citelist.html#CITEREF_juntunen2009nitsche">[35]</a> is shown that <em>a</em> <em>priori</em> error estimator has a constant which depends not only on the mesh density but also the value of the stabilisation parameter \(\gamma_0\), showing that the rate of convergence is improved for smaller values of \(\gamma_0\).</p>
<p>In the two following figures it is shown how convergence changes for different values of \(\gamma_0\) and \(\phi\). Two cases are considered, p- adapativity and h- non-uniform mesh refinement.</p>
<div class="image">
<img src="nitshce_conv_plot2.png" alt=""/>
<div class="caption">
Convergence, void in center, p-adpativity</div></div>
<p>In the figure above uniform p- adaptivity is considered, three values of \(\phi = \{-1,0,1\}\) are considered and values of \(\gamma_0\) are subsequently set to 1e-4, 1e-6 and 1e-8. As shown above the convergence is unconditional for \(\phi=-1\) . Moreover convergence is lost for \(\gamma_0=10^{-4}\) and \(\phi=0\), wheres deteriorated for the symmetric case \(\phi=1\). This corresponds to the theoretical results obtained previously in <a class="el" href="nitsche_periodic.html#nitsche_posedness">Well-posedness</a>. Moreover, it can be noted that the convergence rate improves with increasing value of \(\gamma_0\), with the value of the slope ~0.9 for \(\gamma_0=10^{-4}\), up to slope ~2.1 for \(\gamma_0=10^{-8}\). This agrees with the findings in <a class="el" href="citelist.html#CITEREF_nitsche_method_hal">[27]</a> and <a class="el" href="citelist.html#CITEREF_juntunen2009nitsche">[35]</a>.</p>
<div class="image">
<img src="nitshce_conv_plot3.png" alt=""/>
<div class="caption">
Convergence, void in center, h-adpativity (non-uniform hierarchical mesh)</div></div>
<p>In the last figure h- adaptivity is analysed, using a constant value of \(\gamma_0=10^{-8}\) and three variants of \(\phi = \{-1,0,1\}\). It can be noted that in this case all variants showed good convergence, however for the 3rd polynomial order, convergence rate was seen to deteriorate. This is due to the large value of the stabilisation factor and the large number of DOF which reduce matrix conditioning.</p>
<p>The presented numerical example can be run with the script </p><div class="fragment"></div><!-- fragment --><p> Script needs to be run from the homogenisation build directory, i.e. </p><div class="fragment"><div class="line">nitsche_test.sh</div>
</div><!-- fragment --><p> Note that the script can be easily modified, for example several values of \(\gamma_0\) can be tested.</p>
<h1><a class="anchor" id="nitsche_conclusions"></a>
Conclusions</h1>
<p>Nitsche's method is an efficient and convenient means of enforcing multi-point constraints. The presented methodology augmented with hierarchical approximation basis and appropriate <em>a</em> \rm posterior error estimator gives rise to a powerful methodology. Here we limit ourself to linear constraints, however the presented approach could be easily extended to include a nonlinear constraint matrix.</p>
<p>The key difficulty in practical method implementation is that the Neumann terms depend on physical equations, which in general could be nonlinear. However in the implementation presented here this issue is resolved by automatic differentiation with ADOL-C, where Neumman terms are calculated for an arbitrary constitutive equation, see <a class="el" href="NitscheMethod_8hpp.html">NitscheMethod.hpp</a> for details.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000086">Todo:</a></b></dt><dd>Implement surface constraints for mesh smoothing, as an example nonlinear constrains.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000087">Todo:</a></b></dt><dd>For some cases, it was discovered that integration quadrature was insufficient. That is corrected however some plots need to be recalculated and updated.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000088">Todo:</a></b></dt><dd>In new contact module case for non-conforming meshes is implemented. The algorithm implemented there can be used to here.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000089">Todo:</a></b></dt><dd>For proposes of integration on skeleton new new element has been implemented, <a class="el" href="structMoFEM_1_1VolumeElementForcesAndSourcesCoreOnSide.html" title="Base volume element used to integrate on skeleton.">MoFEM::VolumeElementForcesAndSourcesCoreOnSide</a> and user operator <a class="el" href="structMoFEM_1_1VolumeElementForcesAndSourcesCoreOnSide_1_1UserDataOperator.html" title="default operator for TET element">MoFEM::VolumeElementForcesAndSourcesCoreOnSide::UserDataOperator</a>. Those developemnt can be used here to futher simplify implementation. Such elements are used in UltraWeakTransportElement.hpp to inegrate jumps on mesh skeleton.</dd></dl>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr cla ss="footer" />
<style>
  img[src="UoGLogo.png"] {
    height: 20px;
    padding-top: 0px;
    padding-right: 1px;
    padding-bottom: 3px;
    padding-left: 6px;
  }
</style>
<address class="footer">
  <small>
    Generated by
    <a href="http://www.doxygen.org/index.html"> Doxygen </a> 1.8.17
    and hosted at
    <a href="http://www.gla.ac.uk/schools/engineering/">
      <img class="footer" src="UoGLogo.png" alt="University of Glasgow" />
    </a>
  </small>
</address>
</body>
</html>