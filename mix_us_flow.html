<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
  <meta http-equiv="X-UA-Compatible" content="IE=9"/>
  <meta name="generator" content="Doxygen 1.9.5"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>MoFEM: COR-1: Time dependent nonlinear mix formulation (unsaturated flow)</title>
  <link href="tabs.css" rel="stylesheet" type="text/css"/>
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
  <script type="text/javascript " src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML "></script>
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        extensions: ["AMSmath.js"],
        TeX: { equationNumbers: { autoNumber: ["all"],
                                  useLabelIds: true
        } 
        }
    });
    </script>
  <link href="customdoxygen.css" rel="stylesheet" type="text/css" />
  <link href="extra_style.css" rel="stylesheet" type="text/css"/>
  <link rel="apple-touch-icon" sizes="57x57" href="apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192"  href="android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.png">
  <link rel="shortcut icon" type="image/png" href="favicon-32x32.png"/>
  <link rel="Bookmark" type="image/png" href="favicon-32x32.png"/>
  <link rel="manifest" href="manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div style="background-color:#011A40" id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 30px;">
  <td id="projectlogo"><img alt="Logo" src="MoFEMLogo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <td style="padding-left: 0.5em;" bgcolor="#011A40"
   <div id="projectbrief"><font color="#FFFFFF">v0.14.0</font></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!--Google analytics tags-->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-65236130-1', 'auto');
  ga('send', 'pageview');
</script>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-2J9RE2P3H5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-2J9RE2P3H5');
</script><!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>  </ul>
</div>
</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">COR-1: Time dependent nonlinear mix formulation (unsaturated flow) </div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#mix_us_flow_numerical_examples">Numerical examples</a><ul><li class="level2"><a href="#mix_us_flow_example_1">Numerical example 1</a><ul><li class="level3"><a href="#mix_us_flow_example_1_mesh">Mesh</a></li>
<li class="level3"><a href="#mix_us_flow_example_1_model_parameters">Model parameters</a></li>
<li class="level3"><a href="#mix_us_flow_example_1_model_runing">Analysis</a></li>
<li class="level3"><a href="#mix_us_flow_example_1_model_results">Results</a></li>
</ul>
</li>
<li class="level2"><a href="#mix_us_flow_example_2">Numerical example 2</a><ul><li class="level3"><a href="#mix_us_flow_example_2_mesh">Mesh</a></li>
<li class="level3"><a href="#mix_us_flow_example_2_model_parameters">Model parameters</a></li>
<li class="level3"><a href="#mix_us_flow_example_2_model_runig">Analysis</a></li>
<li class="level3"><a href="#mix_us_flow_example_2_model_results">Results</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#mix_us_flow_model">Mathematical model</a><ul><li class="level2"><a href="#mix_us_flow_pde">PDE</a></li>
<li class="level2"><a href="#mix_us_flow_physical_equation">Physical equations</a></li>
<li class="level2"><a href="#mix_us_flow_physical_equation_adding_material">Adding new material</a></li>
</ul>
</li>
<li class="level1"><a href="#mix_us_flow_numerical_model">Numerical model</a><ul><li class="level2"><a href="#mix_us_flow_numerical_mass">Conservation of mass</a></li>
<li class="level2"><a href="#mix_us_flow_numerical_physical">Physical equation</a></li>
<li class="level2"><a href="#mix_us_flow_numerical_discretisation">Semi-discrete linearized system of equations</a></li>
<li class="level2"><a href="#mix_us_flow_time_discretistion">Time discretization</a></li>
</ul>
</li>
<li class="level1"><a href="#mix_us_flow_implemntation">Implementation</a><ul><li class="level2"><a href="#mix_us_flow_declarations">Declaration of fields, finite elements and problem</a></li>
<li class="level2"><a href="#mix_us_flow_fe_instances">Creating finite element instances</a><ul><li class="level3"><a href="#mix_us_flow_fe_instances_op">Adding operators to elements</a></li>
<li class="level3"><a href="#mix_us_flow_fe_instances_op_ts">Adding finite element instances to DM</a></li>
</ul>
</li>
<li class="level2"><a href="#mix_us_flow_solving_problem">Solving problem using TS</a></li>
</ul>
</li>
<li class="level1"><a href="#mix_us_flow_application">Application code</a></li>
<li class="level1"><a href="#mix_us_flow_to_do">To do</a></li>
</ul>
</div>
<div class="textblock"><p >In this tutorial, we show how to solve a strongly nonlinear time dependent equation using mix-finite-elements. We focus on construction of finite elements, finite element user data operators (UDO), setting up discrete manager (DM) and time solver (TS). Issues related to the nonlinear solver and line searchers are briefly discussed. We also show how to use automatic differentiation (<a href="https://github.com/coin-or/ADOL-C">ADOL-C</a>) to calculate derivatives of a constitutive model.</p>
<p >Problem solved here is similar to the solution of nonlinear <a class="el" href="struct_poisson.html">Poisson</a>'s equation described in <a class="el" href="poisson_tut4.html">COR-5: A nonlinear Poisson equation</a> and is a generalization of the problem described in <a class="el" href="mix_transport.html">COR-0: Mixed formulation and integration on skeleton (h-adaptivity)</a>. You might look to those tutorials if some implementation aspects of presented methodology are unclear. Also, you are encouraged to post questions on our <a href="https://groups.google.com/forum/#!categories/mofem-group">Q&amp;A forum</a>.</p>
<p >Presented methodology is applied to the problem of unsaturated water transport. We have no intention to give a detailed description of transport in unsaturated materials, here we only focus on problem discretization, equations linearization and implementation of finite element. Also, we do not show here how to do hp-adaptivity, this is part of other tutorials. This problem can be solved with block solver, improving its efficiency and robustness, see example <a class="el" href="poisson_tut3.html">COR-4: Using fieldsplit solver and DM sub problem.</a>. If you like to extend this work, adding block solver or hp-adaptivity, we offer our guidance and help.</p>
<p >The application for unsaturated flow is implemented in <a class="el" href="unsaturated_transport_8cpp-example.html">unsaturated_transport.cpp</a>, material models are implemented in <a class="el" href="_material_unsaturated_flow_8hpp.html" title="Mix implementation of transport element.">MaterialUnsaturatedFlow.hpp</a>, problem definition and implementation are implemented in <a class="el" href="_unsaturated_flow_8hpp.html" title="Mix implementation of transport element.">UnsaturatedFlow.hpp</a>.</p>
<p >The tutorial is organized as follows. First, we explain how to run the application. Next, we show how the material model is implemented, after that we explain the mathematical and numerical models. Finally, we explain implementation details.</p>
<dl class="section note"><dt>Note</dt><dd>Not all information presented here is essential, some parts you can skip and come back to them later. For example, if you like to add your material model you have to focus attention on section <a class="el" href="mix_us_flow.html#mix_us_flow_physical_equation">Physical equations</a>.</dd></dl>
<h1><a class="anchor" id="mix_us_flow_numerical_examples"></a>
Numerical examples</h1>
<h2><a class="anchor" id="mix_us_flow_example_1"></a>
Numerical example 1</h2>
<p >You can imagine that we do an experiment, such that we have wet silt and dry clay, we make three layers, with silt in the middle, and clay on the top and below. Such column of soil we put in the box, for example, made from plexiglass. Thus all sides are impermeable. We will observe water content and capillary pressure for two days, that is long enough to approach equilibrium.</p>
<h3><a class="anchor" id="mix_us_flow_example_1_mesh"></a>
Mesh</h3>
<p >First, we create a mesh which can be made in Salome, gMesh, Tetgen, or any other code. <a class="el" href="namespace_mo_f_e_m.html" title="implementation of Data Operators for Forces and Sources">MoFEM</a> uses MOAB for mesh database which can read various mesh file formats. Here we using Cubit to make the mesh, the journal file for this problem is as follows </p><pre class="fragment">reset
# create body volume
brick x 0.01 y 0.002 z 0.1
move Volume all x 0 y 0 z -0.05 include_merged
brick x 0.1 y 0.06 z 0.02
move Volume 2  location volume 1  include_merged
chop volume 1 with volume 2
imprint volume all
merge volume all
# make block for clay
block 1 volume 4 5
block 1 name 'SOIL_CLAY1'
# make block for silt
block 2 volume 3
block 2 name 'SOIL_SILT2'
# make mesh
volume all size auto factor 10
volume all scheme Tetmesh
mesh volume all
# refine mesh at interfaces between clay &amp; silt
refine surface 13 14 size 0.0025 bias 1.5 depth 1 smooth
</pre><p> Note that we do not set any boundary conditions here, in that case, it is assumed that fluxes on the boundary are zero, that is the boundary is impermeable.</p>
<h3><a class="anchor" id="mix_us_flow_example_1_model_parameters"></a>
Model parameters</h3>
<p >Next, we need to make a configuration file, where all problem specific parameters are set. </p><pre class="fragment">[mat_block_1]
# VanGenuchten
# SimpleDarcy
material_name=VanGenuchten
# Default material for VanGenuchten is Clay (no need to set parameters if clay is used)
# Assumed units are in meters and days.

# Model parameters controlling convergence
sCale=1e6       # Scale mass conservation equation
ePsilon1=1e-5   # Minimal capacity when removing spurious oscillations in time

Ah=-9 # head suction at z = 0
AhZ=1 #�gradient of initial head suction
AhZZ=0 # initial head suction is calculated from equation h = Ah + AhZZ*z + AhZZ*zz

[mat_block_2]
material_name=VanGenuchten
# Material parameters for Silt from Vogel., van Genuchten Cislerova 2001
sCale=1e6
ePsilon1=1e-5
Ah=-0.09
AhZ=1
thetaS=0.46
thetaM=0.46
thetaR=0.034
alpha=1.6
n=1.37
Ks=0.006
hS=0
</pre><p> The material parameters are taken from <a class="el" href="citelist.html#CITEREF_vogel2000effect">[50]</a>, the initial parameters for clay (mat_block_1) and silt (mat_block_2) are set with the \(A_h\) and \(A_h^z\), such that initial capillary pressure head is given by  \(
h = A_h+A_h^z z
\) where  </p><p class="formulaDsp">
\[
\left\{
\begin{array}{ll}
h(z,t=0) = -9+z&amp;\textrm{for clay}\\
h(z,t=0) = -0.09+z&amp;\textrm{for silt}
\end{array}
\right.
\]
</p>
<h3><a class="anchor" id="mix_us_flow_example_1_model_runing"></a>
Analysis</h3>
<p >The analysis is run using script <em>run_uf.sh</em> </p><div class="fragment"></div><!-- fragment --><p >Editing that file you can set range of parameters, control time solver, tolerances, stop criteria, line-searcher. For details look to PETSc manual <a href="http://www.mcs.anl.gov/petsc/petsc-current/docs/manual.pdf">link</a>.</p>
<ul>
<li>Options controlling time solver (TS) see <a href="http://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/TS/TSSetFromOptions.html">link</a>.</li>
<li>Options controlling nonlinear solver (SNES) see <a href="http://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/SNES/SNESSetFromOptions.html">link</a>.</li>
<li>Options controlling line-searcher see <a href="http://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/SNES/SNESLineSearchSetFromOptions.html">link</a>.</li>
<li>Options controlling linear solver see <a href="http://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/KSP/KSPSetFromOptions.html">link</a>.</li>
</ul>
<p >Note that here the solved problem is strongly nonlinear, and we use secant line-search in the L2 norm (see <a href="http://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/SNES/SNESLINESEARCHL2.html">link</a>). For stability of the result at each Newton iteration, we execute three sub-iterations with line searcher. Also, you have the option of controlling the time step adaptively and linear solver pre-conditioner. All command line options, both PETSc and <a class="el" href="namespace_mo_f_e_m.html" title="implementation of Data Operators for Forces and Sources">MoFEM</a> are printed if you add switch <em>-help</em> when you run <a class="el" href="namespace_mo_f_e_m.html" title="implementation of Data Operators for Forces and Sources">MoFEM</a> application.</p>
<p ><a class="el" href="namespace_mo_f_e_m.html" title="implementation of Data Operators for Forces and Sources">MoFEM</a> specific options are</p>
<ul>
<li><em>-my_file</em> <em>out.h5m</em> set the name of the mesh file. Note that mesh has to be partitioned into a number of processors. <a class="el" href="namespace_mo_f_e_m.html" title="implementation of Data Operators for Forces and Sources">MoFEM</a> code is parallel.</li>
<li><em>-configure</em> <em>unsaturated.cfg</em> set the name of the material config file.</li>
<li><em>-my_order</em> <em>0</em> set the approximation order of the pressure head.</li>
<li><em>-how_often_output</em> <em>5</em> set how often you dump data on the hard drive. In this case, five means that file is dumped every fifth step.</li>
<li><em>-my_max_post_proc_ref_level</em> <em>0</em> set the post-processing mesh refinement level. If you are using higher order polynomial, higher than two, to resolve the solution on the mesh you can increase the refinement level. Note that the file size could increase significantly, therefore, it is not recommended to use this value higher that one.</li>
</ul>
<p >Finally, we can run the simulation by executing above the script </p><div class="fragment"><div class="line">cd /mofem_build/um/basic_finite_elements/mix_transport</div>
<div class="line">./run_uf.sh soil_impermeable.cub unsaturated.cfg 4 0.001 1 0</div>
</div><!-- fragment --><p> where</p><ul>
<li>the first parameter is the mesh file name</li>
<li>the second parameter is the material configuration name</li>
<li>third parameter is the number of processors which you want to use to run analysis</li>
<li>the fourth parameter sets the time step size</li>
<li>the fifth parameter sets the time of the simulation</li>
<li>the sixth parameter is the approximation order</li>
</ul>
<h3><a class="anchor" id="mix_us_flow_example_1_model_results"></a>
Results</h3>
<p >For the problem setup like above, results are shown in <a class="el" href="mix_us_flow.html#figure_1_unsaturated_flow_result_example1">Figure 1</a>, where the evolution of various parameters over time until equilibrium is reached is shown. You can note that initially, clay is relatively dry, whereas silt is wet. Over time, the clay sucks the water from the silt. On the left-hand side, we observe the distribution of saturation. Initially, high gradients of pressure head are created on the interface between the two materials. Those are captured very well, despite the coarse mesh, showing capabilities of the presented problem formulation. For creation of this figure we used the 2nd order of polynomial to approximate the pressure head and the 3rd order polynomial to approximate the fluxes.</p>
<p ><a class="anchor" id="figure_1_unsaturated_flow_result_example1"></a></p><div class="image">
<img src="unsaturated_flow_example_fig3.gif" alt="" width="900px"/>
<div class="caption">
Figure 1. On the bottom axis is depth, on the left axis is pressure head, right axis is water content. Red line is water head, green line is water content. Colormap on the left hand side is for saturation.</div></div>
<h2><a class="anchor" id="mix_us_flow_example_2"></a>
Numerical example 2</h2>
<p >In the second example, we show how to run downward infiltration problem with three layers, i.e. clay, silt and clay.</p>
<h3><a class="anchor" id="mix_us_flow_example_2_mesh"></a>
Mesh</h3>
<p >In the case above, we apply zero pressure head and the rest of the boundary is impermeable. See the following journal script to generate such a mesh </p><pre class="fragment">reset
# create body volume
brick x 0.01 y 0.002 z 0.1
move Volume all x 0 y 0 z -0.05 include_merged
brick x 0.1 y 0.06 z 0.02
move Volume 2  location volume 1  include_merged
chop volume 1 with volume 2
imprint volume all
merge volume all
# make block for clay
block 1 volume 4 5
block 1 name 'SOIL_CLAY1'
# make block for silt
block 2 volume 3
block 2 name 'SOIL_SILT2'
block 3 surface 1
block 3 name 'HEAD1'
block 3 attribute count 1
block 3 attribute index 1 0
# make mesh
volume all size auto factor 10
volume all scheme Tetmesh
mesh volume all
# refine mesh at interfaces between clay &amp; silt
refine surface 1 13 14 size 0.0025 bias 1.5 depth 1 smooth
</pre><p> Here we add the third block name HEAD1, where a boundary condition is applied. Similarly, non-zero fluxes can be applied by making a block with some surface elements and called it for example "FLUX1".</p>
<h3><a class="anchor" id="mix_us_flow_example_2_model_parameters"></a>
Model parameters</h3>
<p >The material parameters are similar to the ones given in the previous problem </p><pre class="fragment">[mat_block_1]
# VanGenuchten
# SimpleDarcy
material_name=VanGenuchten
# Default material for VanGenuchten is Clay (no need to set parameters if clay is used)
# Assumed units are in meters and days.

# Model parameters controlling convergence
sCale=1e6       # Scale mass conservation equation
ePsilon1=1e-5   # Minimal capacity when removing spurious oscillations in time

Ah=-9 # head suction at z = 0
AhZ=1 #�gradient of initial head suction
AhZZ=0 # initial head suction is calculated from equation h = Ah + AhZZ*z + AhZZ*zz

[mat_block_2]
material_name=VanGenuchten
# Material parameters for Silt from Vogel., van Genuchten Cislerova 2001
sCale=1e6
ePsilon1=1e-5
Ah=-9
AhZ=1
thetaS=0.46
thetaM=0.46
thetaR=0.034
alpha=1.6
n=1.37
Ks=0.006
hS=0

# You can change boundary conditions here
#[head_block_3]
#head = 0
</pre><p> Note that for this example we set initial pressure head distribution such that clay and silt are in equilibrium.  </p><p class="formulaDsp">
\[
\left\{
\begin{array}{ll}
h(z,t=0) = -9+z&amp;\textrm{for clay}\\
h(z,t=0) = -9+z&amp;\textrm{for silt}
\end{array}
\right.
\]
</p>
<p> Moreover at the end we show how to modify boundary condition. As an excrete one can change value of head on the top of the sample.</p>
<h3><a class="anchor" id="mix_us_flow_example_2_model_runig"></a>
Analysis</h3>
<p >We run script as before </p><div class="fragment"><div class="line">./run_uf.sh upward_infiltration.cub  unsaturated.cfg 4 0.001 1 0</div>
</div><!-- fragment --><h3><a class="anchor" id="mix_us_flow_example_2_model_results"></a>
Results</h3>
<p >For this example, we observe an influx of water into the column of the solid, we can plot how it is changing over time. At every time step, the solver monitor prints on the screen following lines </p><pre class="fragment">63 TS dt 0.00242774 time 0.0710581
Flux at time 0.07106 3.859e-07
    0 SNES Function norm 4.123926528377e-02
    1 SNES Function norm 6.552371691866e-02
    2 SNES Function norm 7.740255184123e-02
    3 SNES Function norm 7.999178179888e-02
    4 SNES Function norm 7.881110800442e-02
    5 SNES Function norm 7.582982118207e-02
    6 SNES Function norm 7.173427725809e-02
    7 SNES Function norm 6.666200930695e-02
    8 SNES Function norm 6.040633270649e-02
    9 SNES Function norm 5.232159632926e-02
   10 SNES Function norm 4.057267597689e-02
   11 SNES Function norm 1.625005251310e-02
   12 SNES Function norm 4.316837250846e-05
   13 SNES Function norm 8.980432593466e-07
  Nonlinear solve converged due to CONVERGED_FNORM_RELATIVE iterations 13
      TSAdapt 'basic': step  63 accepted t=0.0710581  + 2.428e-03 wlte=0.546 family='beuler' scheme=0:'' dt=2.627e-03
64 TS dt 0.00262737 time 0.0734859
Flux at time 0.07349 3.812e-07
    0 SNES Function norm 4.023589003253e-02
    1 SNES Function norm 6.962486297267e-02
    2 SNES Function norm 8.329691099303e-02
    3 SNES Function norm 8.641640743250e-02
    4 SNES Function norm 8.532070311444e-02
    5 SNES Function norm 8.223165652333e-02
    6 SNES Function norm 7.792739113001e-02
    7 SNES Function norm 7.257891287567e-02
    8 SNES Function norm 6.598809018682e-02
    9 SNES Function norm 5.751011198160e-02
   10 SNES Function norm 4.535116560548e-02
   11 SNES Function norm 2.147388609216e-02
   12 SNES Function norm 1.073710142541e-05
   13 SNES Function norm 4.011739514453e-11
  Nonlinear solve converged due to CONVERGED_FNORM_ABS iterations 13
      TSAdapt 'basic': step  64 accepted t=0.0734859  + 2.627e-03 wlte=0.588 family='beuler' scheme=0:'' dt=2.742e-03
</pre><p> where for step 63 and 64, total flux is printed in \(m^3/day\), </p><pre class="fragment">Flux at time 0.07106 3.859e-07
Flux at time 0.07349 3.812e-07
</pre><p> We can extract that information using awk/grep as follows </p><div class="fragment"><div class="line">awk <span class="stringliteral">&#39;/Flux at/ {print $4,$5/(0.01*0.002)}&#39;</span> log | tee gp</div>
</div><!-- fragment --><p >This shell command line takes all lines which have the phrase "Flux at", takes the fourth and the fifth columns from those lines, whereas fifth column is divided by area of the surface where the head is applied. Finally, results are stored in file <em>gp</em>. You can plot results in MS Excel or any other software, we choose to use gnuplot. As a result, we get <a class="el" href="mix_us_flow.html#figure_2_influx_of_water">Figure 2</a> below.</p>
<p ><a class="anchor" id="figure_2_influx_of_water"></a></p><div class="image">
<img src="unsaturated_flow_example_fig5.png" alt="" width="600px"/>
<div class="caption">
Figure 2. Influx of water for upward infiltration.</div></div>
<p >In <a class="el" href="mix_us_flow.html#figure_3_unsaturated_flow_result_example2">Figure 3</a> below, we can observe how the wetting front is moving downwards. Note how the gradient of head differs between clay and silt, and how it moves through the interface between materials.</p>
<p ><a class="anchor" id="figure_3_unsaturated_flow_result_example2"></a></p><div class="image">
<img src="unsaturated_flow_example_fig4.gif" alt="" width="900px"/>
<div class="caption">
Figure 3. On the bottom axis is depth, on the left axis is pressure head, right axis is water content. Red line is water head, green line is water content. Colormap on the left hand side is for saturation.</div></div>
<h1><a class="anchor" id="mix_us_flow_model"></a>
Mathematical model</h1>
<p >We consider porous material partially filled with water. In this tutorial, we are going to simulate water transport in such a system. The primary behaviour of the system depends on the material structure, capillary forces and the wetting angle, taken into account by experimentally estimated material parameters. Darcy's law gives the relation between flux and suction head (capillary pressure). Constitutive equations describe the relationship between hydraulic conductivity and water content. It is assumed that the state of the material is a function of water content, and using water retention curve one can map the between capillary head and the water content, i.e. \(\theta=\theta(h)\). The process of the water flow has to obey the conservation of mass, and consequently, the process of unsaturated transport is described by the parabolic differential equation.</p>
<h2><a class="anchor" id="mix_us_flow_pde"></a>
PDE</h2>
<p >The Richards equation describes the problem of unsaturated flow  </p><p class="formulaDsp">
\[
\frac{\partial \theta}{\partial t}-
\nabla \cdot \left[ \left( K(\theta)  \nabla ( h - z) \right) \right] = 0
\]
</p>
<p> where \(z\) is depth and \(K=K(\theta)\) is hydraulic conductivity. \(\nabla\) and \(\nabla \cdot\) are differential operators for gradient and divergence respectively. The above equation can alternatively be expressed by the system of first order partial differential equations  </p><p class="formulaDsp">
\[
\left\{
\begin{array}{l}
\frac{1}{K(\theta)}\boldsymbol\sigma + \nabla (h -z) = 0 \\
c(\theta)\frac{\partial h}{\partial t} - \nabla \cdot \boldsymbol\sigma = 0
\end{array}
\right.
\]
</p>
<p> where \(\boldsymbol\sigma\) is flux. The first equation expresses the constitutive relation while the second is the conservation law. The second equation is also called the continuity equation, and it does not allow for creation or annihilation of mass. The capacity term \(c\) in the second equation is given by  </p><p class="formulaDsp">
\[
c = \frac{\partial \theta}{\partial h}
\]
</p>
<h2><a class="anchor" id="mix_us_flow_physical_equation"></a>
Physical equations</h2>
<p >There exists semi-empirical relation between \(\theta\) and \(h\), called water retention curve, and for an unsaturated state one can uniquely map between the two when water retention hysteresis is not included. For simplicity here, we do not include hysteresis in our equations, and relations need to be established  </p><p class="formulaDsp">
\[
\left\{
\begin{array}{l}
\theta=\theta(h)\\
K = K(\theta)
\end{array}
\right.
\]
</p>
<p >Generic material model is implemented in <a class="el" href="struct_mix_transport_1_1_generic_material.html" title="Generic material model for unsaturated water transport.">MixTransport::GenericMaterial</a>, which is an abstract class, thus its instance cannot be created. This class sets methods and data used by finite element instances. It is not modified when a new material is implemented. This class is located in <a class="el" href="_unsaturated_flow_8hpp-example.html">UnsaturatedFlow.hpp</a>. To implement a new material model the user needs to implement this method</p>
<ul>
<li><a class="el" href="struct_mix_transport_1_1_generic_material.html#a65c262b2bb5b0d6582737403988f43e1">MixTransport::GenericMaterial::calK</a> to calculate hydraulic conductivity</li>
<li><a class="el" href="struct_mix_transport_1_1_generic_material.html#afa323157f62f91a087bf006eb3885035">MixTransport::GenericMaterial::calDiffK</a> to calculate hydraulic conductivity derivative of hydraulic conductivity (we show later how to calculate this derivative with automatic differentiation)</li>
<li><a class="el" href="struct_mix_transport_1_1_generic_material.html#a22bb876238fa08cb674ddeca52f8e642">MixTransport::GenericMaterial::calC</a> to collate capacity term</li>
<li><a class="el" href="struct_mix_transport_1_1_generic_material.html#a6c687c146cf3e7aaabf7202f63917352">MixTransport::GenericMaterial::calDiffC</a> to calculate capacity term derivative</li>
<li><a class="el" href="struct_mix_transport_1_1_generic_material.html#a3d6fe8a78c5886b7618a47eec7c8cbd0">MixTransport::GenericMaterial::calTheta</a> to calculate water content (this function is used for post-processing)</li>
<li><a class="el" href="struct_mix_transport_1_1_generic_material.html#a281c6e5f45ebae00b31702faa417528e">MixTransport::GenericMaterial::calSe</a> to calculate water saturation (this function is used for post-processing)</li>
</ul>
<p >From <a class="el" href="struct_mix_transport_1_1_generic_material.html" title="Generic material model for unsaturated water transport.">MixTransport::GenericMaterial</a>, the <a class="el" href="struct_mix_transport_1_1_common_material_data.html">MixTransport::CommonMaterialData</a> is derived. This class is unchanged if new material is implemented unless new material parameters need to be added to the model. Material parameters are read from text file given with command line option <em>-configure</em> <em>unsaturated.cfg</em>. <a class="el" href="struct_example.html" title="[Example]">Example</a> of such file looks as follows </p><pre class="fragment">[mat_block_1]
# VanGenuchten
# SimpleDarcy
material_name=VanGenuchten
# Default material for VanGenuchten is Clay (no need to set paramters if clay is used)
# Assumed usinits are in meters and days.

# Model parameters controlling convergence
sCale=1e6       # Scale mass conservation equation
ePsilon1=1e-5   # Minimal capacity when removing spurious oscillations in time

Ah=-9 # head suction at z = 0
AhZ=1 # gradient of initial head suction
AhZZ=0 # initial head suction is calculated from equation h = Ah + AhZZ*z + AhZZ*zz

[mat_block_2]
material_name=VanGenuchten
# Material parameters for Silt from Vogel., van Genuchten Cislerova 2001
sCale=1e6
ePsilon1=1e-5
Ah=-0.09
AhZ=1
thetaS=0.46
thetaM=0.46
thetaR=0.034
alpha=1.6
n=1.37
Ks=0.006
hS=0

# You can change boundary conditions here
#[head_block_3]
#head = 0
</pre><p >Note that we have two blocks, which are sets of elements on the mesh. To each block, we can attach material and set material parameters. A user can add more material parameters by declaring them in <a class="el" href="struct_mix_transport_1_1_common_material_data.html">MixTransport::CommonMaterialData</a> and adding them to method <a class="el" href="struct_mix_transport_1_1_common_material_data.html#acc5787a5ad5ecd36f318fb0e65ceca0b">MixTransport::CommonMaterialData::addOptions</a>, such that added material parameters are read from the configuration file.</p>
<p >For purposes of this tutorial we have implemented two material models, i.e. <a class="el" href="struct_mix_transport_1_1_material_darcy.html">MixTransport::MaterialDarcy</a> and <a class="el" href="struct_mix_transport_1_1_material_van_genuchten.html">MixTransport::MaterialVanGenuchten</a>, both classes are derived from <a class="el" href="struct_mix_transport_1_1_common_material_data.html">MixTransport::CommonMaterialData</a>.</p>
<h2><a class="anchor" id="mix_us_flow_physical_equation_adding_material"></a>
Adding new material</h2>
<p >The simplest method to implement new material is to derive class form <a class="el" href="struct_mix_transport_1_1_material_with_automatic_differentiation.html">MixTransport::MaterialWithAutomaticDifferentiation</a>, and add it to file MaterialUnsaturatedFlow.cpp. <a class="el" href="struct_mix_transport_1_1_material_with_automatic_differentiation.html">MixTransport::MaterialWithAutomaticDifferentiation</a> is a class to simplify implementation of the material model by utilizing advantages of automatic differentiation. Comprehensive description of library ADOL-C for automatic differentiation can be found here (<a href="https://projects.coin-or.org/ADOL-C/browser/stable/2.1/ADOL-C/doc/adolc-manual.pdf?format=raw">link</a>).</p>
<p >In principle automatic differentiation records mathematical operations in the function. Recorded mathematical operations are represented algorithmically in the tree, where each tree leaf is expanded into Taylor series, with sufficient order to calculate derivatives exactly. Automatic differentiation is different from symbolic differentiation, such that it can calculate derivatives of algorithm, so you can have loops and other commands in your differentiated function.</p>
<p >In consequence, user needs to build a tree to calculate water content density \(\theta=\theta(h)\) and relative hydraulic conductivity \(K_r=K_r(h)\). Using terminology from ADOL-C, one has to <em>record</em> <em>tape</em> with differentiated function. This is done by overloading two functions, <a class="el" href="struct_mix_transport_1_1_material_with_automatic_differentiation.html#afaa251a9aaa4bb2c0adae56b398373a3">MixTransport::MaterialWithAutomaticDifferentiation::recordTheta</a> and <a class="el" href="struct_mix_transport_1_1_material_with_automatic_differentiation.html#a4a664e2b5169d25420d2b020deacb483">MixTransport::MaterialWithAutomaticDifferentiation::recordKr</a>. For example </p><div class="fragment"><div class="line"><span class="keyword">struct </span>MyMaterialForUnsaturatedFlow: <span class="keyword">public</span> MaterialWithAutomaticDifferentiation {</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">static</span> boost::shared_ptr&lt;CommonMaterialData&gt; createMatPtr(<span class="keyword">const</span> CommonMaterialData &amp;data) {</div>
<div class="line">    <span class="keywordflow">return</span> boost::shared_ptr&lt;CommonMaterialData&gt;(<span class="keyword">new</span> MyMaterialForUnsaturatedFlow(data));</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    MyMaterialForUnsaturatedFlow(<span class="keyword">const</span> CommonMaterialData &amp;data):</div>
<div class="line">    MaterialWithAutomaticDifferentiation(data) {</div>
<div class="line">      recordTheta();</div>
<div class="line">      recordKr();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="classadouble.html">adouble</a> ah;</div>
<div class="line">    <a class="code hl_class" href="classadouble.html">adouble</a> aTheta;</div>
<div class="line">    <a class="code hl_class" href="classadouble.html">adouble</a> aKr;</div>
<div class="line">    <a class="code hl_class" href="classadouble.html">adouble</a> aSe;</div>
<div class="line">    <a class="code hl_class" href="classadouble.html">adouble</a> aSeStar;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TYPE&gt;</div>
<div class="line">    <span class="keyword">inline</span> TYPE funTheta(TYPE &amp;<a class="code hl_variable" href="photon__diffusion_8cpp.html#a8ee9be1b5aa75abae556de3088cba6d9">h</a>,<span class="keyword">const</span> <span class="keywordtype">double</span> <a class="code hl_variable" href="fluid__structure__eigenproblem_8cpp.html#aaeeb615e0d0b09b810b29ec6086e0112">m</a>) {</div>
<div class="line">      <span class="keywordflow">return</span> thetaR+(thetaS-thetaR)/pow(1+pow(-alpha*<a class="code hl_variable" href="photon__diffusion_8cpp.html#a8ee9be1b5aa75abae556de3088cba6d9">h</a>,<a class="code hl_variable" href="fluid__structure__eigenproblem_8cpp.html#a85adab6ee98bfcb82caccea618fde959">n</a>),<a class="code hl_variable" href="fluid__structure__eigenproblem_8cpp.html#aaeeb615e0d0b09b810b29ec6086e0112">m</a>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> recordTheta() {</div>
<div class="line">      trace_on(2*blockId+0,<span class="keyword">true</span>);</div>
<div class="line">      <a class="code hl_variable" href="photon__diffusion_8cpp.html#a8ee9be1b5aa75abae556de3088cba6d9">h</a> = -1-hS;</div>
<div class="line">      ah &lt;&lt;= <a class="code hl_variable" href="photon__diffusion_8cpp.html#a8ee9be1b5aa75abae556de3088cba6d9">h</a>;</div>
<div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> <a class="code hl_variable" href="fluid__structure__eigenproblem_8cpp.html#aaeeb615e0d0b09b810b29ec6086e0112">m</a> = 1-1/<a class="code hl_variable" href="fluid__structure__eigenproblem_8cpp.html#a85adab6ee98bfcb82caccea618fde959">n</a>;</div>
<div class="line">      aTheta = funTheta(ah,<a class="code hl_variable" href="fluid__structure__eigenproblem_8cpp.html#aaeeb615e0d0b09b810b29ec6086e0112">m</a>);</div>
<div class="line">      <span class="keywordtype">double</span> r_theta;</div>
<div class="line">      aTheta &gt;&gt;= r_theta;</div>
<div class="line">      trace_off();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> recordKr() {</div>
<div class="line">      trace_on(2*blockId+1,<span class="keyword">true</span>);</div>
<div class="line">      <a class="code hl_variable" href="photon__diffusion_8cpp.html#a8ee9be1b5aa75abae556de3088cba6d9">h</a> = -1-hS;</div>
<div class="line">      ah &lt;&lt;= <a class="code hl_variable" href="photon__diffusion_8cpp.html#a8ee9be1b5aa75abae556de3088cba6d9">h</a>;</div>
<div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> <a class="code hl_variable" href="fluid__structure__eigenproblem_8cpp.html#aaeeb615e0d0b09b810b29ec6086e0112">m</a> = 1-1/<a class="code hl_variable" href="fluid__structure__eigenproblem_8cpp.html#a85adab6ee98bfcb82caccea618fde959">n</a>;</div>
<div class="line">      aTheta = funTheta(ah,<a class="code hl_variable" href="fluid__structure__eigenproblem_8cpp.html#aaeeb615e0d0b09b810b29ec6086e0112">m</a>);</div>
<div class="line">      aSe = funSe(aTheta);</div>
<div class="line">      aKr = aSe*pow(1-pow(1-pow(Se,1/<a class="code hl_variable" href="fluid__structure__eigenproblem_8cpp.html#aaeeb615e0d0b09b810b29ec6086e0112">m</a>),<a class="code hl_variable" href="fluid__structure__eigenproblem_8cpp.html#aaeeb615e0d0b09b810b29ec6086e0112">m</a>),2);</div>
<div class="line">      <span class="keywordtype">double</span> r_Kr;</div>
<div class="line">      aKr &gt;&gt;= r_Kr;</div>
<div class="line">      trace_off();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">};</div>
<div class="ttc" id="aclassadouble_html"><div class="ttname"><a href="classadouble.html">adouble</a></div></div>
<div class="ttc" id="afluid__structure__eigenproblem_8cpp_html_a85adab6ee98bfcb82caccea618fde959"><div class="ttname"><a href="fluid__structure__eigenproblem_8cpp.html#a85adab6ee98bfcb82caccea618fde959">n</a></div><div class="ttdeci">FTensor::Index&lt; 'n', SPACE_DIM &gt; n</div><div class="ttdef"><b>Definition:</b> <a href="fluid__structure__eigenproblem_8cpp_source.html#l00066">fluid_structure_eigenproblem.cpp:66</a></div></div>
<div class="ttc" id="afluid__structure__eigenproblem_8cpp_html_aaeeb615e0d0b09b810b29ec6086e0112"><div class="ttname"><a href="fluid__structure__eigenproblem_8cpp.html#aaeeb615e0d0b09b810b29ec6086e0112">m</a></div><div class="ttdeci">FTensor::Index&lt; 'm', SPACE_DIM &gt; m</div><div class="ttdef"><b>Definition:</b> <a href="fluid__structure__eigenproblem_8cpp_source.html#l00065">fluid_structure_eigenproblem.cpp:65</a></div></div>
<div class="ttc" id="aphoton__diffusion_8cpp_html_a8ee9be1b5aa75abae556de3088cba6d9"><div class="ttname"><a href="photon__diffusion_8cpp.html#a8ee9be1b5aa75abae556de3088cba6d9">h</a></div><div class="ttdeci">double h</div><div class="ttdef"><b>Definition:</b> <a href="photon__diffusion_8cpp_source.html#l00060">photon_diffusion.cpp:60</a></div></div>
</div><!-- fragment --><p> where method <em>recordTheta</em> represents equation  </p><p class="formulaDsp">
\[
\theta = \theta_r + \frac{\theta_s-\theta_r}{(1+(-\alpha h)^n)^m}
\]
</p>
<p> and method <em>recordKr</em> represents equation  </p><p class="formulaDsp">
\[
K_r(S_e) = S_e\left[1-(1-S_e^{1/m})^m\right]^2
\]
</p>
<p> Note that \(h\) is an independent variable, whereas \(\theta\) and \(K_r\) are dependent variables. \(\alpha\), \(n\) and \(m\) are model parameters, for details see <a class="el" href="citelist.html#CITEREF_vogel2000effect">[50]</a>. Dissecting method <em>recordTheta</em>, we have </p><div class="fragment"><div class="line">trace_on(2*blockId+0,<span class="keyword">true</span>);<span class="comment"></span></div>
<div class="line"><span class="comment">/// Code here</span></div>
<div class="line"><span class="comment"></span>trace_off();</div>
</div><!-- fragment --><p> where we start and stop tape recording/tracing. Each tape has unique <em>Id</em>, in our case we have a convention that even <em>Id's</em> are used to record operations to calculate \(\theta\) and odd <em>Id's</em> are used to record \(K_r\). Each material block has own set of tapes since it uses unique material parameters and physical model has <em>Id</em> calculated from block number set on the mesh. In following code </p><div class="fragment"><div class="line"><a class="code hl_variable" href="photon__diffusion_8cpp.html#a8ee9be1b5aa75abae556de3088cba6d9">h</a> = -1-hS;</div>
<div class="line">ah &lt;&lt;= <a class="code hl_variable" href="photon__diffusion_8cpp.html#a8ee9be1b5aa75abae556de3088cba6d9">h</a>;</div>
<div class="line"><span class="comment">// Calculate aTheta  here</span></div>
<div class="line"><span class="keywordtype">double</span> r_theta;</div>
<div class="line">aTheta &gt;&gt;= r_theta;</div>
</div><!-- fragment --><p> we start by seeding point for which we build tree, \(h\) can be arbitrary but for the unsaturated state. Next, using "&lt;&lt;=" we set independent variable and using operator "&gt;&gt;=" to set dependent variable.</p>
<p >Finally new material model needs to be registered, by adding lines to the code as follows </p><div class="fragment"><div class="line"><span class="keyword">struct </span>RegisterMaterials {</div>
<div class="line">  <span class="keyword">static</span> map&lt;std::string,CommonMaterialData::RegisterHook&gt; mapOfRegistredMaterials;</div>
<div class="line">  MoFEMErrorCode operator()()<span class="keyword"> const </span>{</div>
<div class="line">    <a class="code hl_define" href="definitions_8h.html#aee32377dce975c9a64ed73bd3a003404">MoFEMFunctionBeginHot</a>;</div>
<div class="line">    mapOfRegistredMaterials[<span class="stringliteral">&quot;SimpleDarcy&quot;</span>] = MaterialDarcy::createMatPtr;</div>
<div class="line">    mapOfRegistredMaterials[<span class="stringliteral">&quot;VanGenuchten&quot;</span>] = MaterialVanGenuchten::createMatPtr;</div>
<div class="line">    mapOfRegistredMaterials[<span class="stringliteral">&quot;MyModel&quot;</span>] = MyMaterialForUnsaturatedFlow::createMatPtr;</div>
<div class="line">    <a class="code hl_define" href="definitions_8h.html#a59cd650c2f6d3e0dc1ad1c29821e8692">MoFEMFunctionReturnHot</a>(0);</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="ttc" id="adefinitions_8h_html_a59cd650c2f6d3e0dc1ad1c29821e8692"><div class="ttname"><a href="definitions_8h.html#a59cd650c2f6d3e0dc1ad1c29821e8692">MoFEMFunctionReturnHot</a></div><div class="ttdeci">#define MoFEMFunctionReturnHot(a)</div><div class="ttdoc">Last executable line of each PETSc function used for error handling. Replaces return()</div><div class="ttdef"><b>Definition:</b> <a href="definitions_8h_source.html#l00447">definitions.h:447</a></div></div>
<div class="ttc" id="adefinitions_8h_html_aee32377dce975c9a64ed73bd3a003404"><div class="ttname"><a href="definitions_8h.html#aee32377dce975c9a64ed73bd3a003404">MoFEMFunctionBeginHot</a></div><div class="ttdeci">#define MoFEMFunctionBeginHot</div><div class="ttdoc">First executable line of each MoFEM function, used for error handling. Final line of MoFEM functions ...</div><div class="ttdef"><b>Definition:</b> <a href="definitions_8h_source.html#l00440">definitions.h:440</a></div></div>
</div><!-- fragment --><h1><a class="anchor" id="mix_us_flow_numerical_model"></a>
Numerical model</h1>
<p >In the following, we apply mix-formulation, building on tutorial <a class="el" href="mix_transport.html">COR-0: Mixed formulation and integration on skeleton (h-adaptivity)</a>. We will show below that such approximation enables to solve Richards equation efficiently. This enables to address some issues of the regularity of the equations that are difficult to approximate for classical formulation of finite elements.</p>
<p >Mix-formulations allow converging to the solution faster than classical finite element formulation. Mix-elements have built-in error estimators into formulation allowing for efficient hp-adaptation and last but not least separation of nonlinearities, driving the development of effective solvers for strongly nonlinear problems.</p>
<h2><a class="anchor" id="mix_us_flow_numerical_mass"></a>
Conservation of mass</h2>
<p >Our PDE is system of two equations. The second equation is a universal law of the conservation of mass, which enforces continuity of fluxes, such that for an arbitrary surface \(\Gamma\) dividing body on two parts, that is \(\Omega = \Omega^1 \cup \Omega^2\)  </p><p class="formulaDsp">
\[
\mathbf{n}(\mathbf{x}) \cdot \left(
\boldsymbol\sigma^1(\mathbf{x}) -
\boldsymbol\sigma^2(\mathbf{x})
\right) = 0,\;\forall\mathbf{x}\in\Gamma
\]
</p>
<p> Utilizing this observation, we choose approximation base which <em>a</em> <em>priori</em> satisfies such continuity on element faces. However, it does not enforce continuity of tangential components on the element face, since those do not contribute to mass exchange on element faces. Such approximation base is constructed for Raviart Thomas elements. Here we are using the recipe from <a class="el" href="citelist.html#CITEREF_fuentes2015orientation">[26]</a> to construct arbitrary polynomial base order on elements, which <em>a</em> <em>priori</em> enforces continuity of fluxes.</p>
<p >The mass conservation in discrete form can be expressed as follows  </p><p class="formulaDsp">
\[
\left(v,c(\theta) \frac{\partial h}{\partial t}\right)_\Omega - (v,\boldsymbol\sigma)_\Omega = 0 \quad \forall v
\]
</p>
<p> We obtain this equation by multiplying mass conservation by test function \(v\) and integrating both sides. Tested and test base functions are \(h,v \in
L^2(\Omega)\), whereas \(\boldsymbol\sigma \in H(\nabla\cdot,\Omega)\) are divergence integrable functions which have been properly explained in the above paragraph. Here, we use the shorthand notation suitable for problems with many terms in the variational formulations. The first term reads  </p><p class="formulaDsp">
\[
\left(v,c(\theta) \frac{\partial h}{\partial t}\right)_\Omega =
\int_\Omega v c(\theta) \frac{\partial h}{\partial t} \textrm{d}\Omega
\]
</p>
<p> and other terms are expressed similarly.</p>
<h2><a class="anchor" id="mix_us_flow_numerical_physical"></a>
Physical equation</h2>
<p >The physical equation is the source of strong nonlinearities and problems with convergence of nonlinear solver and irregularities in the solution. We note that continuity of capillary head (capillary pressure) is not derived from conservation law, but dictated by the regularity of hydraulic conductivity \(K=K(\theta)\).</p>
<p >The philosophy of the finite element formulation presented here is to use approximation base having <em>a</em> <em>priory</em> continuity demanded by the conservation law, whereas not to enforce continuity of capillary pressure head, which is controlled by the regularity of a constitutive law. That allows developing a numerical model for the bigger class of materials, initial and boundary conditions, suitable for analysis of interface effects. Here, continuity of capillary pressure head is enforced <em>posterior</em>, as a consequence of assumed physical model.</p>
<p >Taking the physical equation and testing it with a test function \(\boldsymbol\tau \in H(\nabla\cdot,\Omega)\) we get  </p><p class="formulaDsp">
\[
\left(\boldsymbol\tau,\frac{1}{K(\theta)} \boldsymbol\sigma\right)_\Omega +
(\boldsymbol\tau,\nabla (h-z))_\Omega = 0 \quad \forall \boldsymbol\tau
\]
</p>
<p> next applying integration by parts we get  </p><p class="formulaDsp">
\[
\left(\boldsymbol\tau,\frac{1}{K(\theta)} \boldsymbol\sigma\right)_\Omega -
(\nabla \cdot \boldsymbol\tau,(h-z))_\Omega +
(\mathbf{n} \cdot \boldsymbol\tau,(\overline{h}-z))_{\partial\Omega} = 0
\]
</p>
<p> where \(\overline{h}\) is the prescribed capillary pressure on the boundary. Note that</p>
<ul>
<li>Boundary conditions on the capillary head are natural boundary conditions, enforced <em>posterior</em>, i.e. once a system of equations is solved.</li>
<li>We do not calculate derivatives over \(h\) and \(v\), and those functions can belong to \(L^2(\Omega)\) space.</li>
<li>The regularity of solution is controlled by \(K(\theta)\), that for most real materials will imply continuity of the capillary head, in particular at the interface between them. However, in some cases, the changes of the head are so sharp that it is beneficial to use mix-formulation.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>This equation is irregular, hydraulic conductivity can change sharply, as a function of the capillary head. The problem can be regularized by applying Kirchhoff transform, see details here <a class="el" href="citelist.html#CITEREF_radu2004order">[40]</a>. However such approach is limited, and can be applied for special cases, in particular when no hysteresis is considered. Applying Kirchhoff transform, for steady case problem, transforms a nonlinear problem to a linear problem, and not steady case problem still has a nonlinear capacity term. Such approach enables to calculate large scale problems for unsaturated soils and is highly recommended to be implemented here as an alternative approach.</dd></dl>
<h2><a class="anchor" id="mix_us_flow_numerical_discretisation"></a>
Semi-discrete linearized system of equations</h2>
<p >In <a class="el" href="namespace_mo_f_e_m.html" title="implementation of Data Operators for Forces and Sources">MoFEM</a> we do not implement our own Newton method, but use one implemented in PETSc. PETSc Newton solver is implemented in a package of nonlinear solvers SNES. In the nonlinear time dependent problem, SNES is called by TS (time solver). Here we focus on the calculation of residual vector and tangent matrix.</p>
<p >In this section, we focus your attention on discretization in space, without restricting yourself to the particular time integration scheme. That is exclusively managed by TS solver from PETSc. As the title of this section indicates, this formulation is semi-discrete. We apply discretization in space here, but we assume that the function in time is given by some unknown analytical function.</p>
<p >Above we put physical justification for using particular spaces for fluxes, which is \(\boldsymbol\tau,\boldsymbol\sigma \in H(\nabla\cdot,\Omega)\), and capillary pressure head \(u,h \in L^2(\Omega)\). One can show that selection of such approximation spaces is stable, once the problem is discretized (i.e. finite element approximation spaces are used). Numerical solution is stable since the choice of approximation spaces complies with De Rham diagram.</p>
<p >To solve the problem we define residuals  </p><p class="formulaDsp">
\[
\left\{
\begin{array}{l}
r_\tau = (\boldsymbol\tau,\frac{1}{K(\theta)} \boldsymbol\sigma)_\Omega -
(\nabla \cdot \boldsymbol\tau,(h-z))_\Omega +
(\mathbf{n} \cdot \boldsymbol\tau,(\overline{h}-z))_{\partial\Omega}\\
r_v = (v,c(\theta) \frac{\partial h}{\partial t})_\Omega - (v,\boldsymbol\sigma)_\Omega
\end{array}
\right.
\]
</p>
<p> Applying standard procedure where one solves nonlinear system of equations, we expand both equations into Taylor series, for terms \(\boldsymbol\sigma\), \(h\) and \(\frac{\partial h}{\partial t}\), since we have a time dependent problem. Truncating the Taylor series after linear term, we get  </p><p class="formulaDsp">
\[
\left\{
\begin{array}{l}
r^i_\tau + (\boldsymbol\tau,\frac{1}{K^i} \delta\boldsymbol\sigma^{i+1})_\Omega -
(\nabla \cdot \boldsymbol\tau,\delta h^{i+1})_\Omega +
(\boldsymbol\tau,\frac{\textrm{d}K}{\textrm{d}\theta}|^i\frac{\textrm{d}\theta}{\textrm{d}h}|^i(K^i)^{-2} \boldsymbol\sigma^i) \delta h^{i+1})_\Omega
 = 0\\
r_v^i +
(v,c^i\frac{\partial \delta h}{\partial t}|^{i+1})_\Omega +
(v,\frac{\textrm{d}c}{\textrm{d}\theta}|^i\frac{\textrm{d}\theta}{\textrm{d}h}|^i \frac{\partial h}{\partial t}|^i) \delta h^{i+1})_\Omega -
(v,\delta\boldsymbol\sigma^{i+1})_\Omega = 0
\end{array}
\right.
\]
</p>
<p> where \(i\) is Newton iteration number. Note that tangent matrices and residuals are evaluated at known iteration \(i\) and unknowns are solved for iteration \(i+1\). Iterations are repeated until the residuals are small in the absolute or relative norm. Once we achieve equilibrium we move to the next time step.</p>
<p >Expressing test and tested function by vectors of basis functions and vectors of degrees of freedom, we have  </p><p class="formulaDsp">
\[
\boldsymbol\sigma^i_n(\mathbf{x}) = \boldsymbol \phi^\textrm{T}(\mathbf{x}) \mathbf{q}^i_n,\;
h^i_n(\mathbf{x},t_n) = \boldsymbol \psi^\textrm{T}(\mathbf{x},t_n) \mathbf{p}^i_n
\]
</p>
<p> where base vectors \(\boldsymbol \phi\) and \(\boldsymbol \psi\) are for H-div and L2 space respectively. \(n\) is time step. Finally, we get system of linear equations  </p><p class="formulaDsp">
\[
\left[
\begin{array}{cc}
\mathbf{C} &amp; \mathbf{G} \\
\mathbf{H} &amp; \mathbf{A}
\end{array}
\right]
\left\{
\begin{array}{c}
\delta \mathbf{q}^{i+1}\\
\delta \mathbf{p}^{i+1}
\end{array}
\right\}
=
\left[
\begin{array}{c}
\mathbf{r}^i_\tau\\
\mathbf{r}^i_v
\end{array}
\right]
\]
</p>
<p> where vectors of unknowns are updated as follows  </p><p class="formulaDsp">
\[
\mathbf{q}^{i+1}_{n+1} = \mathbf{q}_n + \Delta \mathbf{q}_{n+1}^i + \delta \mathbf{q}^{i+1}\quad
\mathbf{p}^{i+1}_{n+1} = \mathbf{p}_n + \Delta \mathbf{p}_{n+1}^i + \delta \mathbf{p}^{i+1}
\]
</p>
<p >Tangent matrices and vectors are implemented in following operators</p>
<ul>
<li>In operators <a class="el" href="struct_mix_transport_1_1_unsaturated_flow_element_1_1_op_residual_flux.html" title="Assemble flux residual.">MixTransport::UnsaturatedFlowElement::OpResidualFlux</a> and <a class="el" href="struct_mix_transport_1_1_unsaturated_flow_element_1_1_op_rhs_bc_on_values.html" title="Evaluate boundary condition at the boundary.">MixTransport::UnsaturatedFlowElement::OpRhsBcOnValues</a>, we implemented \(\mathbf{r}^\textrm{internal}_\tau\) and \(\mathbf{f}^\textrm{external}_\tau\), respectively.  <p class="formulaDsp">
\[
  \mathbf{r}_\tau = \mathbf{r}^\textrm{internal}_\tau + \mathbf{f}^\textrm{external}_\tau =
  (\boldsymbol\phi^\textrm{T},\frac{1}{K^i} \boldsymbol\sigma^i)_\Omega -
  (\nabla \cdot \boldsymbol\phi^\textrm{T},(h^i-z))_\Omega +
  (\mathbf{n} \cdot \boldsymbol\phi^\textrm{T},(\overline{h}-z))_{\partial\Omega}
  \]
</p>
</li>
<li>In operator <a class="el" href="struct_mix_transport_1_1_unsaturated_flow_element_1_1_op_residual_mass.html">MixTransport::UnsaturatedFlowElement::OpResidualMass</a> is implemented  <p class="formulaDsp">
\[
  \mathbf{r}_v =
  (\boldsymbol\psi^\textrm{T},c(\theta) \frac{\partial h}{\partial t}|^i)_\Omega - (\boldsymbol\psi^\textrm{T},\boldsymbol\sigma^i)_\Omega
  \]
</p>
</li>
<li>In <a class="el" href="struct_mix_transport_1_1_unsaturated_flow_element_1_1_op_tau_dot_sigma___hdiv_hdiv.html">MixTransport::UnsaturatedFlowElement::OpTauDotSigma_HdivHdiv</a> is implemented  <p class="formulaDsp">
\[
  \mathbf{A} = (\boldsymbol\phi^\textrm{T},\frac{1}{K^i} \boldsymbol\phi)_\Omega
  \]
</p>
</li>
<li>In operator <a class="el" href="struct_mix_transport_1_1_unsaturated_flow_element_1_1_op_v_u___l2_l2.html">MixTransport::UnsaturatedFlowElement::OpVU_L2L2</a> is implemented  <p class="formulaDsp">
\[
  \mathbf{C} =
  (\boldsymbol\psi^\textrm{T},c^i \frac{\partial \boldsymbol\psi}{\partial t})_\Omega +
  (\boldsymbol\psi^\textrm{T},\frac{\textrm{d}c}{\textrm{d}\theta}|^i\frac{\textrm{d}\theta}{\textrm{d}h}|^i \frac{\partial h}{\partial t}|^i \boldsymbol\psi)_\Omega
  \]
</p>
</li>
<li>In operator <a class="el" href="struct_mix_transport_1_1_unsaturated_flow_element_1_1_op_v_div_sigma___l2_hdiv.html">MixTransport::UnsaturatedFlowElement::OpVDivSigma_L2Hdiv</a> is implemented  <p class="formulaDsp">
\[
  \mathbf{H}=-(\nabla \cdot \boldsymbol\phi^\textrm{T},\boldsymbol\psi)_\Omega +
  (\boldsymbol\phi^\textrm{T},\frac{\textrm{d}K}{\textrm{d}\theta}|^i\frac{\textrm{d}\theta}{\textrm{d}h}|^i(K^i)^{-2} \boldsymbol\sigma^i) \boldsymbol\psi)_\Omega
  \]
</p>
</li>
<li>In operator <a class="el" href="struct_mix_transport_1_1_unsaturated_flow_element_1_1_op_div_tau_u___hdiv_l2.html">MixTransport::UnsaturatedFlowElement::OpDivTauU_HdivL2</a> is implemented <p class="formulaDsp">
\[\mathbf{G} = (\boldsymbol\psi^\textrm{T},\boldsymbol\phi)_\Omega\]
</p>
</li>
</ul>
<h2><a class="anchor" id="mix_us_flow_time_discretistion"></a>
Time discretization</h2>
<p >In <a class="el" href="namespace_mo_f_e_m.html" title="implementation of Data Operators for Forces and Sources">MoFEM</a>, we do not implement time discretization algorithms unless we would like to do something novel and non-standard, and we would rather recommend implementing such an algorithm using PETSc time solver shell rather than doing so directly in <a class="el" href="namespace_mo_f_e_m.html" title="implementation of Data Operators for Forces and Sources">MoFEM</a>. Detailed description of how to use time solver (TS) in PETSc can be found in <a href="http://www.mcs.anl.gov/petsc/petsc-current/docs/manual.pdf">link</a>, see chapter 6.</p>
<p >The constructions of time discretized problem are managed transparently for the user. If you are interested in details, see <a class="el" href="struct_mo_f_e_m_1_1_ts_ctx.html" title="Interface for Time Stepping (TS) solver.">MoFEM::TsCtx</a> class and auxiliary functions like <a class="el" href="namespace_mo_f_e_m.html#a65f22030e64fd429012bf8f0f025d9a1" title="Set IFunction for TS solver.">MoFEM::TsSetIFunction</a>, <a class="el" href="namespace_mo_f_e_m.html#a12477157e716aece7dd7b3e316fef7a3" title="Set function evaluating jacobina in TS solver.">MoFEM::TsSetIJacobian</a> and <a class="el" href="namespace_mo_f_e_m.html#a1654dd29ff9af437332ec55af104ff48" title="Set monitor for TS solver.">MoFEM::TsMonitorSet</a>. Those functions are called by the discrete manager (DM) which is linked to time solver.</p>
<p >In the previous section, we transform PDE, by applying space discretization, into the system of linearized ordinary differential equations (ODE). In the following description, we transform the system of ODEs into a system of linear equations. In our particular problem, we need to calculate the rate of capillary head, which is discretized in time and space by  </p><p class="formulaDsp">
\[
h(\mathbf{x},t) =
\boldsymbol \psi(\mathbf{x},t)^\textrm{T} \mathbf{p} =
[\boldsymbol \xi(t).\boldsymbol{\tilde{\psi}}(\mathbf{x})]^\textrm{T} \mathbf{p}
\]
</p>
<p> where \([\xi(t).\boldsymbol{\tilde{\psi}}(\mathbf{x})]\) is element by element product of two vectors. With that at hand we can calculate rate of hydraulic head  </p><p class="formulaDsp">
\[
\frac{\partial h}{\partial t}(\mathbf{x},t) =
\left[
\frac{\textrm{d}\boldsymbol\xi}{\textrm{d}t} (t).\boldsymbol{\tilde{\psi}}(\mathbf{x})
\right]^\textrm{T} \mathbf{p}
\]
</p>
<p> With above at hand, matrix \(\mathbf{C}\) where time derivative is present has the following form  </p><p class="formulaDsp">
\[
\mathbf{C} =
\left(\boldsymbol\psi^\textrm{T},
\left(
c^i
\frac{\partial \boldsymbol\xi}{\partial t}+
\frac{\textrm{d}c}{\textrm{d}\theta}|^i\frac{\textrm{d}\theta}{\textrm{d}h}|^i \frac{\partial h}{\partial t}|^i
\right)
\boldsymbol{\tilde\psi}\right)_\Omega
\]
</p>
<p> Note that for any ODE integration method, the approximation of \(\frac{\partial h}{\partial t}\) is by linear function, hence  </p><p class="formulaDsp">
\[
\frac{\partial \boldsymbol\xi}{\partial t} = (shift)
\]
</p>
<p> For example, iterative change of capillary pressure head, when backwards Euler's method is applied, \((shift) = 1/\Delta t\), what can be derived as follows  </p><p class="formulaDsp">
\[
\left(\frac{\partial \delta h}{\partial t}\right)^{i+1}_{n+1} =
\left(\frac{\partial \delta h}{\partial \delta \mathbf{p}}\frac{\partial \delta \mathbf{p}}{\partial t} \right)^{i+1}_{n+1} =
\left( \boldsymbol{\tilde \psi} \delta \mathbf{p}^{i+1}\right) \left( 1/\Delta t \right)
=
\left( \boldsymbol{\tilde \psi} \delta \mathbf{p}^{i+1} \right) (shift)
\]
</p>
<p> Such an approach allows for code generalisation such that finite element formulation which concerns discretization in space, does not depend on discretization in time. That makes it possible to switch between time integration schemes without changing implementation, see list of time integration schemes in <a href="http://www.mcs.anl.gov/petsc/petsc-current/docs/manual.pdf">link</a>, table 10.</p>
<p >Above is exploited in <a class="el" href="struct_mix_transport_1_1_unsaturated_flow_element_1_1_op_v_u___l2_l2.html#a70da7c66957d9aaeebac3b1cdc11e451">MixTransport::UnsaturatedFlowElement::OpVU_L2L2::doWork</a>, where shift is applied at integration points as follows </p><div class="fragment"><div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">int</span> gg = 0;gg!=nb_gauss_pts;gg++) {</div>
<div class="line">  <span class="comment">// get integration weight and multiply by element volume</span></div>
<div class="line">  <span class="keywordtype">double</span> alpha = t_w*vol*<a class="code hl_variable" href="plastic_8cpp.html#a80d402d10e8341004c0caf10133b80ab">scale</a>;</div>
<div class="line">  <span class="comment">// evaluate material model at integration points</span></div>
<div class="line">  <span class="comment">// to calculate capacity and tangent of capacity term</span></div>
<div class="line">  block_data-&gt;h = t_h;</div>
<div class="line">  block_data-&gt;h_t = t_h_t;</div>
<div class="line">  block_data-&gt;x = t_coords(0);</div>
<div class="line">  block_data-&gt;y = t_coords(1);</div>
<div class="line">  block_data-&gt;z = t_coords(2);</div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> block_data-&gt;calC(); </div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> block_data-&gt;calDiffC(); </div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> C = block_data-&gt;C;</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> diffC = block_data-&gt;diffC;</div>
<div class="line">  <span class="comment">// assemble local entity tangent matrix</span></div>
<div class="line">  <a class="code hl_class" href="class_f_tensor_1_1_tensor0.html">FTensor::Tensor0&lt;double*&gt;</a> t_a(&amp;*nN.data().begin());</div>
<div class="line">  <span class="comment">// iterate base functions on rows</span></div>
<div class="line">  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> kk = 0;kk!=nb_row;kk++) {</div>
<div class="line">    <span class="comment">// get first base function on column at integration point gg</span></div>
<div class="line">    <a class="code hl_class" href="class_f_tensor_1_1_tensor0.html">FTensor::Tensor0&lt;double*&gt;</a> t_n_col = col_data.getFTensor0N(gg,0);</div>
<div class="line">    <span class="comment">// iterate base functions on columns</span></div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ll = 0;ll!=nb_col;ll++) {</div>
<div class="line">      <span class="comment">// assemble elements of local matrix</span></div>
<div class="line">      t_a += (alpha*(C*ts_a+diffC*t_h_t))*t_n_row*t_n_col;</div>
<div class="line">      ++t_n_col;  <span class="comment">// move to next base function on column</span></div>
<div class="line">      ++t_a; <span class="comment">// move to next element in local tangent matrix</span></div>
<div class="line">    }</div>
<div class="line">    ++t_n_row; <span class="comment">// move to next base function on row</span></div>
<div class="line">  }</div>
<div class="line">  ++t_w;      <span class="comment">// move to next integration weight</span></div>
<div class="line">  ++t_coords; <span class="comment">// move to next coordinate at integration point</span></div>
<div class="line">  ++t_h;      <span class="comment">// move to next capillary head at integration point</span></div>
<div class="line">  ++t_h_t;    <span class="comment">// move to next capillary head rate at integration point</span></div>
<div class="line">}</div>
<div class="ttc" id="aclass_f_tensor_1_1_tensor0_html"><div class="ttname"><a href="class_f_tensor_1_1_tensor0.html">FTensor::Tensor0</a></div><div class="ttdef"><b>Definition:</b> <a href="_tensor0_8hpp_source.html#l00016">Tensor0.hpp:17</a></div></div>
<div class="ttc" id="adefinitions_8h_html_add80e5ef5f847b2d4b637029f0f671c3"><div class="ttname"><a href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a></div><div class="ttdeci">#define CHKERR</div><div class="ttdoc">Inline error check.</div><div class="ttdef"><b>Definition:</b> <a href="definitions_8h_source.html#l00535">definitions.h:535</a></div></div>
<div class="ttc" id="aplastic_8cpp_html_a80d402d10e8341004c0caf10133b80ab"><div class="ttname"><a href="plastic_8cpp.html#a80d402d10e8341004c0caf10133b80ab">scale</a></div><div class="ttdeci">double scale</div><div class="ttdef"><b>Definition:</b> <a href="plastic_8cpp_source.html#l00166">plastic.cpp:166</a></div></div>
</div><!-- fragment --><p> where \(\textrm{ts_a} = (shift)\). Note that evaluation of capillary head DOFs, i.e. \(\frac{\partial \mathbf{p}}{\partial t}\) is managed exclusively by PETSc and depends on used time integration shame.</p>
<h1><a class="anchor" id="mix_us_flow_implemntation"></a>
Implementation</h1>
<h2><a class="anchor" id="mix_us_flow_declarations"></a>
Declaration of fields, finite elements and problem</h2>
<p >In method <a class="el" href="struct_mix_transport_1_1_unsaturated_flow_element.html#a6575c02eb2a321533d18b6ae4f381034" title="add fields">MixTransport::UnsaturatedFlowElement::addFields</a>, we declare and define fields on entities and set order of approximation as follows </p><div class="fragment"><div class="line"><span class="comment">//Fields</span></div>
<div class="line"><a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> mField.add_field(fluxes,<a class="code hl_enumvalue" href="definitions_8h.html#a5ed4cb303bab8cd0673ae12e5bc73c12ab360a65247d7fe5efc6f3a533d47e5c8">HDIV</a>,<a class="code hl_enumvalue" href="definitions_8h.html#a2ed4ed94b56d2843840bb7c55adcf0c5a9b4f9fbc1a88eda9b2cde0df10ca23bf">DEMKOWICZ_JACOBI_BASE</a>,1); </div>
<div class="line"><a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> mField.add_field(values,<a class="code hl_enumvalue" href="definitions_8h.html#a5ed4cb303bab8cd0673ae12e5bc73c12a0adffb24dae0c41be5b803f4d444f066">L2</a>,<a class="code hl_enumvalue" href="definitions_8h.html#a2ed4ed94b56d2843840bb7c55adcf0c5a54a26843865f4712f50a74fa4f8d025d">AINSWORTH_LEGENDRE_BASE</a>,1); </div>
<div class="line"><a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> mField.add_field(values+<span class="stringliteral">&quot;_t&quot;</span>,<a class="code hl_enumvalue" href="definitions_8h.html#a5ed4cb303bab8cd0673ae12e5bc73c12a0adffb24dae0c41be5b803f4d444f066">L2</a>,<a class="code hl_enumvalue" href="definitions_8h.html#a2ed4ed94b56d2843840bb7c55adcf0c5a54a26843865f4712f50a74fa4f8d025d">AINSWORTH_LEGENDRE_BASE</a>,1); </div>
<div class="line"><span class="comment">//add entities to field</span></div>
<div class="line"><span class="keywordflow">for</span>(<a class="code hl_define" href="group__mofem__meshset__mng.html#gaff36ed0367e6b0a57541419546aa1323">_IT_CUBITMESHSETS_BY_SET_TYPE_FOR_LOOP_</a>(mField,<a class="code hl_enumvalue" href="definitions_8h.html#a82340fd7aca566defb002f93cc299efcac77b6cdcfb446c668fd1d7c66cfd15ab">BLOCKSET</a>,it)) {</div>
<div class="line">  <span class="keywordflow">if</span>(it-&gt;getName().compare(0,4,<span class="stringliteral">&quot;SOIL&quot;</span>)!=0) <span class="keywordflow">continue</span>;</div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> mField.add_ents_to_field_by_type(</div>
<div class="line">    dMatMap[it-&gt;getMeshsetId()]-&gt;tEts,MBTET,fluxes</div>
<div class="line">  ); </div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> mField.add_ents_to_field_by_type(</div>
<div class="line">    dMatMap[it-&gt;getMeshsetId()]-&gt;tEts,MBTET,values</div>
<div class="line">  ); </div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> mField.add_ents_to_field_by_type(</div>
<div class="line">    dMatMap[it-&gt;getMeshsetId()]-&gt;tEts,MBTET,values+<span class="stringliteral">&quot;_t&quot;</span></div>
<div class="line">  ); </div>
<div class="line">}</div>
<div class="line"><a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> mField.set_field_order(0,MBTET,fluxes,<a class="code hl_variable" href="dg__projection_8cpp.html#ad7eceded84ace5678d9df3e44f47d475">order</a>+1); </div>
<div class="line"><a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> mField.set_field_order(0,MBTRI,fluxes,<a class="code hl_variable" href="dg__projection_8cpp.html#ad7eceded84ace5678d9df3e44f47d475">order</a>+1); </div>
<div class="line"><a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> mField.set_field_order(0,MBTET,values,<a class="code hl_variable" href="dg__projection_8cpp.html#ad7eceded84ace5678d9df3e44f47d475">order</a>); </div>
<div class="line"><a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> mField.set_field_order(0,MBTET,values+<span class="stringliteral">&quot;_t&quot;</span>,<a class="code hl_variable" href="dg__projection_8cpp.html#ad7eceded84ace5678d9df3e44f47d475">order</a>); </div>
<div class="ttc" id="adefinitions_8h_html_a2ed4ed94b56d2843840bb7c55adcf0c5a54a26843865f4712f50a74fa4f8d025d"><div class="ttname"><a href="definitions_8h.html#a2ed4ed94b56d2843840bb7c55adcf0c5a54a26843865f4712f50a74fa4f8d025d">AINSWORTH_LEGENDRE_BASE</a></div><div class="ttdeci">@ AINSWORTH_LEGENDRE_BASE</div><div class="ttdoc">Ainsworth Cole (Legendre) approx. base .</div><div class="ttdef"><b>Definition:</b> <a href="definitions_8h_source.html#l00061">definitions.h:60</a></div></div>
<div class="ttc" id="adefinitions_8h_html_a2ed4ed94b56d2843840bb7c55adcf0c5a9b4f9fbc1a88eda9b2cde0df10ca23bf"><div class="ttname"><a href="definitions_8h.html#a2ed4ed94b56d2843840bb7c55adcf0c5a9b4f9fbc1a88eda9b2cde0df10ca23bf">DEMKOWICZ_JACOBI_BASE</a></div><div class="ttdeci">@ DEMKOWICZ_JACOBI_BASE</div><div class="ttdef"><b>Definition:</b> <a href="definitions_8h_source.html#l00067">definitions.h:66</a></div></div>
<div class="ttc" id="adefinitions_8h_html_a5ed4cb303bab8cd0673ae12e5bc73c12a0adffb24dae0c41be5b803f4d444f066"><div class="ttname"><a href="definitions_8h.html#a5ed4cb303bab8cd0673ae12e5bc73c12a0adffb24dae0c41be5b803f4d444f066">L2</a></div><div class="ttdeci">@ L2</div><div class="ttdoc">field with C-1 continuity</div><div class="ttdef"><b>Definition:</b> <a href="definitions_8h_source.html#l00088">definitions.h:88</a></div></div>
<div class="ttc" id="adefinitions_8h_html_a5ed4cb303bab8cd0673ae12e5bc73c12ab360a65247d7fe5efc6f3a533d47e5c8"><div class="ttname"><a href="definitions_8h.html#a5ed4cb303bab8cd0673ae12e5bc73c12ab360a65247d7fe5efc6f3a533d47e5c8">HDIV</a></div><div class="ttdeci">@ HDIV</div><div class="ttdoc">field with continuous normal traction</div><div class="ttdef"><b>Definition:</b> <a href="definitions_8h_source.html#l00087">definitions.h:87</a></div></div>
<div class="ttc" id="adefinitions_8h_html_a82340fd7aca566defb002f93cc299efcac77b6cdcfb446c668fd1d7c66cfd15ab"><div class="ttname"><a href="definitions_8h.html#a82340fd7aca566defb002f93cc299efcac77b6cdcfb446c668fd1d7c66cfd15ab">BLOCKSET</a></div><div class="ttdeci">@ BLOCKSET</div><div class="ttdef"><b>Definition:</b> <a href="definitions_8h_source.html#l00148">definitions.h:148</a></div></div>
<div class="ttc" id="adg__projection_8cpp_html_ad7eceded84ace5678d9df3e44f47d475"><div class="ttname"><a href="dg__projection_8cpp.html#ad7eceded84ace5678d9df3e44f47d475">order</a></div><div class="ttdeci">constexpr int order</div><div class="ttdef"><b>Definition:</b> <a href="dg__projection_8cpp_source.html#l00018">dg_projection.cpp:18</a></div></div>
<div class="ttc" id="agroup__mofem__meshset__mng_html_gaff36ed0367e6b0a57541419546aa1323"><div class="ttname"><a href="group__mofem__meshset__mng.html#gaff36ed0367e6b0a57541419546aa1323">_IT_CUBITMESHSETS_BY_SET_TYPE_FOR_LOOP_</a></div><div class="ttdeci">#define _IT_CUBITMESHSETS_BY_SET_TYPE_FOR_LOOP_(MESHSET_MANAGER, CUBITBCTYPE, IT)</div><div class="ttdoc">Iterator that loops over a specific Cubit MeshSet having a particular BC meshset in a moFEM field.</div><div class="ttdef"><b>Definition:</b> <a href="_meshsets_manager_8hpp_source.html#l00071">MeshsetsManager.hpp:71</a></div></div>
</div><!-- fragment --><p> Note that we set field space independently from the approximation base. We can have different recipes to construct approximation base, for example <a class="el" href="citelist.html#CITEREF_NME:NME847">[1]</a> and <a class="el" href="citelist.html#CITEREF_fuentes2015orientation">[26]</a>. Note, to get a solvable system of linear equations, the pressure head approximation is one order lower than the approximation for fluxes. Here for simplicity, we set homogeneous approximation order, however, implementation can be easily extended to the case where approximation order is locally increased near interfaces or boundary where pressure head is applied.</p>
<p >In a similar way, we declare and define finite elements in <a class="el" href="struct_mix_transport_1_1_unsaturated_flow_element.html#ad8e71d2842b2665c490ef80a279b21b4" title="add finite elements">MixTransport::UnsaturatedFlowElement::addFiniteElements</a>, as follows </p><div class="fragment"><div class="line"><span class="comment">// Define element &quot;MIX&quot;. Note that this element will work with fluxes_name and</span></div>
<div class="line"><span class="comment">// values_name. This reflect bilinear form for the problem</span></div>
<div class="line"><a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> mField.add_finite_element(<span class="stringliteral">&quot;MIX&quot;</span>,<a class="code hl_enumvalue" href="definitions_8h.html#a2c740dc34f8edf00c432912eaa5484c1a0bb920c38e835e0fbae45b0c0c029264">MF_ZERO</a>); </div>
<div class="line"><a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> mField.modify_finite_element_add_field_row(<span class="stringliteral">&quot;MIX&quot;</span>,fluxes_name); </div>
<div class="line"><a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> mField.modify_finite_element_add_field_col(<span class="stringliteral">&quot;MIX&quot;</span>,fluxes_name); </div>
<div class="line"><a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> mField.modify_finite_element_add_field_row(<span class="stringliteral">&quot;MIX&quot;</span>,values_name); </div>
<div class="line"><a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> mField.modify_finite_element_add_field_col(<span class="stringliteral">&quot;MIX&quot;</span>,values_name); </div>
<div class="line"><a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> mField.modify_finite_element_add_field_data(<span class="stringliteral">&quot;MIX&quot;</span>,fluxes_name); </div>
<div class="line"><a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> mField.modify_finite_element_add_field_data(<span class="stringliteral">&quot;MIX&quot;</span>,values_name); </div>
<div class="line"><a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> mField.modify_finite_element_add_field_data(<span class="stringliteral">&quot;MIX&quot;</span>,values_name+<span class="stringliteral">&quot;_t&quot;</span>); </div>
<div class="line"><span class="keywordflow">for</span>(<a class="code hl_define" href="group__mofem__meshset__mng.html#gaff36ed0367e6b0a57541419546aa1323">_IT_CUBITMESHSETS_BY_SET_TYPE_FOR_LOOP_</a>(mField,<a class="code hl_enumvalue" href="definitions_8h.html#a82340fd7aca566defb002f93cc299efcac77b6cdcfb446c668fd1d7c66cfd15ab">BLOCKSET</a>,it)) {</div>
<div class="line">  <span class="keywordflow">if</span>(it-&gt;getName().compare(0,4,<span class="stringliteral">&quot;SOIL&quot;</span>)!=0) <span class="keywordflow">continue</span>;</div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> mField.add_ents_to_finite_element_by_type(</div>
<div class="line">    dMatMap[it-&gt;getMeshsetId()]-&gt;tEts,MBTET,<span class="stringliteral">&quot;MIX&quot;</span></div>
<div class="line">  ); </div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Define element to integrate natural boundary conditions, i.e. set values.</span></div>
<div class="line"><a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> mField.add_finite_element(<span class="stringliteral">&quot;MIX_BCVALUE&quot;</span>,<a class="code hl_enumvalue" href="definitions_8h.html#a2c740dc34f8edf00c432912eaa5484c1a0bb920c38e835e0fbae45b0c0c029264">MF_ZERO</a>); </div>
<div class="line"><a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> mField.modify_finite_element_add_field_row(<span class="stringliteral">&quot;MIX_BCVALUE&quot;</span>,fluxes_name); </div>
<div class="line"><a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> mField.modify_finite_element_add_field_col(<span class="stringliteral">&quot;MIX_BCVALUE&quot;</span>,fluxes_name); </div>
<div class="line"><a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> mField.modify_finite_element_add_field_data(<span class="stringliteral">&quot;MIX_BCVALUE&quot;</span>,fluxes_name); </div>
<div class="line"><a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> mField.modify_finite_element_add_field_data(<span class="stringliteral">&quot;MIX_BCVALUE&quot;</span>,values_name); </div>
<div class="line"><span class="keywordflow">for</span>(<a class="code hl_define" href="group__mofem__meshset__mng.html#gaff36ed0367e6b0a57541419546aa1323">_IT_CUBITMESHSETS_BY_SET_TYPE_FOR_LOOP_</a>(mField,<a class="code hl_enumvalue" href="definitions_8h.html#a82340fd7aca566defb002f93cc299efcac77b6cdcfb446c668fd1d7c66cfd15ab">BLOCKSET</a>,it)) {</div>
<div class="line">  <span class="keywordflow">if</span>(it-&gt;getName().compare(0,4,<span class="stringliteral">&quot;HEAD&quot;</span>)!=0) <span class="keywordflow">continue</span>;</div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> mField.add_ents_to_finite_element_by_type(</div>
<div class="line">    bcValueMap[it-&gt;getMeshsetId()]-&gt;eNts,MBTRI,<span class="stringliteral">&quot;MIX_BCVALUE&quot;</span></div>
<div class="line">  ); </div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Define element to apply essential boundary conditions.</span></div>
<div class="line"><a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> mField.add_finite_element(<span class="stringliteral">&quot;MIX_BCFLUX&quot;</span>,<a class="code hl_enumvalue" href="definitions_8h.html#a2c740dc34f8edf00c432912eaa5484c1a0bb920c38e835e0fbae45b0c0c029264">MF_ZERO</a>); </div>
<div class="line"><a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> mField.modify_finite_element_add_field_row(<span class="stringliteral">&quot;MIX_BCFLUX&quot;</span>,fluxes_name); </div>
<div class="line"><a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> mField.modify_finite_element_add_field_col(<span class="stringliteral">&quot;MIX_BCFLUX&quot;</span>,fluxes_name); </div>
<div class="line"><a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> mField.modify_finite_element_add_field_data(<span class="stringliteral">&quot;MIX_BCFLUX&quot;</span>,fluxes_name); </div>
<div class="line"><a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> mField.modify_finite_element_add_field_data(<span class="stringliteral">&quot;MIX_BCFLUX&quot;</span>,values_name); </div>
<div class="line"><span class="keywordflow">for</span>(<a class="code hl_define" href="group__mofem__meshset__mng.html#gaff36ed0367e6b0a57541419546aa1323">_IT_CUBITMESHSETS_BY_SET_TYPE_FOR_LOOP_</a>(mField,<a class="code hl_enumvalue" href="definitions_8h.html#a82340fd7aca566defb002f93cc299efcac77b6cdcfb446c668fd1d7c66cfd15ab">BLOCKSET</a>,it)) {</div>
<div class="line">  <span class="keywordflow">if</span>(it-&gt;getName().compare(0,4,<span class="stringliteral">&quot;FLUX&quot;</span>)!=0) <span class="keywordflow">continue</span>;</div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> mField.add_ents_to_finite_element_by_type(</div>
<div class="line">    bcFluxMap[it-&gt;getMeshsetId()]-&gt;eNts,MBTRI,<span class="stringliteral">&quot;MIX_BCFLUX&quot;</span></div>
<div class="line">  ); </div>
<div class="line">}</div>
<div class="ttc" id="adefinitions_8h_html_a2c740dc34f8edf00c432912eaa5484c1a0bb920c38e835e0fbae45b0c0c029264"><div class="ttname"><a href="definitions_8h.html#a2c740dc34f8edf00c432912eaa5484c1a0bb920c38e835e0fbae45b0c0c029264">MF_ZERO</a></div><div class="ttdeci">@ MF_ZERO</div><div class="ttdef"><b>Definition:</b> <a href="definitions_8h_source.html#l00098">definitions.h:98</a></div></div>
</div><!-- fragment --><p> Note that we create three elements including "MIX", "MIX_BCVALUE" and "MIX_BCFLUX", to evaluate fields in volume, on the boundary where natural conditions are applied and where essential conditions are applied, respectively.</p>
<p >Both fields and finite elements are defined on part of the mesh, i.e. entities set, where mesh block name starts with first four letters "SOIL". In case of "MIX_BCVALUE" and "MIX_BCFLUX" where blocks name having first for letters "HEAD" and "FLUX", respectively. A user can define multiple blocks and attach a material model, material parameters and initial conditions independently to each of them independently.</p>
<p >In a similar way, other types of elements can be added to the formulation, for example, we can create an evaporation element on some parts of the boundary, or one can extend formulation with other mechanical and non-mechanical fields. For example, one can add heat conduction and solve a coupled problem with freezing and thawing processes.</p>
<p >In method <a class="el" href="struct_mix_transport_1_1_unsaturated_flow_element.html#a38264c6e19bcaeb899af4f6fa1a42d99" title="Build problem.">MixTransport::UnsaturatedFlowElement::buildProblem</a>, we create problem and Discrete Manager operating on that problem </p><div class="fragment"><div class="line"><span class="comment">//  create DM instance</span></div>
<div class="line"><a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> DMCreate(PETSC_COMM_WORLD,&amp;dM);</div>
<div class="line"><span class="comment">// setting that DM is type of DMMOFEM, i.e. MOFEM implementation manages DM</span></div>
<div class="line"><a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> DMSetType(dM,<span class="stringliteral">&quot;DMMOFEM&quot;</span>);</div>
<div class="line"><span class="comment">// mesh is portioned, each process keeps only part of problem</span></div>
<div class="line"><a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> DMMoFEMSetIsPartitioned(dM,PETSC_TRUE);</div>
<div class="line"><span class="comment">// creates problem in DM, &quot;MIX&quot; is name of problem</span></div>
<div class="line"><a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> DMMoFEMCreateMoFEM(dM,&amp;mField,<span class="stringliteral">&quot;MIX&quot;</span>,ref_level); </div>
<div class="line"><span class="comment">// discretized problem creates square matrix (that makes some optimizations)</span></div>
<div class="line"><a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> DMMoFEMSetIsPartitioned(dM,PETSC_TRUE); </div>
<div class="line"><span class="comment">// set DM options from command line</span></div>
<div class="line"><a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> DMSetFromOptions(dM); </div>
<div class="line"><span class="comment">// add finite elements</span></div>
<div class="line"><a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> DMMoFEMAddElement(dM,<span class="stringliteral">&quot;MIX&quot;</span>); </div>
<div class="line"><a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> DMMoFEMAddElement(dM,<span class="stringliteral">&quot;MIX_BCFLUX&quot;</span>); </div>
<div class="line"><a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> DMMoFEMAddElement(dM,<span class="stringliteral">&quot;MIX_BCVALUE&quot;</span>); </div>
<div class="line"><span class="comment">// constructor data structures</span></div>
<div class="line"><a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> DMSetUp(dM); </div>
</div><!-- fragment --><p> Note that problem in DM is created by setting finite elements on which it operates.</p>
<h2><a class="anchor" id="mix_us_flow_fe_instances"></a>
Creating finite element instances</h2>
<p >Definition of the problem enables construction of a matrix since the matrix connectivity is derived from problem definition. To fill the matrix with the numbers, you need to implement finite elements. In fact, you can have more than one implementation of the same problem.</p>
<p >Once you have problem defined, the developer is released from the need of managing complexities related to management of DOFs, iteration over elements, matrix assembly, etc. He/she can focus on the integration of local entity matrices, as shown in <a class="el" href="mix_us_flow.html#mix_us_flow_numerical_discretisation">Semi-discrete linearized system of equations</a>.</p>
<p ><a class="el" href="namespace_mo_f_e_m.html" title="implementation of Data Operators for Forces and Sources">MoFEM</a> provides technology whith simplifies implementation of the element, enabling the developer to break a complex problem into smaller tasks, which are easier to implement, debug and reuse in different contexts, this has been discussed in several tutorials already. Assembly of residual vectors and tangent matrices is made with the use of the so called user data operators (UDO). For example, the sequence of user data operators of finite element instance to assemble tangent matrix is shown in <a class="el" href="mix_us_flow.html#figure_4_operators_mix_element">Figure 4</a>.</p>
<p ><a class="anchor" id="figure_4_operators_mix_element"></a></p><div class="image">
<img src="unsaturated_flow_fig1.png" alt="" width="700px"/>
<div class="caption">
Figure 4. Sequence of operators on instance of MIX element</div></div>
<p >We have already discussed the last four operators in sequence for <em>feVolLhs</em> finite element instance, those are used to assemble tangent matrix blocks, i.e. \(\mathbf{C}\), \(\mathbf{G}\), \(\mathbf{H}\) and \(\mathbf{A}\). The first three operators are used to evaluate fields at integration points, i.e. capillary head, flux and rate of capillary head. Note that the first three operators have been reused from other tutorials.</p>
<p >In this problem, we use two generic implementations of finite element, <a class="el" href="struct_mo_f_e_m_1_1_volume_element_forces_and_sources_core.html" title="Volume finite element base.">MoFEM::VolumeElementForcesAndSourcesCore</a> and <a class="el" href="struct_mo_f_e_m_1_1_face_element_forces_and_sources_core.html" title="Face finite element.">MoFEM::FaceElementForcesAndSourcesCore</a>, for integrating fields on volumes and faces. Finite element instances are iterated over a particular element in the problem, and for each entity on finite element entity, the sequence of UDO is called.</p>
<p >We use smart pointers to create the finite element instances, which gives the code flexibility and a safe memory management. The finite element instances are created in method <a class="el" href="struct_mix_transport_1_1_unsaturated_flow_element.html#a2fe2664b246c11462fc96422231627dc" title="Create finite element instances.">MixTransport::UnsaturatedFlowElement::setFiniteElements</a> as follows </p><div class="fragment"><div class="line">feFaceBc = boost::shared_ptr&lt;ForcesAndSourcesCore&gt;(<span class="keyword">new</span> <a class="code hl_class" href="class_face_element_forces_and_sources_core.html">FaceElementForcesAndSourcesCore</a>(mField));</div>
<div class="line">feFaceRhs = boost::shared_ptr&lt;ForcesAndSourcesCore&gt;(<span class="keyword">new</span> <a class="code hl_class" href="class_face_element_forces_and_sources_core.html">FaceElementForcesAndSourcesCore</a>(mField));</div>
<div class="line">feVolInitialPc = boost::shared_ptr&lt;ForcesAndSourcesCore&gt;(<span class="keyword">new</span> VolumeElementForcesAndSourcesCore(mField));</div>
<div class="line">feVolLhs = boost::shared_ptr&lt;ForcesAndSourcesCore&gt;(<span class="keyword">new</span> VolumeElementForcesAndSourcesCore(mField));</div>
<div class="line">feVolRhs = boost::shared_ptr&lt;ForcesAndSourcesCore&gt;(<span class="keyword">new</span> VolumeElementForcesAndSourcesCore(mField));</div>
<div class="ttc" id="aclass_face_element_forces_and_sources_core_html"><div class="ttname"><a href="class_face_element_forces_and_sources_core.html">FaceElementForcesAndSourcesCore</a></div></div>
</div><!-- fragment --><p> Next, we set the integration rule, as has been discussed in tutorial <a class="el" href="poisson_tut1.html">COR-2: Solving the Poisson equation</a> as follows </p><div class="fragment"><div class="line"><span class="comment">// set integration rule to elements</span></div>
<div class="line">feFaceBc-&gt;getRuleHook = face_rule;</div>
<div class="line">feFaceRhs-&gt;getRuleHook = face_rule;</div>
<div class="line">feVolInitialPc-&gt;getRuleHook = vol_rule;</div>
<div class="line">feVolLhs-&gt;getRuleHook = vol_rule;</div>
<div class="line">feVolRhs-&gt;getRuleHook = vol_rule;</div>
</div><!-- fragment --><p> In addition, we add hooks to functions which are run at the beginning and the end of the loop over a particular element. Those functions are used to preprocess and postprocess the matrix assembly. Those pre-processing and post-processing hooks are added as follows </p><div class="fragment"><div class="line">feVolRhs-&gt;preProcessHook = preProcessVol(*<span class="keyword">this</span>,feVolRhs);</div>
<div class="line">feVolLhs-&gt;preProcessHook = preProcessVol(*<span class="keyword">this</span>,feVolLhs);</div>
<div class="line">feVolRhs-&gt;postProcessHook = postProcessVol(*<span class="keyword">this</span>,feVolRhs);</div>
<div class="line">feVolLhs-&gt;postProcessHook = postProcessVol(*<span class="keyword">this</span>,feVolLhs);</div>
</div><!-- fragment --><p> We use classes <a class="el" href="struct_mix_transport_1_1_unsaturated_flow_element_1_1pre_process_vol.html" title="Pre-peprocessing Set head pressure rate and get inital essential boundary conditions.">MixTransport::UnsaturatedFlowElement::preProcessVol</a> and <a class="el" href="struct_mix_transport_1_1_unsaturated_flow_element_1_1post_process_vol.html" title="Post proces method for volume element Assemble vectors and matrices and apply essential boundary cond...">MixTransport::UnsaturatedFlowElement::postProcessVol</a> to enforce essential boundary conditions. The method of enforcing essential boundary conditions is discussed in <a class="el" href="mix_transport.html">COR-0: Mixed formulation and integration on skeleton (h-adaptivity)</a>. In addition, in function <a class="el" href="struct_mix_transport_1_1_unsaturated_flow_element_1_1post_process_vol.html#a6def7ed2575973cd4126c8a853e3df09">MixTransport::UnsaturatedFlowElement::postProcessVol::operator()()</a>, we scatter the vector of rate of capillary pressure on the field data. Since the rate of capillary head is not primary unknown but linear function of solution at current and previous steps, it is evaluated by PETSc for particular integration scheme. </p><div class="fragment"><div class="line"><a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> fePtr-&gt;mField.getInterface&lt;VecManager&gt;()-&gt;setOtherLocalGhostVector(</div>
<div class="line">  fePtr-&gt;problemPtr,<span class="stringliteral">&quot;VALUES&quot;</span>,<span class="keywordtype">string</span>(<span class="stringliteral">&quot;VALUES&quot;</span>)+<span class="stringliteral">&quot;_t&quot;</span>,</div>
<div class="line">  <a class="code hl_enumvalue" href="definitions_8h.html#a194bf71b1f5ddbc56eef764d19ea69dbabf470e461303b909bf0dc58084ebafa0">ROW</a>,fePtr-&gt;ts_u_t,INSERT_VALUES,SCATTER_REVERSE</div>
<div class="line">); </div>
<div class="ttc" id="adefinitions_8h_html_a194bf71b1f5ddbc56eef764d19ea69dbabf470e461303b909bf0dc58084ebafa0"><div class="ttname"><a href="definitions_8h.html#a194bf71b1f5ddbc56eef764d19ea69dbabf470e461303b909bf0dc58084ebafa0">ROW</a></div><div class="ttdeci">@ ROW</div><div class="ttdef"><b>Definition:</b> <a href="definitions_8h_source.html#l00123">definitions.h:123</a></div></div>
</div><!-- fragment --><p> Time solver provides vector of DOFs, \(\left(\frac{\textrm{d}\mathbf{p}}{\textrm{d}t}\right)^{i+1}_{n+1}\) at integration \(i+1\) and time step \(n+1\), and the above code scatters the vector values on the mesh, such that values of capillary head at integration points are evaluated early, i.e. \(\frac{\textrm{d}h}{\textrm{d}t}|^{i+1}_{n+1}\). Capillary head DOFs are sub-vectors of <em>fePtr-&gt;ts_u_t</em>.</p>
<h3><a class="anchor" id="mix_us_flow_fe_instances_op"></a>
Adding operators to elements</h3>
<p >The user data operators are added to the finite element calculating tangent matrix as follows </p><div class="fragment"><div class="line"><span class="comment">// set tangent matrix finite element operators</span></div>
<div class="line">feVolLhs-&gt;getOpPtrVector().push_back(</div>
<div class="line">  <span class="keyword">new</span> OpCalculateScalarFieldValues(<span class="keywordtype">string</span>(<span class="stringliteral">&quot;VALUES&quot;</span>)+<span class="stringliteral">&quot;_t&quot;</span>,headRateAtGaussPts,MBTET)</div>
<div class="line">);</div>
<div class="line">feVolLhs-&gt;getOpPtrVector().push_back(<span class="keyword">new</span> OpValuesAtGaussPts(*<span class="keyword">this</span>,<span class="stringliteral">&quot;VALUES&quot;</span>));</div>
<div class="line">feVolLhs-&gt;getOpPtrVector().push_back(<span class="keyword">new</span> OpFluxDivergenceAtGaussPts(*<span class="keyword">this</span>,<span class="stringliteral">&quot;FLUXES&quot;</span>));</div>
<div class="line">feVolLhs-&gt;getOpPtrVector().push_back(<span class="keyword">new</span> OpTauDotSigma_HdivHdiv(*<span class="keyword">this</span>,<span class="stringliteral">&quot;FLUXES&quot;</span>));</div>
<div class="line">feVolLhs-&gt;getOpPtrVector().push_back(<span class="keyword">new</span> OpVU_L2L2(*<span class="keyword">this</span>,<span class="stringliteral">&quot;VALUES&quot;</span>));</div>
<div class="line">feVolLhs-&gt;getOpPtrVector().push_back(<span class="keyword">new</span> OpVDivSigma_L2Hdiv(*<span class="keyword">this</span>,<span class="stringliteral">&quot;VALUES&quot;</span>,<span class="stringliteral">&quot;FLUXES&quot;</span>));</div>
<div class="line">feVolLhs-&gt;getOpPtrVector().push_back(<span class="keyword">new</span> OpDivTauU_HdivL2(*<span class="keyword">this</span>,<span class="stringliteral">&quot;FLUXES&quot;</span>,<span class="stringliteral">&quot;VALUES&quot;</span>));</div>
</div><!-- fragment --><p> and similarly for other elements, evaluating the boundary conditions and the vector of residuals. For more details we refer to tutorial <a class="el" href="hello_world_tut1.html">FUN-0: Hello world</a>.</p>
<p >In addition, finite element instances are created to post-process results and to run time stepping monitor, see code in <a class="el" href="struct_mix_transport_1_1_unsaturated_flow_element.html#a2fe2664b246c11462fc96422231627dc">MixTransport::UnsaturatedFlowElement::setFiniteElements</a>.</p>
<h3><a class="anchor" id="mix_us_flow_fe_instances_op_ts"></a>
Adding finite element instances to DM</h3>
<p >Once we have created finite element instances, in <a class="el" href="struct_mix_transport_1_1_unsaturated_flow_element.html#a2fe2664b246c11462fc96422231627dc">MixTransport::UnsaturatedFlowElement::setFiniteElements</a>, we add finite instances to DM manager, such that the system of equations could be assembled. This is simply done by </p><div class="fragment"><div class="line"><a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> DMMoFEMTSSetIFunction(dM,<span class="stringliteral">&quot;MIX_BCVALUE&quot;</span>,feFaceRhs,null,null); </div>
<div class="line"><a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> DMMoFEMTSSetIFunction(dM,<span class="stringliteral">&quot;MIX&quot;</span>,feVolRhs,null,null); </div>
<div class="line"><a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> DMMoFEMTSSetIJacobian(dM,<span class="stringliteral">&quot;MIX&quot;</span>,feVolLhs,null,null); </div>
</div><!-- fragment --><p> Those functions are specific to <a class="el" href="namespace_mo_f_e_m.html" title="implementation of Data Operators for Forces and Sources">MoFEM</a> implementation, they have been implemented based on PETSc documentation, <a href="http://www.mcs.anl.gov/petsc/petsc-current/docs/manual.pdf">link</a>, see Chapter 6.</p>
<h2><a class="anchor" id="mix_us_flow_solving_problem"></a>
Solving problem using TS</h2>
<p >Finally, we can solve the problem by creating TS solver and link it to DM as follows </p><div class="fragment"><div class="line"><span class="comment">// Create time solver</span></div>
<div class="line">TS ts;</div>
<div class="line"><a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> TSCreate(PETSC_COMM_WORLD,&amp;ts); </div>
<div class="line"><span class="comment">// Use backward Euler method</span></div>
<div class="line"><a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> TSSetType(ts,TSBEULER); </div>
<div class="line"><span class="comment">// Not test functions to evalye matrix and rigth hand side, TS ask DM</span></div>
<div class="line"><span class="comment">// for doing that</span></div>
<div class="line"><a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> TSSetIFunction(ts,<a class="code hl_enumvalue" href="free__surface_8cpp.html#a275fe82762dca6ff32ecbb73db0b3b84af382a63cc3d6491bf26b59e66f46826d">F</a>,PETSC_NULL,PETSC_NULL); </div>
<div class="line"><a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> TSSetIJacobian(ts,Aij,Aij,PETSC_NULL,PETSC_NULL); </div>
<div class="line"><span class="comment">// Set final time</span></div>
<div class="line"><span class="keywordtype">double</span> ftime = 1;</div>
<div class="line"><a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> TSSetDuration(ts,PETSC_DEFAULT,ftime); </div>
<div class="line"><span class="comment">// Setup solver from commabd line</span></div>
<div class="line"><a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> TSSetFromOptions(ts); </div>
<div class="line"><span class="comment">// Set DM to TS</span></div>
<div class="line"><a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> TSSetDM(ts,dM); </div>
<div class="line"><span class="preprocessor">#if PETSC_VERSION_GE(3,7,0)</span></div>
<div class="line"><a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> TSSetExactFinalTime(ts,TS_EXACTFINALTIME_STEPOVER); </div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="comment">// Set-up monitor</span></div>
<div class="line">TsCtx *<a class="code hl_variable" href="level__set_8cpp.html#ae194ec50b15d7b114a4e5e5a4cb8e218">ts_ctx</a>;</div>
<div class="line">DMMoFEMGetTsCtx(dM,&amp;<a class="code hl_variable" href="level__set_8cpp.html#ae194ec50b15d7b114a4e5e5a4cb8e218">ts_ctx</a>);</div>
<div class="line"><a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> TSMonitorSet(ts,TsMonitorSet,<a class="code hl_variable" href="level__set_8cpp.html#ae194ec50b15d7b114a4e5e5a4cb8e218">ts_ctx</a>,PETSC_NULL); </div>
<div class="line"><a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> TSSolve(ts,<a class="code hl_variable" href="initial__diffusion_8cpp.html#ad8657a5ec76e12f3066fb4b4eb75ace9">D</a>); </div>
<div class="ttc" id="afree__surface_8cpp_html_a275fe82762dca6ff32ecbb73db0b3b84af382a63cc3d6491bf26b59e66f46826d"><div class="ttname"><a href="free__surface_8cpp.html#a275fe82762dca6ff32ecbb73db0b3b84af382a63cc3d6491bf26b59e66f46826d">F</a></div><div class="ttdeci">@ F</div><div class="ttdef"><b>Definition:</b> <a href="free__surface_8cpp_source.html#l00394">free_surface.cpp:394</a></div></div>
<div class="ttc" id="ainitial__diffusion_8cpp_html_ad8657a5ec76e12f3066fb4b4eb75ace9"><div class="ttname"><a href="initial__diffusion_8cpp.html#ad8657a5ec76e12f3066fb4b4eb75ace9">D</a></div><div class="ttdeci">double D</div><div class="ttdef"><b>Definition:</b> <a href="initial__diffusion_8cpp_source.html#l00044">initial_diffusion.cpp:44</a></div></div>
<div class="ttc" id="alevel__set_8cpp_html_ae194ec50b15d7b114a4e5e5a4cb8e218"><div class="ttname"><a href="level__set_8cpp.html#ae194ec50b15d7b114a4e5e5a4cb8e218">ts_ctx</a></div><div class="ttdeci">MoFEM::TsCtx * ts_ctx</div><div class="ttdef"><b>Definition:</b> <a href="level__set_8cpp_source.html#l01884">level_set.cpp:1884</a></div></div>
</div><!-- fragment --><p> Note that TS calls the finite elements instance by DM, similarly how SNES (Newton solver) calls finite elements in <a class="el" href="poisson_tut4.html">COR-5: A nonlinear Poisson equation</a>, or KSP (Krylov solver) calls finite elements in <a class="el" href="poisson_tut1.html">COR-2: Solving the Poisson equation</a>. The above is implemented in <a class="el" href="struct_mix_transport_1_1_unsaturated_flow_element.html#a7c21609cdb160f43e7d758aa6f9cf163" title="solve problem">MixTransport::UnsaturatedFlowElement::solveProblem</a>, where prior to solution, initial conditions are calculated, and statistics at the end printed to the terminal.</p>
<h1><a class="anchor" id="mix_us_flow_application"></a>
Application code</h1>
<p >Application code is <a class="el" href="unsaturated_transport_8cpp-example.html">unsaturated_transport.cpp</a>, which calls sequence of functions </p><div class="fragment"><div class="line"><span class="comment">// Initialise</span></div>
<div class="line"><a class="code hl_function" href="struct_mo_f_e_m_1_1_core_tmp_3_010_01_4.html#a137f1f2092d00ef0c1ec679db94b8cb0">MoFEM::Core::Initialize</a>(&amp;argc,&amp;argv,(<span class="keywordtype">char</span> *)0,<a class="code hl_variable" href="activate__deactivate__dofs_8cpp.html#a29680e68c64040f4884f60691a193226">help</a>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Register materials</span></div>
<div class="line"><a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> RegisterMaterials()(); </div>
<div class="line"><span class="comment">// Register MOFEM DM implementation</span></div>
<div class="line"><a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> DMRegister_MoFEM(<span class="stringliteral">&quot;DMMOFEM&quot;</span>);  <span class="comment">// register MoFEM DM in PETSc</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">try</span> {</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Create moab instance</span></div>
<div class="line">  moab::Core mb_instance;</div>
<div class="line">  moab::Interface&amp; moab = mb_instance;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Read mesh</span></div>
<div class="line">  ...</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Create mofem interface</span></div>
<div class="line">  <a class="code hl_struct" href="struct_mo_f_e_m_1_1_core_tmp_3_010_01_4.html">MoFEM::Core</a> core(moab);</div>
<div class="line">  <a class="code hl_struct" href="struct_mo_f_e_m_1_1_deprecated_core_interface.html">MoFEM::Interface</a>&amp; m_field = core;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Create unsaturated flow structures</span></div>
<div class="line">  UnsaturatedFlowElement uf(m_field);</div>
<div class="line"> </div>
<div class="line">  \\ Read data from meshsets</div>
<div class="line">  ...</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> uf.addFields(<span class="stringliteral">&quot;VALUES&quot;</span>,<span class="stringliteral">&quot;FLUXES&quot;</span>,<a class="code hl_variable" href="dg__projection_8cpp.html#ad7eceded84ace5678d9df3e44f47d475">order</a>); </div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> uf.addFiniteElements(<span class="stringliteral">&quot;FLUXES&quot;</span>,<span class="stringliteral">&quot;VALUES&quot;</span>); </div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> m_field.<a class="code hl_function" href="group__mofem__fe.html#ga8b068eced1fd720631edcaea59289a15">add_ents_to_finite_element_by_type</a>(</div>
<div class="line">  zero_flux_ents,MBTRI,<span class="stringliteral">&quot;MIX_BCFLUX&quot;</span></div>
<div class="line">  ); </div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> uf.buildProblem(); </div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> uf.createMatrices(); </div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> uf.setFiniteElements(); </div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> uf.calculateEssentialBc(); </div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> uf.calculateInitialPc(); </div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> uf.solveProblem(); </div>
<div class="line">  <a class="code hl_define" href="definitions_8h.html#add80e5ef5f847b2d4b637029f0f671c3">CHKERR</a> uf.destroyMatrices(); </div>
<div class="line"> </div>
<div class="line">} <a class="code hl_define" href="definitions_8h.html#a1e74d797bf522e2b291419cddab27835">CATCH_ERRORS</a>;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="struct_mo_f_e_m_1_1_core_tmp_3_010_01_4.html#aa5abe3b5d998e2dc50e4ef6916915eb1">MoFEM::Core::Finalize</a>(); </div>
<div class="ttc" id="aactivate__deactivate__dofs_8cpp_html_a29680e68c64040f4884f60691a193226"><div class="ttname"><a href="activate__deactivate__dofs_8cpp.html#a29680e68c64040f4884f60691a193226">help</a></div><div class="ttdeci">static char help[]</div><div class="ttdef"><b>Definition:</b> <a href="activate__deactivate__dofs_8cpp_source.html#l00013">activate_deactivate_dofs.cpp:13</a></div></div>
<div class="ttc" id="adefinitions_8h_html_a1e74d797bf522e2b291419cddab27835"><div class="ttname"><a href="definitions_8h.html#a1e74d797bf522e2b291419cddab27835">CATCH_ERRORS</a></div><div class="ttdeci">#define CATCH_ERRORS</div><div class="ttdoc">Catch errors.</div><div class="ttdef"><b>Definition:</b> <a href="definitions_8h_source.html#l00372">definitions.h:372</a></div></div>
<div class="ttc" id="agroup__mofem__fe_html_ga8b068eced1fd720631edcaea59289a15"><div class="ttname"><a href="group__mofem__fe.html#ga8b068eced1fd720631edcaea59289a15">MoFEM::CoreInterface::add_ents_to_finite_element_by_type</a></div><div class="ttdeci">virtual MoFEMErrorCode add_ents_to_finite_element_by_type(const EntityHandle entities, const EntityType type, const std::string &amp;name, const bool recursive=true)=0</div><div class="ttdoc">add entities to finite element</div></div>
<div class="ttc" id="astruct_mo_f_e_m_1_1_core_tmp_3_010_01_4_html"><div class="ttname"><a href="struct_mo_f_e_m_1_1_core_tmp_3_010_01_4.html">MoFEM::CoreTmp&lt; 0 &gt;</a></div><div class="ttdoc">Core (interface) class.</div><div class="ttdef"><b>Definition:</b> <a href="_core_8hpp_source.html#l00082">Core.hpp:82</a></div></div>
<div class="ttc" id="astruct_mo_f_e_m_1_1_core_tmp_3_010_01_4_html_a137f1f2092d00ef0c1ec679db94b8cb0"><div class="ttname"><a href="struct_mo_f_e_m_1_1_core_tmp_3_010_01_4.html#a137f1f2092d00ef0c1ec679db94b8cb0">MoFEM::CoreTmp&lt; 0 &gt;::Initialize</a></div><div class="ttdeci">static MoFEMErrorCode Initialize(int *argc, char ***args, const char file[], const char help[])</div><div class="ttdoc">Initializes the MoFEM database PETSc, MOAB and MPI.</div><div class="ttdef"><b>Definition:</b> <a href="_core_8cpp_source.html#l00072">Core.cpp:72</a></div></div>
<div class="ttc" id="astruct_mo_f_e_m_1_1_core_tmp_3_010_01_4_html_aa5abe3b5d998e2dc50e4ef6916915eb1"><div class="ttname"><a href="struct_mo_f_e_m_1_1_core_tmp_3_010_01_4.html#aa5abe3b5d998e2dc50e4ef6916915eb1">MoFEM::CoreTmp&lt; 0 &gt;::Finalize</a></div><div class="ttdeci">static MoFEMErrorCode Finalize()</div><div class="ttdoc">Checks for options to be called at the conclusion of the program.</div><div class="ttdef"><b>Definition:</b> <a href="_core_8cpp_source.html#l00112">Core.cpp:112</a></div></div>
<div class="ttc" id="astruct_mo_f_e_m_1_1_deprecated_core_interface_html"><div class="ttname"><a href="struct_mo_f_e_m_1_1_deprecated_core_interface.html">MoFEM::DeprecatedCoreInterface</a></div><div class="ttdoc">Deprecated interface functions.</div><div class="ttdef"><b>Definition:</b> <a href="_deprecated_core_interface_8hpp_source.html#l00016">DeprecatedCoreInterface.hpp:16</a></div></div>
</div><!-- fragment --><h1><a class="anchor" id="mix_us_flow_to_do"></a>
To do</h1>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000083">Todo:</a></b></dt><dd><p class="startdd">Add example with hp-adaptivity </p>
<p class="interdd">Implement block-solver and multigrid </p>
<p class="interdd">Apply Kirchhoff transform </p>
<p class="interdd">Add boundary condition for evaporation </p>
<p class="interdd">Add air phase and mechanical filed </p>
<p class="interdd">Add diffusion and other physical phenomena </p>
<p class="interdd">Make example with flux history or head history. That is implemented but no example is added </p>
<p class="enddd">Add diffusion and other physical phenomenas</p>
</dd></dl>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr cla ss="footer" />
<style>
  img[src="UoGLogo.png"] {
    height: 20px;
    padding-top: 0px;
    padding-right: 1px;
    padding-bottom: 3px;
    padding-left: 6px;
  }
</style>
<address class="footer">
  <small>
    Generated by
    <a href="http://www.doxygen.org/index.html"> Doxygen </a> 1.9.5
    and hosted at
    <a href="http://www.gla.ac.uk/schools/engineering/">
      <img class="footer" src="UoGLogo.png" alt="University of Glasgow" />
    </a>
  </small>
</address>
</body>
</html>