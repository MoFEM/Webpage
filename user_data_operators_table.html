<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
  <meta http-equiv="X-UA-Compatible" content="IE=9"/>
  <meta name="generator" content="Doxygen 1.8.17"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>MoFEM: User data operators table</title>
  <link href="tabs.css" rel="stylesheet" type="text/css"/>
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
  <script type="text/javascript " src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML "></script>
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        extensions: ["AMSmath.js"],
        TeX: { equationNumbers: { autoNumber: ["all"],
                                  useLabelIds: true
        } 
        }
    });
    </script>
  <link href="customdoxygen.css" rel="stylesheet" type="text/css" />
  <link href="extra_style.css" rel="stylesheet" type="text/css"/>
  <link rel="apple-touch-icon" sizes="57x57" href="apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192"  href="android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.png">
  <link rel="shortcut icon" type="image/png" href="favicon-32x32.png"/>
  <link rel="Bookmark" type="image/png" href="favicon-32x32.png"/>
  <link rel="manifest" href="manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div style="background-color:#011A40" id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 30px;">
  <td id="projectlogo"><img alt="Logo" src="MoFEMLogo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <td style="padding-left: 0.5em;" bgcolor="#011A40"
   <div id="projectbrief"><font color="#FFFFFF">v0.14.0</font></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!--Google analytics tags-->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-65236130-1', 'auto');
  ga('send', 'pageview');
</script>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-2J9RE2P3H5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-2J9RE2P3H5');
</script><!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">User data operators table </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#tab_user_data_op">Field operators</a></li>
<li class="level1"><a href="#tab_other_data_op">Other operators</a></li>
<li class="level1"><a href="#tab_linear_forms">Linear forms</a></li>
<li class="level1"><a href="#tab_bilinear_forms">Bilinear forms</a></li>
</ul>
</div>
<div class="textblock"><dl class="section note"><dt>Note</dt><dd>Work in progress. Tables not complete.</dd></dl>
<p>Template arguments:</p>
<ul>
<li><b>BASE_DIM</b> is dimension of base function. Typically bases for L2 and H1 spaces are scalar bases. Thus BASE_DIM is 1. Typically H-div and H-curl bases are vectorial bases and BASE_DIM 3. For some special case could be exceptions.</li>
<li><b>FIELD_DIM</b> is dimension of the field. We can have scalar field, vectorial field. For example, the scalar field for scalar base function has one coefficient for base function and <em>FIELD_DIM</em> = 1. Vectorial field with scalar base in 3D has three coefficients for each base function and <em>FIELD_DIM</em> = 3. On the other hand, a vectorial field with a vectorial base has one coefficient for each base function and <em>FIELD_DIM</em> = 3, and tensorial field of rank two in 3D on vectorial base has three coefficients for each base function and <em>FIELD_DIM</em> = 9.</li>
<li><b>SPACE_DIM</b> is dismension of space. Typically, it is used to indicate how many elements have a gradient of base function or field.</li>
<li><b>ASSEMBLE_TYPE</b> by this template assembly method is indicated. For example, if the assembly is to CST compressed matrix assembly type is PETSc. For some other cases, for example, integration to nested matrices, or other matrices formats could be added and implemented.</li>
<li><b>INTEGRATION_TYPE</b> indicate method used to assembly elements. If standard numerical integration is used, then the integration type is GAUSS. Some other more sophisticated integration methods can be implemented to exploit some base functions for fast integration.</li>
<li><b>OP</b> type of opetaor for voulme, face, edge or vertex finite element.</li>
</ul>
<h1><a class="anchor" id="tab_user_data_op"></a>
Field operators</h1>
<a class="anchor" id="user_data_ops_table"></a>
<table class="doxtable">
<caption>Table of user data operators</caption>
<tr style="width:100%">
<th style="width:50%">Operator </th><th style="width:50%">Usage </th></tr>
<tr>
<td colspan="2"><b>Scalar fields</b> </td></tr>
<tr>
<td><p class="starttd"></p>
<p class="intertd">Evaluate scalar field at integration points. <a class="el" href="structMoFEM_1_1OpCalculateScalarFieldValues.html">MoFEM::OpCalculateScalarFieldValues</a></p>
<p class="formulaDsp">
\[ u^h(\pmb\xi^g) = \sum_i^N \phi^i(\pmb\xi^g) \overline{u}_i \]
</p>
<p class="intertd">where \(u^h(\pmb\xi^g)\) is the field value at integration point \(g\), \(\phi^i(\pmb\xi^g)\) is value of base function \(i\) at integtation point coordinate \(\pmb\xi^g\), and \(\overline{u}_i\) is \(i\)-th degree of freedom.</p>
<p class="intertd">This function has a similar variant that is used to calculate time derivative, when a time solver is used, see <a class="el" href="namespaceMoFEM.html#abacce9829252f33b5ca316aea0b3e090">MoFEM::OpCalculateScalarFieldValuesDot</a></p>
<p class="formulaDsp">
\[ \frac{\partial u^h}{\partial t} (\pmb\xi^g) = \sum_i^N \phi^i(\pmb\xi^g) \frac{\partial \overline{u}}{\partial t} \]
</p>
<p class="intertd">where \( \frac{\partial u^h}{\partial t} (\pmb\xi^g) \) (or \(\dot{u}^h(\pmb\xi^g)\) in short) is the rate value at integration point \(g\) and \( \frac{\partial \overline{u}}{\partial t} \) (or \(\dot{\overline{u}}_i\) in short) is the rate of \(i\)-th degree of freedom. Note that this funtion will work only with TS solver which is the numerical scheme used to calculate time derivative depends on time solver method.</p>
<p class="endtd"></p>
</td><td><p class="starttd"></p>
<p class="intertd">Basic usage: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> vals_U_at_integration_pts = boost::make_shared&lt;VectorDouble&gt;();</div>
<div class="line">pipeline_mng-&gt;<a class="code" href="group__mofem__basic__interface.html#gac52cdc08eaadd124e0224d7d9e0a13f5">getOpDomainRhsPipeline</a>().push_back(</div>
<div class="line">  <span class="keyword">new</span> OpCalculateScalarFieldValues(<span class="stringliteral">&quot;U&quot;</span>, vals_U_at_integration_pts));</div>
</div><!-- fragment --><p class="intertd">Operator for a given field calulates values of a scalar field at integration points. Values are stored in, for example, <em>vals_U_at_integration_pts</em>. Then value can be accessed as follows </p><div class="fragment"><div class="line"><span class="keyword">auto</span> nb_integration_pts = vals_U_at_integration_pts-&gt;size();</div>
<div class="line"><span class="keyword">auto</span> t_val = <a class="code" href="namespaceMoFEM.html#aa464ad90a188180427136b22e078ec7d">getFTensor0FromVec</a>(vals_U_at_integration_pts);</div>
<div class="line"><span class="keywordflow">for</span>(<span class="keyword">auto</span> gg = 0;gg!=nb_integration_pts;++gg) {</div>
<div class="line">  <span class="comment">// do something here</span></div>
<div class="line">  ++t_val;</div>
<div class="line">}</div>
</div><!-- fragment --><p class="endtd"></p>
</td></tr>
<tr>
<td><p class="starttd"></p>
<p class="intertd">Evaluate scalar field gradient</p>
<p class="intertd"><a class="el" href="structMoFEM_1_1OpCalculateScalarFieldGradient.html">MoFEM::OpCalculateScalarFieldGradient</a></p>
<p class="formulaDsp">
\[ {u}^h_{,j} (\pmb\xi^g) = \sum_i^N \phi^i_{,j}(\pmb\xi^g) \overline{u}_i \]
</p>
<p class="intertd">where </p><p class="formulaDsp">
\[ \phi^i_{,j} = \left. \frac{\partial \phi^i}{\partial \xi_j} \right|_{\pmb\xi^g} \]
</p>
<p class="intertd">Depending on code context, derivatives are calculated in reference element or on the current physical element. For most cases, the gradient is calculated on the current physical element. Then derivative of base function is interpreted as</p>
<p class="formulaDsp">
\[ \phi^i_{,j} = \left. \frac{\partial \phi^i}{\partial \xi_ks} \frac{\partial \xi_k}{\partial x_j} \right|_{\mathbf{x}(\pmb\xi^g)} \]
</p>
<p class="endtd"></p>
</td><td><p class="starttd"></p>
<p class="intertd">Basic usage: </p><div class="fragment"><div class="line">constexpr <span class="keywordtype">int</span> <a class="code" href="child__and__parent_8cpp.html#a541ffc988889246e44b233b777828847">SPACE_DIM</a> = 3;</div>
<div class="line"><span class="keyword">auto</span> grad_U_at_integration_pts = boost::make_shared&lt;MatrixDouble&gt;();</div>
<div class="line">pipeline_mng-&gt;<a class="code" href="group__mofem__basic__interface.html#gac52cdc08eaadd124e0224d7d9e0a13f5">getOpDomainRhsPipeline</a>().push_back(</div>
<div class="line">  <span class="keyword">new</span> OpCalculateVectorFieldValues&lt;SPACE_DIM&gt;(<span class="stringliteral">&quot;U&quot;</span>, grad_U_at_integration_pts));</div>
</div><!-- fragment --><p class="intertd">Operator for a given field calculate values of scalar field gradient at integration points. Values are stored in, for example, <em>grad_U_at_integration_pts</em>. Then value can be accessed as follows </p><div class="fragment"><div class="line">constexpr <span class="keywordtype">int</span> <a class="code" href="child__and__parent_8cpp.html#a662ea09b7a3c09effd6610d75fb7cbcb">FIELD_DIM</a> = 3;</div>
<div class="line"><a class="code" href="classFTensor_1_1Index.html">FTensor::Index&lt;'i', FIELD_DIM&gt;</a> <a class="code" href="hcurl__divergence__operator__2d_8cpp.html#a4c0436605284b64f6b0b5482594d86bc">i</a>; </div>
<div class="line"><span class="keyword">auto</span> nb_integration_pts = grad_U_at_integration_pts-&gt;size2();</div>
<div class="line"><span class="keyword">auto</span> t_grad = getFTensor1FromMat&lt;FIELD_DIM&gt;((grad_U_at_integration_pts);</div>
<div class="line"><span class="keywordflow">for</span>(<span class="keyword">auto</span> gg = 0;gg!=nb_integration_pts;++gg) {</div>
<div class="line">  <span class="keyword">auto</span> dot = t_grad(<a class="code" href="hcurl__divergence__operator__2d_8cpp.html#a4c0436605284b64f6b0b5482594d86bc">i</a>)*t_grad(<a class="code" href="hcurl__divergence__operator__2d_8cpp.html#a4c0436605284b64f6b0b5482594d86bc">i</a>);</div>
<div class="line">  ++t_grad;</div>
<div class="line">}</div>
</div><!-- fragment --><p class="endtd"></p>
</td></tr>
<tr>
<td colspan="2"><b>Vector fields</b> </td></tr>
<tr>
<td><p class="starttd">Evaluate vector field at integration points <a class="el" href="structMoFEM_1_1OpCalculateVectorFieldValues.html">MoFEM::OpCalculateVectorFieldValues</a></p>
<p class="formulaDsp">
\[ u_j^h(\pmb\xi^g) = \sum_i^N \phi^i(\pmb\xi^g) \overline{u}_i^j \]
</p>
<p> where \(j\) is vector element index.</p>
<p class="intertd">This function has a similar variant to calculate rates when a time solver is used; see <a class="el" href="group__mofem__forces__and__sources__user__data__operators.html#gae10e922bea686a13172541fcd994fba7">MoFEM::OpCalculateVectorFieldValuesDot</a>, which can be used with a time solver (TS). Also is a variant to calculate accelerations (second derivatives with respect to time), <a class="el" href="group__mofem__forces__and__sources__user__data__operators.html#gabd19108139737472ff421f539a585274">MoFEM::OpCalculateVectorFieldValuesDotDot</a>, which can be used with a second-order time solver (TS2). PETSc has currently implemented the alpha method for second-order time differential equations.</p>
<p class="endtd"></p>
</td><td><p class="starttd"></p>
<p class="intertd">Basic usage: </p><div class="fragment"><div class="line">constexpr <span class="keywordtype">int</span> <a class="code" href="child__and__parent_8cpp.html#a662ea09b7a3c09effd6610d75fb7cbcb">FIELD_DIM</a> = 3;</div>
<div class="line"><span class="keyword">auto</span> vals_U_at_integration_pts = boost::make_shared&lt;MatrixDouble&gt;();</div>
<div class="line">pipeline_mng-&gt;<a class="code" href="group__mofem__basic__interface.html#gac52cdc08eaadd124e0224d7d9e0a13f5">getOpDomainRhsPipeline</a>().push_back(</div>
<div class="line">  <span class="keyword">new</span> OpCalculateVectorFieldValues&lt;FIELD_DIM&gt;(<span class="stringliteral">&quot;U&quot;</span>, vals_U_at_integration_pts));</div>
</div><!-- fragment --><p class="intertd">Operator for a given field calulates values of vector field at integration points. Values are stored in, for example, <em>vals_U_at_integration_pts</em>. Then value can be accessed as follows </p><div class="fragment"><div class="line">constexpr <span class="keywordtype">int</span> <a class="code" href="child__and__parent_8cpp.html#a662ea09b7a3c09effd6610d75fb7cbcb">FIELD_DIM</a> = 3;</div>
<div class="line"><a class="code" href="classFTensor_1_1Index.html">FTensor::Index&lt;'i', FIELD_DIM&gt;</a> <a class="code" href="hcurl__divergence__operator__2d_8cpp.html#a4c0436605284b64f6b0b5482594d86bc">i</a>; </div>
<div class="line"><span class="keyword">auto</span> nb_integration_pts = vals_U_at_integration_pts-&gt;size2();</div>
<div class="line"><span class="keyword">auto</span> t_val = getFTensor1FromMat&lt;FIELD_DIM&gt;((vals_U_at_integration_pts);</div>
<div class="line"><span class="keywordflow">for</span>(<span class="keyword">auto</span> gg = 0;gg!=nb_integration_pts;++gg) {</div>
<div class="line">  <span class="keyword">auto</span> dot = t_val(<a class="code" href="hcurl__divergence__operator__2d_8cpp.html#a4c0436605284b64f6b0b5482594d86bc">i</a>)*t_val(<a class="code" href="hcurl__divergence__operator__2d_8cpp.html#a4c0436605284b64f6b0b5482594d86bc">i</a>);</div>
<div class="line">  ++t_val;</div>
<div class="line">}</div>
</div><!-- fragment --><p class="endtd"></p>
</td></tr>
<tr>
<td><p class="starttd">Evaluate vector field gradient at integration points <a class="el" href="structMoFEM_1_1OpCalculateVectorFieldGradient.html">MoFEM::OpCalculateVectorFieldGradient</a></p>
<p class="formulaDsp">
\[ u_{jk}^h(\pmb\xi^g) = \sum_i^N \phi^i_{,k}(\pmb\xi^g) \overline{u}_i^{j} \]
</p>
<p> where \(j\) is vector element index, \(k\) is derivative and \(i\) is index of base function.</p>
<p class="intertd">This function has a similar variant to calculate rates, when a time solver is used, see <a class="el" href="structMoFEM_1_1OpCalculateVectorFieldGradientDot.html">MoFEM::OpCalculateVectorFieldGradientDot</a>, which can be used with time solver (TS).</p>
<p class="endtd"></p>
</td><td><p class="starttd"></p>
<p class="intertd">Basic usage: </p><div class="fragment"><div class="line">constexpr <span class="keywordtype">int</span> <a class="code" href="child__and__parent_8cpp.html#a662ea09b7a3c09effd6610d75fb7cbcb">FIELD_DIM</a> = 3;</div>
<div class="line">constexpr <span class="keywordtype">int</span> <a class="code" href="child__and__parent_8cpp.html#a541ffc988889246e44b233b777828847">SPACE_DIM</a> = 3;</div>
<div class="line"><span class="keyword">auto</span> grad_U_at_integration_pts = boost::make_shared&lt;MatrixDouble&gt;();</div>
<div class="line">pipeline_mng-&gt;<a class="code" href="group__mofem__basic__interface.html#gac52cdc08eaadd124e0224d7d9e0a13f5">getOpDomainRhsPipeline</a>().push_back(</div>
<div class="line">  <span class="keyword">new</span> <a class="code" href="classOpCalculateVectorFieldGradient.html">OpCalculateVectorFieldGradient&lt;FIELD_DIM, SPACE_DIM&gt;</a>(<span class="stringliteral">&quot;U&quot;</span>, grad_U_at_integration_pts));</div>
</div><!-- fragment --><p class="intertd">Operator for a given field calulates gradient of a vector field at integration points. Values are stored in for example in <em>grad_U_at_integration_pts</em>. Then value can be accessed as follows </p><div class="fragment"><div class="line">constexpr <span class="keywordtype">int</span> <a class="code" href="child__and__parent_8cpp.html#a662ea09b7a3c09effd6610d75fb7cbcb">FIELD_DIM</a> = 3;</div>
<div class="line">constexpr <span class="keywordtype">int</span> <a class="code" href="child__and__parent_8cpp.html#a541ffc988889246e44b233b777828847">SPACE_DIM</a> = 3;</div>
<div class="line"><a class="code" href="classFTensor_1_1Index.html">FTensor::Index&lt;'i', FIELD_DIM&gt;</a> <a class="code" href="hcurl__divergence__operator__2d_8cpp.html#a4c0436605284b64f6b0b5482594d86bc">i</a>; </div>
<div class="line"><a class="code" href="classFTensor_1_1Index.html">FTensor::Index&lt;'j', SPACE_DIM&gt;</a> <a class="code" href="matrix__function_8cpp.html#a8191f28ba278df9c5d32a75cadb2bbd5">j</a>; </div>
<div class="line">constexpr <span class="keyword">auto</span> <a class="code" href="free__surface_8cpp.html#a52438586143ef05bfe922220a317c144">t_kd</a> = <a class="code" href="classFTensor_1_1Kronecker__Delta.html">FTensor::Kronecker_Delta&lt;double&gt;</a>();</div>
<div class="line"><span class="keyword">auto</span> nb_integration_pts = vals_U_at_integration_pts-&gt;size2();</div>
<div class="line"><span class="keyword">auto</span> t_grad = getFTensor2FromMat&lt;FIELD_DIM, SPACE_DIM&gt;((grad_U_at_integration_pts);</div>
<div class="line"><span class="keywordflow">for</span>(<span class="keyword">auto</span> gg = 0;gg!=nb_integration_pts;++gg) {</div>
<div class="line">  <span class="keyword">auto</span> <a class="code" href="namespacePlasticOps.html#ad104160ccee829446f9f4701d5364629">trace</a> = t_grad(<a class="code" href="hcurl__divergence__operator__2d_8cpp.html#a4c0436605284b64f6b0b5482594d86bc">i</a>,<a class="code" href="matrix__function_8cpp.html#a8191f28ba278df9c5d32a75cadb2bbd5">j</a>)*<a class="code" href="free__surface_8cpp.html#a52438586143ef05bfe922220a317c144">t_kd</a>(<a class="code" href="hcurl__divergence__operator__2d_8cpp.html#a4c0436605284b64f6b0b5482594d86bc">i</a>,<a class="code" href="matrix__function_8cpp.html#a8191f28ba278df9c5d32a75cadb2bbd5">j</a>);</div>
<div class="line">  ++t_grad;</div>
<div class="line">}</div>
</div><!-- fragment --><p class="endtd"></p>
</td></tr>
<tr>
<td colspan="2"><b>Tensor fields</b> </td></tr>
<tr>
<td><p class="starttd">Evaluate tensor field at integration points <a class="el" href="structMoFEM_1_1OpCalculateTensor2FieldValues.html">MoFEM::OpCalculateTensor2FieldValues</a></p>
<p class="formulaDsp">
\[ u_{jk}^h(\pmb\xi^g) = \sum_i^N \phi^i(\pmb\xi^g) \overline{u}_i^{jk} \]
</p>
<p> where \(j\) and \(k\) are tensor element (coefficient) indices.</p>
<p class="intertd">This function has a similar variant to calculate rates, when a time solver is used, see <a class="el" href="structMoFEM_1_1OpCalculateTensor2FieldValuesDot.html">MoFEM::OpCalculateTensor2FieldValuesDot</a>, which can be used with time solver (TS).</p>
<p class="endtd"></p>
</td><td><p class="starttd"></p>
<p class="intertd">Basic usage: </p><div class="fragment"><div class="line">constexpr <span class="keywordtype">int</span> <a class="code" href="child__and__parent_8cpp.html#a662ea09b7a3c09effd6610d75fb7cbcb">FIELD_DIM</a> = 3;</div>
<div class="line"><span class="keyword">auto</span> vals_U_at_integration_pts = boost::make_shared&lt;MatrixDouble&gt;();</div>
<div class="line">pipeline_mng-&gt;<a class="code" href="group__mofem__basic__interface.html#gac52cdc08eaadd124e0224d7d9e0a13f5">getOpDomainRhsPipeline</a>().push_back(</div>
<div class="line">  <span class="keyword">new</span> OpCalculateTensor2FieldValues&lt;FIELD_DIM, FIELD_DIM&gt;(<span class="stringliteral">&quot;U&quot;</span>, vals_U_at_integration_pts));</div>
</div><!-- fragment --><p class="intertd">Operator for a given field calulates values of tensor field at integration points. Values are stored in, for example, <em>vals_U_at_integration_pts</em>. Then value can be accessed as follows </p><div class="fragment"><div class="line">constexpr <span class="keywordtype">int</span> <a class="code" href="child__and__parent_8cpp.html#a662ea09b7a3c09effd6610d75fb7cbcb">FIELD_DIM</a> = 3;</div>
<div class="line"><a class="code" href="classFTensor_1_1Index.html">FTensor::Index&lt;'i', FIELD_DIM&gt;</a> <a class="code" href="hcurl__divergence__operator__2d_8cpp.html#a4c0436605284b64f6b0b5482594d86bc">i</a>; </div>
<div class="line"><a class="code" href="classFTensor_1_1Index.html">FTensor::Index&lt;'j', FIELD_DIM&gt;</a> <a class="code" href="matrix__function_8cpp.html#a8191f28ba278df9c5d32a75cadb2bbd5">j</a>; </div>
<div class="line"><span class="keyword">auto</span> nb_integration_pts = vals_U_at_integration_pts-&gt;size2();</div>
<div class="line"><span class="keyword">auto</span> t_val = getFTensor2FromMat&lt;FIELD_DIM, FIELD_DIM&gt;((vals_U_at_integration_pts);</div>
<div class="line"><span class="keywordflow">for</span>(<span class="keyword">auto</span> gg = 0;gg!=nb_integration_pts;++gg) {</div>
<div class="line">  <span class="keyword">auto</span> norm = sqrt(t_val(<a class="code" href="hcurl__divergence__operator__2d_8cpp.html#a4c0436605284b64f6b0b5482594d86bc">i</a>,<a class="code" href="matrix__function_8cpp.html#a8191f28ba278df9c5d32a75cadb2bbd5">j</a>)*t_val(<a class="code" href="hcurl__divergence__operator__2d_8cpp.html#a4c0436605284b64f6b0b5482594d86bc">i</a>,<a class="code" href="matrix__function_8cpp.html#a8191f28ba278df9c5d32a75cadb2bbd5">j</a>));</div>
<div class="line">  ++t_val;</div>
<div class="line">}</div>
</div><!-- fragment --><p class="endtd"></p>
</td></tr>
<tr>
<td><p class="starttd">Evaluate <em>symmetric</em> tensor field at integration points <a class="el" href="structMoFEM_1_1OpCalculateTensor2SymmetricFieldValues.html">MoFEM::OpCalculateTensor2SymmetricFieldValues</a></p>
<p class="formulaDsp">
\[ u_{jk}^h(\pmb\xi^g) = \sum_i^N \phi^i(\pmb\xi^g) \overline{u}_i^{jk} \]
</p>
<p> where \(j\) and \(k\) are tensor element (coefficient) indices.</p>
<p class="intertd">Note that field degree of freedom represents only symmetric coefficients, so for each base function, we have a number of DOFs given by formula (FIELD_DIM * (FIELD_DIM + 1)) / 2. For example, for 3D case, six DOFs for each base function. <br  />
</p>
<p class="intertd">This function has a similar variant to calculate rates, when a time solver is used, see <a class="el" href="structMoFEM_1_1OpCalculateTensor2SymmetricFieldValuesDot.html">MoFEM::OpCalculateTensor2SymmetricFieldValuesDot</a>, which can be used with a time solver (TS).</p>
<p class="endtd"></p>
</td><td><p class="starttd"></p>
<p class="intertd">Basic usage: </p><div class="fragment"><div class="line">constexpr <span class="keywordtype">int</span> <a class="code" href="child__and__parent_8cpp.html#a662ea09b7a3c09effd6610d75fb7cbcb">FIELD_DIM</a> = 3;</div>
<div class="line"><span class="keyword">auto</span> vals_U_at_integration_pts = boost::make_shared&lt;MatrixDouble&gt;();</div>
<div class="line">pipeline_mng-&gt;<a class="code" href="group__mofem__basic__interface.html#gac52cdc08eaadd124e0224d7d9e0a13f5">getOpDomainRhsPipeline</a>().push_back(</div>
<div class="line">  <span class="keyword">new</span> OpCalculateTensor2SymmetricFieldValues&lt;FIELD_DIM&gt;(<span class="stringliteral">&quot;U&quot;</span>, vals_U_at_integration_pts));</div>
</div><!-- fragment --><p class="intertd">Operator for a given field calulates values of tensor field at integration points. Values are stored in, for example, <em>vals_U_at_integration_pts</em>. Then value can be accessed as follows </p><div class="fragment"><div class="line">constexpr <span class="keywordtype">int</span> <a class="code" href="child__and__parent_8cpp.html#a662ea09b7a3c09effd6610d75fb7cbcb">FIELD_DIM</a> = 3;</div>
<div class="line"><a class="code" href="classFTensor_1_1Index.html">FTensor::Index&lt;'i', FIELD_DIM&gt;</a> <a class="code" href="hcurl__divergence__operator__2d_8cpp.html#a4c0436605284b64f6b0b5482594d86bc">i</a>; </div>
<div class="line"><a class="code" href="classFTensor_1_1Index.html">FTensor::Index&lt;'j', FIELD_DIM&gt;</a> <a class="code" href="matrix__function_8cpp.html#a8191f28ba278df9c5d32a75cadb2bbd5">j</a>; </div>
<div class="line"><span class="keyword">auto</span> nb_integration_pts = vals_U_at_integration_pts-&gt;size2();</div>
<div class="line"><span class="keyword">auto</span> t_val = getFTensor2SymmetricFromMat&lt;FIELD_DIM&gt;((vals_U_at_integration_pts);</div>
<div class="line"><span class="keywordflow">for</span>(<span class="keyword">auto</span> gg = 0;gg!=nb_integration_pts;++gg) {</div>
<div class="line">  <span class="keyword">auto</span> norm = sqrt(t_val(<a class="code" href="hcurl__divergence__operator__2d_8cpp.html#a4c0436605284b64f6b0b5482594d86bc">i</a>,<a class="code" href="matrix__function_8cpp.html#a8191f28ba278df9c5d32a75cadb2bbd5">j</a>)*t_val(<a class="code" href="hcurl__divergence__operator__2d_8cpp.html#a4c0436605284b64f6b0b5482594d86bc">i</a>,<a class="code" href="matrix__function_8cpp.html#a8191f28ba278df9c5d32a75cadb2bbd5">j</a>));</div>
<div class="line">  ++t_val;</div>
<div class="line">}</div>
</div><!-- fragment --><p class="endtd"></p>
</td></tr>
<tr>
<td><p class="starttd"></p>
<p class="intertd">Evaluate tesorial field values for vectorial bases (Hdiv and Hcurl) <a class="el" href="structMoFEM_1_1OpCalculateHVecVectorField.html">MoFEM::OpCalculateHVecVectorField</a></p>
<p class="formulaDsp">
\[ u_{j}^h(\pmb\xi^g) = \sum_i^N \phi^i_j(\pmb\xi^g) \overline{u}_i^{jk} \]
</p>
<p> where \(j\) and \(k\) tensor element (coefficient) indices.</p>
<p class="endtd"></p>
</td><td><p class="starttd"></p>
<p class="intertd">Example </p><div class="fragment"><div class="line">constexpr <span class="keywordtype">int</span> <a class="code" href="dg__projection_8cpp.html#a87778f5f0ec7eba11e8f327af2258018">BASE_DIM</a> = 3;</div>
<div class="line"><span class="keyword">auto</span> vals_integration_pts = boost::make_shared&lt;MatrixDouble&gt;();</div>
<div class="line">pipeline_mng-&gt;<a class="code" href="group__mofem__basic__interface.html#gac52cdc08eaadd124e0224d7d9e0a13f5">getOpDomainRhsPipeline</a>().push_back(</div>
<div class="line">          <span class="keyword">new</span> OpCalculateHVecTensorField&lt;3, 3&gt;(</div>
<div class="line">            <a class="code" href="poisson__2d__homogeneous_8cpp.html#a3917f3987bad1f4e24b85c9d0ab84a5e">field_name</a>, vals_integration_pts));</div>
</div><!-- fragment --><p class="endtd"></p>
</td></tr>
<tr>
</tr>
</table>
<table class="doxtable">
</table>
<p>User data operators are defined in file <a class="el" href="UserDataOperators_8hpp.html">UserDataOperators.hpp</a></p>
<h1><a class="anchor" id="tab_other_data_op"></a>
Other operators</h1>
<a class="anchor" id="user_other_ops_table"></a>
<table class="doxtable">
<caption>Table of other operators</caption>
<tr style="width:100%">
<th style="width:50%">Operator </th><th style="width:50%">Usage </th></tr>
<tr>
<td colspan="2"><b>Face operators</b> </td></tr>
<tr>
<td><p class="starttd">Calculate Jacobian and inverse Jacobian on face. See MoFEM::OpCalculateJacForFace and <a class="el" href="structMoFEM_1_1OpInvertMatrix.html">MoFEM::OpInvertMatrix</a></p>
<p class="intertd">For 2D element on plane XY, Jacobian is given by, </p><p class="formulaDsp">
\[ J_{ij} = \frac{\partial X_i}{\partial \xi_j},\quad i,j=0,1 \]
</p>
<dl class="section note"><dt>Note</dt><dd>For 3D volume element, the operator is not implemented explicitly. In current implementation, Jacobian is calculated implicitly, and derivatives of shape functions are pushed to the current configuration.</dd>
<dd>
For face element, it is uncertain what developer do, whether it calculates problem in 2D, or do integration on the adjacent face of 3D element, or face element is embedded in 3D, i.e. solve 2 and 1/2 dimension problem. See also MoFEM::OpCalculateInvJacForFaceEmbeddedIn3DSpace</dd></dl>
</td><td>Example usage <div class="fragment"><div class="line"><span class="keyword">auto</span> det_ptr = boost::make_shared&lt;VectorDouble&gt;();</div>
<div class="line"><span class="keyword">auto</span> jac_ptr = boost::make_shared&lt;MatrixDouble&gt;();</div>
<div class="line"><span class="keyword">auto</span> inv_jac_ptr = boost::make_shared&lt;MatrixDouble&gt;();</div>
<div class="line">pipeline_mng-&gt;<a class="code" href="group__mofem__basic__interface.html#gac52cdc08eaadd124e0224d7d9e0a13f5">getOpDomainRhsPipeline</a>().push_back(</div>
<div class="line">  <span class="keyword">new</span> OpCalculateJacForFace(jac_ptr));</div>
<div class="line">pipeline_mng-&gt;<a class="code" href="group__mofem__basic__interface.html#gac52cdc08eaadd124e0224d7d9e0a13f5">getOpDomainRhsPipeline</a>().push_back(</div>
<div class="line">  <span class="keyword">new</span> OpInvertMatrix&lt;2&gt;(jac_ptr, det_ptr, inv_jac_ptr));</div>
</div><!-- fragment --> </td></tr>
<tr>
<td><p class="starttd"></p>
<p class="intertd">Push face base function to physical element configuration. <a class="el" href="structMoFEM_1_1OpSetHOInvJacToScalarBases.html">MoFEM::OpSetHOInvJacToScalarBases&lt;2&gt;</a> This operator assumes that the face element is on the XY plane.</p>
<p class="formulaDsp">
\[ \frac{\partial \phi}{\partial X_i} = \frac{\partial \phi}{\partial \xi_j} J^{-1}_{ij} \]
</p>
<dl class="section note"><dt>Note</dt><dd>For face element, it is uncertain what developer do, whether it calculates problem in 2D, or do integration on the adjacent face of 3D element, or face element is embedded in 3D, i.e. solve 2 and 1/2 dimension problem. See also <a class="el" href="structMoFEM_1_1OpSetInvJacH1ForFaceEmbeddedIn3DSpace.html">MoFEM::OpSetInvJacH1ForFaceEmbeddedIn3DSpace</a></dd></dl>
</td><td><p class="starttd">Example usage </p><div class="fragment"><div class="line"><span class="keyword">auto</span> inv_jac_ptr = boost::make_shared&lt;MatrixDouble&gt;();</div>
<div class="line">pipeline_mng-&gt;<a class="code" href="group__mofem__basic__interface.html#gac52cdc08eaadd124e0224d7d9e0a13f5">getOpDomainRhsPipeline</a>().push_back(</div>
<div class="line">  <span class="keyword">new</span> OpSetHOInvJacToScalarBases&lt;2&gt;(inv_jac_ptr));</div>
</div><!-- fragment --><p class="endtd"></p>
</td></tr>
<tr>
<td><p class="starttd"></p>
<p class="intertd">Apply contravariant (Piola) transfer to Hdiv space on face <a class="el" href="namespaceMoFEM.html#aa31b19346629cc2f84fb4333f981989d">MoFEM::OpSetContravariantPiolaTransformOnFace2D</a> and <a class="el" href="namespaceMoFEM.html#a1581cdd9218a980e2aad036d0ac8b2ae">MoFEM::OpSetContravariantPiolaTransformOnFace2DEmbeddedIn3DSpace</a></p>
<p class="intertd">Contravariant Piola transformation </p><p class="formulaDsp">
\[ \psi_i = \frac{1}{\textrm{det}(J)}J_{ij}\hat{\psi}_j\\ \frac{\partial \psi_i}{\partial \xi_j} = \frac{1}{\textrm{det}(J)}J_{ik}\frac{\partial \hat{\psi}_k}{\partial \xi_j} \]
</p>
<p class="endtd"></p>
</td><td><p class="starttd"></p>
<p class="intertd">Example for 2D problem for face in XY space </p><div class="fragment"><div class="line"><span class="keyword">auto</span> jac_ptr = boost::make_shared&lt;MatrixDouble&gt;();</div>
<div class="line">pipeline_mng-&gt;<a class="code" href="group__mofem__basic__interface.html#gac52cdc08eaadd124e0224d7d9e0a13f5">getOpDomainRhsPipeline</a>().push_back(</div>
<div class="line">    <span class="keyword">new</span> OpCalculateJacForFace(jac_ptr));</div>
<div class="line">pipeline_mng-&gt;<a class="code" href="group__mofem__basic__interface.html#gac52cdc08eaadd124e0224d7d9e0a13f5">getOpDomainRhsPipeline</a>().push_back(</div>
<div class="line">    <span class="keyword">new</span> OpMakeHdivFromHcurl());</div>
<div class="line">pipeline_mng-&gt;<a class="code" href="group__mofem__basic__interface.html#gac52cdc08eaadd124e0224d7d9e0a13f5">getOpDomainRhsPipeline</a>().push_back(</div>
<div class="line">    <span class="keyword">new</span> <a class="code" href="namespaceMoFEM.html#aa31b19346629cc2f84fb4333f981989d">OpSetContravariantPiolaTransformOnFace2D</a>(jac_ptr))</div>
</div><!-- fragment --><p class="intertd">Example for face emerged in 3D space </p><div class="fragment"><div class="line"><span class="keyword">auto</span> det_ptr = boost::make_shared&lt;VectorDouble&gt;();</div>
<div class="line"><span class="keyword">auto</span> jac_ptr = boost::make_shared&lt;MatrixDouble&gt;();</div>
<div class="line"><span class="keyword">auto</span> inv_jac_ptr = boost::make_shared&lt;MatrixDouble&gt;();</div>
<div class="line">pipeline_mng-&gt;<a class="code" href="group__mofem__basic__interface.html#gac52cdc08eaadd124e0224d7d9e0a13f5">getOpDomainRhsPipeline</a>().push_back(</div>
<div class="line">  <span class="keyword">new</span> OpCalculateJacForFaceEmbeddedIn3DSpace(jac_ptr));</div>
<div class="line">pipeline.push_back(<span class="keyword">new</span> OpInvertMatrix&lt;3&gt;(jac_ptr, det_ptr, inv_jac_ptr));</div>
<div class="line">pipeline_mng-&gt;<a class="code" href="group__mofem__basic__interface.html#gac52cdc08eaadd124e0224d7d9e0a13f5">getOpDomainRhsPipeline</a>().push_back(</div>
<div class="line">  <span class="keyword">new</span> OpMakeHdivFromHcurl());</div>
<div class="line">pipeline_mng-&gt;<a class="code" href="group__mofem__basic__interface.html#gac52cdc08eaadd124e0224d7d9e0a13f5">getOpDomainRhsPipeline</a>().push_back(</div>
<div class="line">  <span class="keyword">new</span> </div>
<div class="line">  <a class="code" href="namespaceMoFEM.html#a1581cdd9218a980e2aad036d0ac8b2ae">OpSetContravariantPiolaTransformOnFace2DEmbeddedIn3DSpace</a>(jac_ptr));</div>
</div><!-- fragment --><p> Note, in this case problem is 2D, however surface on which PDE is solved is emerged in 3D space.</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><p class="starttd"></p>
<p class="intertd">Transform local reference derivatives of shape function to global derivatives for face <a class="el" href="namespaceMoFEM.html#a033d6e09a0edb97bf505545cfe554a69">MoFEM::OpSetInvJacHcurlFace</a> and <a class="el" href="namespaceMoFEM.html#a60e54b179e8dc7c61aa47f7abcb2ae42">MoFEM::OpSetInvJacHcurlFaceEmbeddedIn3DSpace</a></p>
<p class="formulaDsp">
\[ \frac{\partial \psi_i}{\partial X_j}= \frac{\partial \psi_i}{\partial \xi_k} \frac{\partial \xi_k}{\partial X_j} \]
</p>
<p class="endtd"></p>
</td><td><p class="starttd"></p>
<p class="intertd">Example for 2D problem for face in XY space </p><div class="fragment"><div class="line"><span class="keyword">auto</span> jac_ptr = boost::make_shared&lt;MatrixDouble&gt;();</div>
<div class="line">pipeline_mng-&gt;<a class="code" href="group__mofem__basic__interface.html#gac52cdc08eaadd124e0224d7d9e0a13f5">getOpDomainRhsPipeline</a>().push_back(</div>
<div class="line">    <span class="keyword">new</span> OpCalculateJacForFace(jac_ptr));</div>
<div class="line">pipeline_mng-&gt;<a class="code" href="group__mofem__basic__interface.html#gac52cdc08eaadd124e0224d7d9e0a13f5">getOpDomainRhsPipeline</a>().push_back(</div>
<div class="line">    <span class="keyword">new</span> OpMakeHdivFromHcurl());</div>
<div class="line">pipeline_mng-&gt;<a class="code" href="group__mofem__basic__interface.html#gac52cdc08eaadd124e0224d7d9e0a13f5">getOpDomainRhsPipeline</a>().push_back(</div>
<div class="line">    <span class="keyword">new</span> <a class="code" href="namespaceMoFEM.html#aa31b19346629cc2f84fb4333f981989d">OpSetContravariantPiolaTransformOnFace2D</a>(jac_ptr));</div>
<div class="line">pipeline_mng-&gt;<a class="code" href="group__mofem__basic__interface.html#gac52cdc08eaadd124e0224d7d9e0a13f5">getOpDomainRhsPipeline</a>().push_back(</div>
<div class="line">    <span class="keyword">new</span> <a class="code" href="namespaceMoFEM.html#aa31b19346629cc2f84fb4333f981989d">OpSetContravariantPiolaTransformOnFace2D</a>(jac_ptr))    </div>
</div><!-- fragment --><p class="endtd"></p>
</td></tr>
<tr>
<td><p class="starttd"></p>
<p class="intertd">Make H-div space from H-curl space in 2D <a class="el" href="structMoFEM_1_1OpMakeHdivFromHcurl.html">MoFEM::OpMakeHdivFromHcurl</a></p>
<p class="formulaDsp">
\[ \pmb \psi^\textrm{Hdiv} = \left\{ \psi^\textrm{Hcurl}_{1}, -\psi^\textrm{Hcurl}_{0}, 0 \right\} \]
</p>
<p> where \(\psi^\textrm{Hdiv}\) are base functions for H-div space.</p>
<p class="intertd">Note that applying function twice will transform base from H-curl space and then back to H-div space.</p>
<p class="endtd"></p>
</td><td><p class="starttd"></p>
<p class="intertd">Example for 2D problem for face in XY space </p><div class="fragment"><div class="line"><span class="keyword">auto</span> jac_ptr = boost::make_shared&lt;MatrixDouble&gt;();</div>
<div class="line">pipeline_mng-&gt;<a class="code" href="group__mofem__basic__interface.html#gac52cdc08eaadd124e0224d7d9e0a13f5">getOpDomainRhsPipeline</a>().push_back(</div>
<div class="line">    <span class="keyword">new</span> OpCalculateJacForFace(jac_ptr));</div>
<div class="line">pipeline_mng-&gt;<a class="code" href="group__mofem__basic__interface.html#gac52cdc08eaadd124e0224d7d9e0a13f5">getOpDomainRhsPipeline</a>().push_back(</div>
<div class="line">    <span class="keyword">new</span> OpMakeHdivFromHcurl());</div>
<div class="line">pipeline_mng-&gt;<a class="code" href="group__mofem__basic__interface.html#gac52cdc08eaadd124e0224d7d9e0a13f5">getOpDomainRhsPipeline</a>().push_back(</div>
<div class="line">    <span class="keyword">new</span> <a class="code" href="namespaceMoFEM.html#aa31b19346629cc2f84fb4333f981989d">OpSetContravariantPiolaTransformOnFace2D</a>(jac_ptr));</div>
<div class="line">pipeline_mng-&gt;<a class="code" href="group__mofem__basic__interface.html#gac52cdc08eaadd124e0224d7d9e0a13f5">getOpDomainRhsPipeline</a>().push_back(</div>
<div class="line">    <span class="keyword">new</span> <a class="code" href="namespaceMoFEM.html#aa31b19346629cc2f84fb4333f981989d">OpSetContravariantPiolaTransformOnFace2D</a>(jac_ptr))    </div>
</div><!-- fragment --><p class="endtd"></p>
</td></tr>
<tr>
<td><p class="starttd"></p>
<p class="intertd">Modify integration weights on face to take in account higher-order geometry <a class="el" href="structMoFEM_1_1OpSetHOWeightsOnFace.html">MoFEM::OpSetHOWeightsOnFace</a></p>
<p class="intertd">Suppose Jacobian is not constant on the finite element, then this operator sets integration weights to take into account the geometry of the finite element, that is, a case for a non-parallelepiped quad. Also, that is a case for any face element given by higher-order geometry approximation. Note that geometry in <a class="el" href="namespaceMoFEM.html" title="implementation of Data Operators for Forces and Sources">MoFEM</a> can be represented by an arbitrary order approximation field.</p>
<p class="formulaDsp">
\[ w^g = \left(\frac{\|J(\pmb\xi^g)\|}{A}\right) W^g \]
</p>
<p> where \(w^g\) is weight on update configuration, \(W^g\) integration weight at intergration point \(g\), at reference point \(\pmb\xi^g\). \(\|J(\pmb\xi^g)\|\) is determinant of the Jacobian, and \(A\) is area of face element.</p>
<p class="endtd"></p>
</td><td><p class="starttd"></p>
<p class="intertd">Example </p><div class="fragment"><div class="line">pipeline_mng-&gt;<a class="code" href="group__mofem__basic__interface.html#ga4b4225b4e1f114d604552ad8ec176486">getOpDomainLhsPipeline</a>().push_back(</div>
<div class="line">    <span class="keyword">new</span> OpSetHOWeightsOnFace());</div>
</div><!-- fragment --><p class="endtd"></p>
</td></tr>
<tr>
<td colspan="2"><b>Generic operators</b> </td></tr>
<tr>
<td><p class="starttd"></p>
<p class="intertd">Scale base (default L2) functions by inverses of measure of element <a class="el" href="structMoFEM_1_1OpScaleBaseBySpaceInverseOfMeasure.html">MoFEM::OpScaleBaseBySpaceInverseOfMeasure</a></p>
<p class="intertd">Scale base </p><p class="formulaDsp">
\[ \overline{\phi}^m = \frac{1}{\mu(\Omega^e)} \phi^m \]
</p>
<p> where \(\mu(\Omega^e)\) is length, area or volume, depending on dimension of the finite elemen entitiy. Note that function scales also base function derivatives.</p>
<p class="endtd"></p>
</td><td><p class="starttd"></p>
<p class="intertd">Call that functions at front of the operators, before you evaluate field on given space, i.e. L2 space.</p>
<p class="intertd">Example: </p><div class="fragment"><div class="line"><span class="keyword">using</span> OpScaleL2 = <a class="code" href="structMoFEM_1_1OpScaleBaseBySpaceInverseOfMeasure.html">MoFEM::OpScaleBaseBySpaceInverseOfMeasure&lt;DomainEleOp&gt;</a>;</div>
<div class="line">pipeline_mng-&gt;<a class="code" href="group__mofem__basic__interface.html#ga4b4225b4e1f114d604552ad8ec176486">getOpDomainLhsPipeline</a>().push_back(</div>
<div class="line">      <span class="keyword">new</span> OpScaleL2());</div>
</div><!-- fragment --><p class="endtd"></p>
</td></tr>
<tr>
</tr>
</table>
<table class="doxtable">
</table>
<p>User data operators are defined in file <a class="el" href="UserDataOperators_8hpp.html">UserDataOperators.hpp</a></p>
<h1><a class="anchor" id="tab_linear_forms"></a>
Linear forms</h1>
<a class="anchor" id="user_linear_forms_ops_table"></a>
<table class="doxtable">
<caption>Table of linear from operators</caption>
<tr style="width:100%">
<th style="width:50%">Operator </th><th style="width:50%">Usage </th></tr>
<tr>
<td><p class="starttd"></p>
<p class="intertd">Integrate source term for scalar and vectorial fields <a class="el" href="structMoFEM_1_1OpSourceImpl.html">MoFEM::OpSourceImpl</a></p>
<p class="formulaDsp">
\[ (v_i,f_i(\mathbf{x}))_\Omega = \int_\Omega v_i f_i (x,y,z) \textrm{d}\Omega \]
</p>
<p class="intertd">Template arguments: </p><div class="fragment"><div class="line"><span class="keyword">using</span> OpSource = </div>
<div class="line">  FormsIntegrators&lt;OP&gt;::</div>
<div class="line">  Assembly&lt;ASSEMBLE_TYPE&gt;::</div>
<div class="line">  LinearForm&lt;INTEGRATION_TYPE&gt;::</div>
<div class="line">  OpSource&lt;BASE_DIM, FIELD_DIM&gt;;</div>
</div><!-- fragment --><p class="endtd"></p>
</td><td><p class="starttd"></p>
<p class="intertd">Example usage for scalar base and scalar field: </p><div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="child__and__parent_8cpp.html#a4d5d1673a6198f0cb09118e6db333d6f">OpDomainSource</a> = FormsIntegrators&lt;DomainEleOp&gt;::Assembly&lt;</div>
<div class="line">    <a class="code" href="group__mofem__forms.html#ggabb82cd10e89a1d4d25fa7756360b181ba2243b0abb08ad80d05c47e734f3134bc">PETSC</a>&gt;::LinearForm&lt;GAUSS&gt;::OpSource&lt;1, 1&gt;;</div>
<div class="line"><span class="keyword">auto</span> <a class="code" href="dg__projection_8cpp.html#a47f5c9a54ebf753d18651f417f81f4e8">fun</a> = [](<span class="keywordtype">double</span> x, <span class="keywordtype">double</span> y, <span class="keywordtype">double</span> z) {</div>
<div class="line">  <span class="keywordflow">return</span> sin(x/<a class="code" href="namespaceMoFEM.html#a123875fb03925a9640697591e972412c">L</a>)*sin(y/<a class="code" href="namespaceMoFEM.html#a123875fb03925a9640697591e972412c">L</a>)*sin(z/<a class="code" href="namespaceMoFEM.html#a123875fb03925a9640697591e972412c">L</a>);</div>
<div class="line">};</div>
<div class="line">pipeline_mng-&gt;<a class="code" href="group__mofem__basic__interface.html#gac52cdc08eaadd124e0224d7d9e0a13f5">getOpDomainRhsPipeline</a>().push_back(</div>
<div class="line">  <span class="keyword">new</span> <a class="code" href="child__and__parent_8cpp.html#a4d5d1673a6198f0cb09118e6db333d6f">OpDomainSource</a>(<span class="stringliteral">&quot;U&quot;</span>, <a class="code" href="dg__projection_8cpp.html#a47f5c9a54ebf753d18651f417f81f4e8">fun</a>));</div>
</div><!-- fragment --><p class="intertd">Example usage for scalar base and vector field: </p><div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="child__and__parent_8cpp.html#a4d5d1673a6198f0cb09118e6db333d6f">OpDomainSource</a> = FormsIntegrators&lt;DomainEleOp&gt;::Assembly&lt;</div>
<div class="line">    <a class="code" href="group__mofem__forms.html#ggabb82cd10e89a1d4d25fa7756360b181ba2243b0abb08ad80d05c47e734f3134bc">PETSC</a>&gt;::LinearForm&lt;GAUSS&gt;::OpSource&lt;1, 3&gt;;</div>
<div class="line"><span class="keyword">auto</span> <a class="code" href="dg__projection_8cpp.html#a47f5c9a54ebf753d18651f417f81f4e8">fun</a> = [](<span class="keywordtype">double</span> x, <span class="keywordtype">double</span> y, <span class="keywordtype">double</span> z) {</div>
<div class="line">  <span class="keywordflow">return</span> <a class="code" href="classFTensor_1_1Tensor1.html">FTensor::Tensor1&lt;double&gt;</a>{ sin(x/<a class="code" href="namespaceMoFEM.html#a123875fb03925a9640697591e972412c">L</a>), sin(y/<a class="code" href="namespaceMoFEM.html#a123875fb03925a9640697591e972412c">L</a>), sin(z/<a class="code" href="namespaceMoFEM.html#a123875fb03925a9640697591e972412c">L</a>) };</div>
<div class="line">};</div>
<div class="line">pipeline_mng-&gt;<a class="code" href="group__mofem__basic__interface.html#gac52cdc08eaadd124e0224d7d9e0a13f5">getOpDomainRhsPipeline</a>().push_back(</div>
<div class="line">  <span class="keyword">new</span> <a class="code" href="child__and__parent_8cpp.html#a4d5d1673a6198f0cb09118e6db333d6f">OpDomainSource</a>(<span class="stringliteral">&quot;U&quot;</span>, <a class="code" href="dg__projection_8cpp.html#a47f5c9a54ebf753d18651f417f81f4e8">fun</a>));</div>
</div><!-- fragment --><p class="intertd">Example usage for vector base and vector field: </p><div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="child__and__parent_8cpp.html#a4d5d1673a6198f0cb09118e6db333d6f">OpDomainSource</a> = FormsIntegrators&lt;DomainEleOp&gt;::Assembly&lt;</div>
<div class="line">    <a class="code" href="group__mofem__forms.html#ggabb82cd10e89a1d4d25fa7756360b181ba2243b0abb08ad80d05c47e734f3134bc">PETSC</a>&gt;::LinearForm&lt;GAUSS&gt;::OpSource&lt;3, 3&gt;;</div>
<div class="line"><span class="keyword">auto</span> <a class="code" href="dg__projection_8cpp.html#a47f5c9a54ebf753d18651f417f81f4e8">fun</a> = [](<span class="keywordtype">double</span> x, <span class="keywordtype">double</span> y, <span class="keywordtype">double</span> z) {</div>
<div class="line">  <span class="keywordflow">return</span> <a class="code" href="classFTensor_1_1Tensor1.html">FTensor::Tensor1&lt;double&gt;</a>{ sin(x/<a class="code" href="namespaceMoFEM.html#a123875fb03925a9640697591e972412c">L</a>), sin(y/<a class="code" href="namespaceMoFEM.html#a123875fb03925a9640697591e972412c">L</a>), sin(z/<a class="code" href="namespaceMoFEM.html#a123875fb03925a9640697591e972412c">L</a>) };</div>
<div class="line">};</div>
<div class="line">pipeline_mng-&gt;<a class="code" href="group__mofem__basic__interface.html#gac52cdc08eaadd124e0224d7d9e0a13f5">getOpDomainRhsPipeline</a>().push_back(</div>
<div class="line">  <span class="keyword">new</span> <a class="code" href="child__and__parent_8cpp.html#a4d5d1673a6198f0cb09118e6db333d6f">OpDomainSource</a>(<span class="stringliteral">&quot;U&quot;</span>, <a class="code" href="dg__projection_8cpp.html#a47f5c9a54ebf753d18651f417f81f4e8">fun</a>));</div>
</div><!-- fragment --><p class="endtd"></p>
</td></tr>
<tr>
<td><p class="starttd"></p>
<p class="intertd">Integrate term for discrete scalar fields <a class="el" href="structMoFEM_1_1OpBaseTimesScalarImpl.html">MoFEM::OpBaseTimesScalarImpl</a></p>
<div class="fragment"><div class="line"><span class="keyword">using</span> OpBaseTimesV = FormsIntegrators&lt;DomainEleOp&gt;::Assembly&lt;<a class="code" href="group__mofem__forms.html#ggabb82cd10e89a1d4d25fa7756360b181ba2243b0abb08ad80d05c47e734f3134bc">PETSC</a>&gt;::LinearForm&lt;</div>
<div class="line">    <a class="code" href="group__mofem__forms.html#gga2136fdd1cb130ca18f645e799b05569faccb6b64b4a909e6408f40132996fdced">GAUSS</a>&gt;::OpBaseTimesScalar&lt;BASE_DIM&gt;;</div>
</div><!-- fragment --><p class="endtd"></p>
</td><td><p class="starttd"></p>
<p class="intertd">Example </p><div class="fragment"><div class="line"><span class="keyword">using</span> OpBaseTimesV = FormsIntegrators&lt;DomainEleOp&gt;::Assembly&lt;<a class="code" href="group__mofem__forms.html#ggabb82cd10e89a1d4d25fa7756360b181ba2243b0abb08ad80d05c47e734f3134bc">PETSC</a>&gt;::LinearForm&lt;</div>
<div class="line">    <a class="code" href="group__mofem__forms.html#gga2136fdd1cb130ca18f645e799b05569faccb6b64b4a909e6408f40132996fdced">GAUSS</a>&gt;::OpBaseTimesScalar&lt;1&gt;;</div>
<div class="line"><span class="keyword">auto</span> vec_at_gauss_pts = boost::make_shared&lt;VectorDouble&gt;();</div>
<div class="line"><span class="comment">// Push operator which sets vec_at_gauss_pts</span></div>
<div class="line">pipeline_mng-&gt;<a class="code" href="group__mofem__basic__interface.html#gac52cdc08eaadd124e0224d7d9e0a13f5">getOpDomainRhsPipeline</a>().push_back(</div>
<div class="line">  <span class="keyword">new</span> OpBaseTimesV(<span class="stringliteral">&quot;U&quot;</span>, vec_ptr_at_gauss_pts));</div>
</div><!-- fragment --><p class="endtd"></p>
</td></tr>
<tr>
<td><p class="starttd"></p>
<p class="intertd">Integrate term for discrete vector fields <a class="el" href="structMoFEM_1_1OpBaseTimesScalarImpl.html">MoFEM::OpBaseTimesScalarImpl</a></p>
<div class="fragment"><div class="line"><span class="keyword">using</span> OpBaseTimesM = FormsIntegrators&lt;DomainEleOp&gt;::Assembly&lt;<a class="code" href="group__mofem__forms.html#ggabb82cd10e89a1d4d25fa7756360b181ba2243b0abb08ad80d05c47e734f3134bc">PETSC</a>&gt;::LinearForm&lt;</div>
<div class="line">    <a class="code" href="group__mofem__forms.html#gga2136fdd1cb130ca18f645e799b05569faccb6b64b4a909e6408f40132996fdced">GAUSS</a>&gt;::OpBaseTimesVector&lt;BASE_DIM, FIELD_DIM, S&gt;;</div>
</div><!-- fragment --><p class="endtd"></p>
</td><td><p class="starttd"></p>
<p class="intertd">Example for scalar base and field vector field (e.g. body forces) </p><div class="fragment"><div class="line"><span class="keyword">using</span> OpBaseFlux = FormsIntegrators&lt;DomainEleOp&gt;::Assembly&lt;<a class="code" href="group__mofem__forms.html#ggabb82cd10e89a1d4d25fa7756360b181ba2243b0abb08ad80d05c47e734f3134bc">PETSC</a>&gt;::LinearForm&lt;</div>
<div class="line">    <a class="code" href="group__mofem__forms.html#gga2136fdd1cb130ca18f645e799b05569faccb6b64b4a909e6408f40132996fdced">GAUSS</a>&gt;::OpBaseTimesVector&lt;1, 3, 0&gt;;</div>
<div class="line"><span class="keyword">auto</span> body_force = boost::make_shared&lt;MatrixDouble&gt;();</div>
<div class="line"><span class="keyword">auto</span> t_body_force = getFTensor1FromMat&lt;3, 0&gt;(*body_force);</div>
<div class="line">t_body_force(0) = 0;</div>
<div class="line">t_body_force(1) = 0;</div>
<div class="line">t_body_force(2) = -9.81;</div>
<div class="line">pipeline_mng-&gt;<a class="code" href="group__mofem__basic__interface.html#gac52cdc08eaadd124e0224d7d9e0a13f5">getOpDomainRhsPipeline</a>().push_back(</div>
<div class="line">  <span class="keyword">new</span> OpBaseFlux(<span class="stringliteral">&quot;U&quot;</span>, body_force));</div>
</div><!-- fragment --><p class="intertd">Example for base in Hdiv space and field in Hdiv space </p><div class="fragment"><div class="line"><span class="keyword">using</span> OpBaseFlux = FormsIntegrators&lt;DomainEleOp&gt;::Assembly&lt;<a class="code" href="group__mofem__forms.html#ggabb82cd10e89a1d4d25fa7756360b181ba2243b0abb08ad80d05c47e734f3134bc">PETSC</a>&gt;::LinearForm&lt;</div>
<div class="line">    <a class="code" href="group__mofem__forms.html#gga2136fdd1cb130ca18f645e799b05569faccb6b64b4a909e6408f40132996fdced">GAUSS</a>&gt;::OpBaseTimesVector&lt;3, 3, 1&gt;;</div>
<div class="line"><span class="keyword">auto</span> flux_at_gauss_pts = boost::make_shared&lt;MatrixDouble&gt;();</div>
<div class="line"><span class="comment">// Push operator which sets flux at integration points</span></div>
<div class="line">pipeline_mng-&gt;<a class="code" href="group__mofem__basic__interface.html#gac52cdc08eaadd124e0224d7d9e0a13f5">getOpDomainRhsPipeline</a>().push_back(</div>
<div class="line">  <span class="keyword">new</span> OpBaseFlux(<span class="stringliteral">&quot;U&quot;</span>, flux_at_gauss_pts));</div>
</div><!-- fragment --><p class="endtd"></p>
</td></tr>
<tr>
<td><p class="starttd"></p>
<p class="intertd">Integrate natural boundary condidition </p><div class="fragment"><div class="line"><a class="code" href="structMoFEM_1_1OpNormalMixVecTimesScalarImpl.html">MoFEM::OpNormalMixVecTimesScalarImpl</a></div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">using</span> OpMixNaturalBC = FormsIntegrators&lt;BoundaryEleOp&gt;::Assembly&lt;<a class="code" href="group__mofem__forms.html#ggabb82cd10e89a1d4d25fa7756360b181ba2243b0abb08ad80d05c47e734f3134bc">PETSC</a>&gt;::LinearForm&lt;</div>
<div class="line">    <a class="code" href="group__mofem__forms.html#gga2136fdd1cb130ca18f645e799b05569faccb6b64b4a909e6408f40132996fdced">GAUSS</a>&gt;::OpBaseTimesVector&lt;3&gt;;</div>
</div><!-- fragment --><p class="endtd"></p>
</td><td><p class="starttd"></p>
<p class="intertd">Example </p><div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="structMoFEM_1_1OpFluxRhsImpl.html">OpTemperatureBC</a> = FormsIntegrators&lt;BoundaryEleOp&gt;::Assembly&lt;</div>
<div class="line">    <a class="code" href="group__mofem__forms.html#ggabb82cd10e89a1d4d25fa7756360b181ba2243b0abb08ad80d05c47e734f3134bc">PETSC</a>&gt;::LinearForm&lt;GAUSS&gt;::OpNormalMixVecTimesScalar&lt;<a class="code" href="child__and__parent_8cpp.html#a541ffc988889246e44b233b777828847">SPACE_DIM</a>&gt;;</div>
<div class="line">pipeline.push_back(</div>
<div class="line">   <span class="keyword">new</span> <a class="code" href="thermo__elastic_8cpp.html#a9136f58c96b1f4e005800f4edc7d4904">OpTemperatureBC</a>(<span class="stringliteral">&quot;FLUX&quot;</span>, [](<span class="keywordtype">double</span>,<span class="keywordtype">double</span>.<span class="keywordtype">double</span>) { <span class="keywordflow">return</span> 1;},</div>
<div class="line">                      boost::make_shared&lt;Range&gt;(skin_edges)));</div>
</div><!-- fragment --><p> Example usage <a class="el" href="thermo__elastic_8cpp.html">thermo_elastic.cpp</a></p>
<p class="endtd"></p>
</td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>Linear froms are defined in file <a class="el" href="LinearFormsIntegrators_8hpp.html" title="Linear forms integrators.">LinearFormsIntegrators.hpp</a></dd></dl>
<h1><a class="anchor" id="tab_bilinear_forms"></a>
Bilinear forms</h1>
<a class="anchor" id="user_bilinear_forms_ops_table"></a>
<table class="doxtable">
<caption>Table of bilinear from operators</caption>
<tr style="width:100%">
<th style="width:50%">Operator </th><th style="width:50%">Usage </th></tr>
<tr>
<td><p class="starttd">Integrate Grad Grad operator <a class="el" href="structMoFEM_1_1OpGradGradImpl.html">MoFEM::OpGradGradImpl</a></p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="helmholtz_8cpp.html#ab00a435c2cfb8b6e8e71eabe83ddeb07">OpDomainGradGrad</a> = </div>
<div class="line">  FormsIntegrators&lt;OP&gt;::Assembly&lt;ASSEMBLY_TYPE&gt;::</div>
<div class="line">  BiLinearForm&lt;INTEGRATION_TYPE&gt;::</div>
<div class="line">  OpGradGrad&lt;BASE_DIM, FIELD_DIM, SPACE_DIM&gt;;</div>
</div><!-- fragment --><p class="endtd"></p>
</td><td><p class="starttd"></p>
<p class="endtd">Example for scalar base, scalar field and 3D problem </p><div class="fragment"><div class="line"><span class="keyword">auto</span> beta = [](<span class="keywordtype">double</span> x, <span class="keywordtype">double</span> y , <span class="keywordtype">double</span> z) {</div>
<div class="line">  <span class="keywordflow">return</span> 1;</div>
<div class="line">};</div>
<div class="line"><span class="keyword">using</span> <a class="code" href="helmholtz_8cpp.html#ab00a435c2cfb8b6e8e71eabe83ddeb07">OpDomainGradGrad</a> = FormsIntegrators&lt;DomainEleOp&gt;::Assembly&lt;</div>
<div class="line">    <a class="code" href="group__mofem__forms.html#ggabb82cd10e89a1d4d25fa7756360b181ba2243b0abb08ad80d05c47e734f3134bc">PETSC</a>&gt;<a class="code" href="classBiLinearForm.html">::BiLinearForm&lt;GAUSS&gt;::OpGradGrad</a>&lt;1, 1, 3&gt;;</div>
<div class="line">pipeline_mng-&gt;<a class="code" href="group__mofem__basic__interface.html#ga4b4225b4e1f114d604552ad8ec176486">getOpDomainLhsPipeline</a>().push_back(</div>
<div class="line">      <span class="keyword">new</span> <a class="code" href="helmholtz_8cpp.html#ab00a435c2cfb8b6e8e71eabe83ddeb07">OpDomainGradGrad</a>(<span class="stringliteral">&quot;U&quot;</span>, <span class="stringliteral">&quot;U&quot;</span>, beta));</div>
</div><!-- fragment --><p> Example usage: <a class="el" href="helmholtz_8cpp.html">helmholtz.cpp</a> </p>
</td></tr>
<tr>
<td><p class="starttd">Integrate mass <a class="el" href="structMoFEM_1_1OpMassImpl.html">MoFEM::OpMassImpl</a> </p><div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="seepage_8cpp.html#a2993c54e90f2427566f6d9dc8e5399a9">OpMass</a> = </div>
<div class="line">  FormsIntegrators&lt;OP&gt;::Assembly&lt;ASSEMBLY_TYPE&gt;::</div>
<div class="line">  BiLinearForm&lt;INTEGRATION_TYPE&gt;::</div>
<div class="line">  OpMass&lt;BASE_DIM, FIELD_DIM&gt;;</div>
</div><!-- fragment --><p> Example usage: <a class="el" href="helmholtz_8cpp-example.html">helmholtz.cpp</a></p>
<p class="endtd"></p>
</td><td><p class="starttd"></p>
<p class="intertd">Example for scalar base and scalar field </p><div class="fragment"><div class="line"><span class="keyword">auto</span> volume_specific_heat_capacity = [](<span class="keywordtype">double</span> x, <span class="keywordtype">double</span> y , <span class="keywordtype">double</span> z) {</div>
<div class="line">  <span class="keywordflow">return</span> 1;</div>
<div class="line">};</div>
<div class="line"><span class="keyword">using</span> <a class="code" href="thermo__elastic_8cpp.html#ab422105b0f4ac556f5b13c2394026774">OpCapacity</a> = </div>
<div class="line">  FormsIntegrators&lt;OP&gt;::Assembly&lt; <a class="code" href="group__mofem__forms.html#ggabb82cd10e89a1d4d25fa7756360b181ba2243b0abb08ad80d05c47e734f3134bc">PETSC</a>&gt;<a class="code" href="classBiLinearForm.html">::BiLinearForm&lt;GAUSS&gt;::OpMass</a>&lt;1, 1&gt;;</div>
<div class="line">pipeline_mng-&gt;<a class="code" href="group__mofem__basic__interface.html#ga4b4225b4e1f114d604552ad8ec176486">getOpDomainLhsPipeline</a>().push_back(</div>
<div class="line">      <span class="keyword">new</span> <a class="code" href="thermo__elastic_8cpp.html#ab422105b0f4ac556f5b13c2394026774">OpCapacity</a>(<span class="stringliteral">&quot;T&quot;</span>, <span class="stringliteral">&quot;T&quot;</span>, volume_specific_heat_capacity));</div>
</div><!-- fragment --><p> Example usage: <a class="el" href="helmholtz_8cpp.html">helmholtz.cpp</a></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><p class="starttd"></p>
<p class="intertd">Integrate base divergence times base <a class="el" href="structMoFEM_1_1OpMixDivTimesScalarImpl.html">MoFEM::OpMixDivTimesScalarImpl</a> </p><div class="fragment"><div class="line"><span class="keyword">using</span> OpHcurlHcurl = </div>
<div class="line">  FormsIntegrators&lt;OP&gt;::Assembly&lt;</div>
<div class="line">  ASSEMBLY_TYPE&gt;::</div>
<div class="line">  BiLinearForm&lt;INTEGRATION_TYPE&gt;::</div>
<div class="line">  OpMixDivTimesScalarImpl&lt;SPACE_DIM&gt;;</div>
</div><!-- fragment --><p> Example usage: <a class="el" href="mixed__poisson_8cpp.html">mixed_poisson.cpp</a></p>
<p class="endtd"></p>
</td><td><p class="starttd"></p>
<p class="intertd">Example </p><div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="mixed__poisson_8cpp.html#a8ecd4d9c0e0646249967b06e472964c9">OpHdivU</a> = FormsIntegrators&lt;DomainEleOp&gt;::Assembly&lt;<a class="code" href="group__mofem__forms.html#ggabb82cd10e89a1d4d25fa7756360b181ba2243b0abb08ad80d05c47e734f3134bc">PETSC</a>&gt;<a class="code" href="classBiLinearForm.html">::BiLinearForm</a>&lt;</div>
<div class="line">    <a class="code" href="group__mofem__forms.html#gga2136fdd1cb130ca18f645e799b05569faccb6b64b4a909e6408f40132996fdced">GAUSS</a>&gt;::OpMixDivTimesScalar&lt;2&gt;;</div>
<div class="line"><span class="keyword">auto</span> unity = []() { <span class="keywordflow">return</span> 1; };</div>
<div class="line">pipeline_mng-&gt;<a class="code" href="group__mofem__basic__interface.html#ga4b4225b4e1f114d604552ad8ec176486">getOpDomainLhsPipeline</a>().push_back(</div>
<div class="line">    <span class="keyword">new</span> <a class="code" href="mixed__poisson_8cpp.html#a8ecd4d9c0e0646249967b06e472964c9">OpHdivU</a>(<span class="stringliteral">&quot;FLUX&quot;</span>, <span class="stringliteral">&quot;U&quot;</span>, unity, <span class="keyword">true</span>));</div>
</div><!-- fragment --><p> Example usage: <a class="el" href="mixed__poisson_8cpp.html">mixed_poisson.cpp</a></p>
<p class="endtd"></p>
</td></tr>
<tr>
</tr>
</table>
<table class="doxtable">
</table>
<p>Bilinear froms are defined in file <a class="el" href="BiLinearFormsIntegrators_8hpp.html" title="Bilinear forms integrators.">BiLinearFormsIntegrators.hpp</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<div class="ttc" id="athermo__elastic_8cpp_html_a9136f58c96b1f4e005800f4edc7d4904"><div class="ttname"><a href="thermo__elastic_8cpp.html#a9136f58c96b1f4e005800f4edc7d4904">OpTemperatureBC</a></div><div class="ttdeci">BoundaryNaturalBC::OpFlux&lt; NaturalTemperatureMeshsets, 3, SPACE_DIM &gt; OpTemperatureBC</div><div class="ttdef"><b>Definition:</b> <a href="thermo__elastic_8cpp_source.html#l00110">thermo_elastic.cpp:110</a></div></div>
<div class="ttc" id="astructMoFEM_1_1OpNormalMixVecTimesScalarImpl_html"><div class="ttname"><a href="structMoFEM_1_1OpNormalMixVecTimesScalarImpl.html">MoFEM::OpNormalMixVecTimesScalarImpl</a></div><div class="ttdoc">Multiply vector times normal on the face times scalar function.</div><div class="ttdef"><b>Definition:</b> <a href="LinearFormsIntegratorsImpl_8hpp_source.html#l00378">LinearFormsIntegratorsImpl.hpp:378</a></div></div>
<div class="ttc" id="aclassFTensor_1_1Tensor1_html"><div class="ttname"><a href="classFTensor_1_1Tensor1.html">FTensor::Tensor1</a></div><div class="ttdef"><b>Definition:</b> <a href="Tensor1__value_8hpp_source.html#l00008">Tensor1_value.hpp:8</a></div></div>
<div class="ttc" id="anamespaceMoFEM_html_aa31b19346629cc2f84fb4333f981989d"><div class="ttname"><a href="namespaceMoFEM.html#aa31b19346629cc2f84fb4333f981989d">MoFEM::OpSetContravariantPiolaTransformOnFace2D</a></div><div class="ttdeci">OpSetContravariantPiolaTransformOnFace2DImpl&lt; 2 &gt; OpSetContravariantPiolaTransformOnFace2D</div><div class="ttdef"><b>Definition:</b> <a href="UserDataOperators_8hpp_source.html#l03076">UserDataOperators.hpp:3076</a></div></div>
<div class="ttc" id="astructMoFEM_1_1OpFluxRhsImpl_html"><div class="ttname"><a href="structMoFEM_1_1OpFluxRhsImpl.html">MoFEM::OpFluxRhsImpl</a></div><div class="ttdef"><b>Definition:</b> <a href="Natural_8hpp_source.html#l00039">Natural.hpp:39</a></div></div>
<div class="ttc" id="agroup__mofem__basic__interface_html_gac52cdc08eaadd124e0224d7d9e0a13f5"><div class="ttname"><a href="group__mofem__basic__interface.html#gac52cdc08eaadd124e0224d7d9e0a13f5">MoFEM::PipelineManager::getOpDomainRhsPipeline</a></div><div class="ttdeci">boost::ptr_deque&lt; UserDataOperator &gt; &amp; getOpDomainRhsPipeline()</div><div class="ttdoc">Get the Op Domain Rhs Pipeline object.</div><div class="ttdef"><b>Definition:</b> <a href="PipelineManager_8hpp_source.html#l00773">PipelineManager.hpp:773</a></div></div>
<div class="ttc" id="aclassFTensor_1_1Kronecker__Delta_html"><div class="ttname"><a href="classFTensor_1_1Kronecker__Delta.html">FTensor::Kronecker_Delta</a></div><div class="ttdoc">Kronecker Delta class.</div><div class="ttdef"><b>Definition:</b> <a href="Kronecker__Delta_8hpp_source.html#l00015">Kronecker_Delta.hpp:15</a></div></div>
<div class="ttc" id="agroup__mofem__forms_html_ggabb82cd10e89a1d4d25fa7756360b181ba2243b0abb08ad80d05c47e734f3134bc"><div class="ttname"><a href="group__mofem__forms.html#ggabb82cd10e89a1d4d25fa7756360b181ba2243b0abb08ad80d05c47e734f3134bc">MoFEM::PETSC</a></div><div class="ttdeci">@ PETSC</div><div class="ttdef"><b>Definition:</b> <a href="FormsIntegrators_8hpp_source.html#l00105">FormsIntegrators.hpp:105</a></div></div>
<div class="ttc" id="astructMoFEM_1_1OpScaleBaseBySpaceInverseOfMeasure_html"><div class="ttname"><a href="structMoFEM_1_1OpScaleBaseBySpaceInverseOfMeasure.html">MoFEM::OpScaleBaseBySpaceInverseOfMeasure</a></div><div class="ttdoc">Scale base functions by inverses of measure of element.</div><div class="ttdef"><b>Definition:</b> <a href="HODataOperators_8hpp_source.html#l00390">HODataOperators.hpp:390</a></div></div>
<div class="ttc" id="adg__projection_8cpp_html_a87778f5f0ec7eba11e8f327af2258018"><div class="ttname"><a href="dg__projection_8cpp.html#a87778f5f0ec7eba11e8f327af2258018">BASE_DIM</a></div><div class="ttdeci">constexpr int BASE_DIM</div><div class="ttdef"><b>Definition:</b> <a href="dg__projection_8cpp_source.html#l00015">dg_projection.cpp:15</a></div></div>
<div class="ttc" id="achild__and__parent_8cpp_html_a662ea09b7a3c09effd6610d75fb7cbcb"><div class="ttname"><a href="child__and__parent_8cpp.html#a662ea09b7a3c09effd6610d75fb7cbcb">FIELD_DIM</a></div><div class="ttdeci">constexpr int FIELD_DIM</div><div class="ttdef"><b>Definition:</b> <a href="child__and__parent_8cpp_source.html#l00015">child_and_parent.cpp:15</a></div></div>
<div class="ttc" id="anamespaceMoFEM_html_a1581cdd9218a980e2aad036d0ac8b2ae"><div class="ttname"><a href="namespaceMoFEM.html#a1581cdd9218a980e2aad036d0ac8b2ae">MoFEM::OpSetContravariantPiolaTransformOnFace2DEmbeddedIn3DSpace</a></div><div class="ttdeci">OpSetContravariantPiolaTransformOnFace2DImpl&lt; 3 &gt; OpSetContravariantPiolaTransformOnFace2DEmbeddedIn3DSpace</div><div class="ttdef"><b>Definition:</b> <a href="UserDataOperators_8hpp_source.html#l03078">UserDataOperators.hpp:3078</a></div></div>
<div class="ttc" id="achild__and__parent_8cpp_html_a541ffc988889246e44b233b777828847"><div class="ttname"><a href="child__and__parent_8cpp.html#a541ffc988889246e44b233b777828847">SPACE_DIM</a></div><div class="ttdeci">constexpr int SPACE_DIM</div><div class="ttdef"><b>Definition:</b> <a href="child__and__parent_8cpp_source.html#l00016">child_and_parent.cpp:16</a></div></div>
<div class="ttc" id="aseepage_8cpp_html_a2993c54e90f2427566f6d9dc8e5399a9"><div class="ttname"><a href="seepage_8cpp.html#a2993c54e90f2427566f6d9dc8e5399a9">OpMass</a></div><div class="ttdeci">FormsIntegrators&lt; DomainEleOp &gt;::Assembly&lt; PETSC &gt;::BiLinearForm&lt; GAUSS &gt;::OpMass&lt; 1, SPACE_DIM &gt; OpMass</div><div class="ttdoc">[Only used with Hooke equation (linear material model)]</div><div class="ttdef"><b>Definition:</b> <a href="seepage_8cpp_source.html#l00057">seepage.cpp:57</a></div></div>
<div class="ttc" id="anamespaceMoFEM_html_aa464ad90a188180427136b22e078ec7d"><div class="ttname"><a href="namespaceMoFEM.html#aa464ad90a188180427136b22e078ec7d">MoFEM::getFTensor0FromVec</a></div><div class="ttdeci">static auto getFTensor0FromVec(ublas::vector&lt; T, A &gt; &amp;data)</div><div class="ttdoc">Get tensor rank 0 (scalar) form data vector.</div><div class="ttdef"><b>Definition:</b> <a href="Templates_8hpp_source.html#l00135">Templates.hpp:135</a></div></div>
<div class="ttc" id="agroup__mofem__forms_html_gga2136fdd1cb130ca18f645e799b05569faccb6b64b4a909e6408f40132996fdced"><div class="ttname"><a href="group__mofem__forms.html#gga2136fdd1cb130ca18f645e799b05569faccb6b64b4a909e6408f40132996fdced">MoFEM::GAUSS</a></div><div class="ttdeci">@ GAUSS</div><div class="ttdef"><b>Definition:</b> <a href="FormsIntegrators_8hpp_source.html#l00136">FormsIntegrators.hpp:136</a></div></div>
<div class="ttc" id="anamespaceMoFEM_html_a123875fb03925a9640697591e972412c"><div class="ttname"><a href="namespaceMoFEM.html#a123875fb03925a9640697591e972412c">MoFEM::L</a></div><div class="ttdeci">VectorDouble L</div><div class="ttdef"><b>Definition:</b> <a href="Projection10NodeCoordsOnField_8cpp_source.html#l00124">Projection10NodeCoordsOnField.cpp:124</a></div></div>
<div class="ttc" id="agroup__mofem__basic__interface_html_ga4b4225b4e1f114d604552ad8ec176486"><div class="ttname"><a href="group__mofem__basic__interface.html#ga4b4225b4e1f114d604552ad8ec176486">MoFEM::PipelineManager::getOpDomainLhsPipeline</a></div><div class="ttdeci">boost::ptr_deque&lt; UserDataOperator &gt; &amp; getOpDomainLhsPipeline()</div><div class="ttdoc">Get the Op Domain Lhs Pipeline object.</div><div class="ttdef"><b>Definition:</b> <a href="PipelineManager_8hpp_source.html#l00749">PipelineManager.hpp:749</a></div></div>
<div class="ttc" id="ahcurl__divergence__operator__2d_8cpp_html_a4c0436605284b64f6b0b5482594d86bc"><div class="ttname"><a href="hcurl__divergence__operator__2d_8cpp.html#a4c0436605284b64f6b0b5482594d86bc">i</a></div><div class="ttdeci">FTensor::Index&lt; 'i', SPACE_DIM &gt; i</div><div class="ttdef"><b>Definition:</b> <a href="hcurl__divergence__operator__2d_8cpp_source.html#l00027">hcurl_divergence_operator_2d.cpp:27</a></div></div>
<div class="ttc" id="afree__surface_8cpp_html_a52438586143ef05bfe922220a317c144"><div class="ttname"><a href="free__surface_8cpp.html#a52438586143ef05bfe922220a317c144">t_kd</a></div><div class="ttdeci">constexpr auto t_kd</div><div class="ttdef"><b>Definition:</b> <a href="free__surface_8cpp_source.html#l00137">free_surface.cpp:137</a></div></div>
<div class="ttc" id="aclassBiLinearForm_html"><div class="ttname"><a href="classBiLinearForm.html">BiLinearForm</a></div></div>
<div class="ttc" id="apoisson__2d__homogeneous_8cpp_html_a3917f3987bad1f4e24b85c9d0ab84a5e"><div class="ttname"><a href="poisson__2d__homogeneous_8cpp.html#a3917f3987bad1f4e24b85c9d0ab84a5e">field_name</a></div><div class="ttdeci">constexpr auto field_name</div><div class="ttdef"><b>Definition:</b> <a href="poisson__2d__homogeneous_8cpp_source.html#l00013">poisson_2d_homogeneous.cpp:13</a></div></div>
<div class="ttc" id="aclassFTensor_1_1Index_html"><div class="ttname"><a href="classFTensor_1_1Index.html">FTensor::Index&lt; 'i', FIELD_DIM &gt;</a></div></div>
<div class="ttc" id="ahelmholtz_8cpp_html_ab00a435c2cfb8b6e8e71eabe83ddeb07"><div class="ttname"><a href="helmholtz_8cpp.html#ab00a435c2cfb8b6e8e71eabe83ddeb07">OpDomainGradGrad</a></div><div class="ttdeci">FormsIntegrators&lt; DomainEleOp &gt;::Assembly&lt; PETSC &gt;::BiLinearForm&lt; GAUSS &gt;::OpGradGrad&lt; 1, 1, SPACE_DIM &gt; OpDomainGradGrad</div><div class="ttdef"><b>Definition:</b> <a href="helmholtz_8cpp_source.html#l00025">helmholtz.cpp:25</a></div></div>
<div class="ttc" id="amixed__poisson_8cpp_html_a8ecd4d9c0e0646249967b06e472964c9"><div class="ttname"><a href="mixed__poisson_8cpp.html#a8ecd4d9c0e0646249967b06e472964c9">OpHdivU</a></div><div class="ttdeci">FormsIntegrators&lt; DomainEleOp &gt;::Assembly&lt; PETSC &gt;::BiLinearForm&lt; GAUSS &gt;::OpMixDivTimesScalar&lt; 2 &gt; OpHdivU</div><div class="ttdef"><b>Definition:</b> <a href="mixed__poisson_8cpp_source.html#l00025">mixed_poisson.cpp:25</a></div></div>
<div class="ttc" id="amatrix__function_8cpp_html_a8191f28ba278df9c5d32a75cadb2bbd5"><div class="ttname"><a href="matrix__function_8cpp.html#a8191f28ba278df9c5d32a75cadb2bbd5">j</a></div><div class="ttdeci">FTensor::Index&lt; 'j', 3 &gt; j</div><div class="ttdef"><b>Definition:</b> <a href="matrix__function_8cpp_source.html#l00019">matrix_function.cpp:19</a></div></div>
<div class="ttc" id="athermo__elastic_8cpp_html_ab422105b0f4ac556f5b13c2394026774"><div class="ttname"><a href="thermo__elastic_8cpp.html#ab422105b0f4ac556f5b13c2394026774">OpCapacity</a></div><div class="ttdeci">FormsIntegrators&lt; DomainEleOp &gt;::Assembly&lt; PETSC &gt;::BiLinearForm&lt; GAUSS &gt;::OpMass&lt; 1, 1 &gt; OpCapacity</div><div class="ttdoc">Integrate Lhs base of temperature times (heat capacity) times base of temperature (T x T)</div><div class="ttdef"><b>Definition:</b> <a href="thermo__elastic_8cpp_source.html#l00063">thermo_elastic.cpp:63</a></div></div>
<div class="ttc" id="anamespacePlasticOps_html_ad104160ccee829446f9f4701d5364629"><div class="ttname"><a href="namespacePlasticOps.html#ad104160ccee829446f9f4701d5364629">PlasticOps::trace</a></div><div class="ttdeci">double trace(FTensor::Tensor2_symmetric&lt; T, 2 &gt; &amp;t_stress)</div><div class="ttdef"><b>Definition:</b> <a href="PlasticOpsGeneric_8hpp_source.html#l00080">PlasticOpsGeneric.hpp:80</a></div></div>
<div class="ttc" id="achild__and__parent_8cpp_html_a4d5d1673a6198f0cb09118e6db333d6f"><div class="ttname"><a href="child__and__parent_8cpp.html#a4d5d1673a6198f0cb09118e6db333d6f">OpDomainSource</a></div><div class="ttdeci">FormsIntegrators&lt; DomainEleOp &gt;::Assembly&lt; PETSC &gt;::LinearForm&lt; GAUSS &gt;::OpSource&lt; 1, FIELD_DIM &gt; OpDomainSource</div><div class="ttdef"><b>Definition:</b> <a href="child__and__parent_8cpp_source.html#l00055">child_and_parent.cpp:55</a></div></div>
<div class="ttc" id="adg__projection_8cpp_html_a47f5c9a54ebf753d18651f417f81f4e8"><div class="ttname"><a href="dg__projection_8cpp.html#a47f5c9a54ebf753d18651f417f81f4e8">fun</a></div><div class="ttdeci">auto fun</div><div class="ttdoc">Function to approximate.</div><div class="ttdef"><b>Definition:</b> <a href="dg__projection_8cpp_source.html#l00036">dg_projection.cpp:36</a></div></div>
<div class="ttc" id="aclassOpCalculateVectorFieldGradient_html"><div class="ttname"><a href="classOpCalculateVectorFieldGradient.html">OpCalculateVectorFieldGradient</a></div></div>
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr cla ss="footer" />
<style>
  img[src="UoGLogo.png"] {
    height: 20px;
    padding-top: 0px;
    padding-right: 1px;
    padding-bottom: 3px;
    padding-left: 6px;
  }
</style>
<address class="footer">
  <small>
    Generated by
    <a href="http://www.doxygen.org/index.html"> Doxygen </a> 1.8.17
    and hosted at
    <a href="http://www.gla.ac.uk/schools/engineering/">
      <img class="footer" src="UoGLogo.png" alt="University of Glasgow" />
    </a>
  </small>
</address>
</body>
</html>