<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
  <meta http-equiv="X-UA-Compatible" content="IE=9"/>
  <meta name="generator" content="Doxygen 1.9.8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>MoFEM: FUN-2: Hierarchical approximation</title>
  <link href="tabs.css" rel="stylesheet" type="text/css"/>
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
  <script>
    window.MathJax = {
      tex: {
        tags: 'all', // Enables equation numbering
      },
      loader: {
        load: ['[tex]/boldsymbol']
      }
    };
  </script>
  <script type="text/javascript " src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
  <link href="customdoxygen.css" rel="stylesheet" type="text/css" />
  <link href="extra_style.css" rel="stylesheet" type="text/css"/>
  <link rel="apple-touch-icon" sizes="57x57" href="apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192"  href="android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.png">
  <link rel="shortcut icon" type="image/png" href="favicon-32x32.png"/>
  <link rel="Bookmark" type="image/png" href="favicon-32x32.png"/>
  <link rel="manifest" href="manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div style="background-color:#011A40" id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 30px;">
  <td id="projectlogo"><img alt="Logo" src="MoFEMLogo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <td style="padding-left: 0.5em;" bgcolor="#011A40"
   <div id="projectbrief"><font color="#FFFFFF">v0.15.0</font></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!--Google analytics tags-->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-65236130-1', 'auto');
  ga('send', 'pageview');
</script>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-2J9RE2P3H5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-2J9RE2P3H5');
</script><!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">FUN-2: Hierarchical approximation</div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#hierarchical_approximation_introduction">Introduction</a><ul><li class="level2"><a href="#hierarchical_approximation_motivation">Motivation for using Hierarchical shape functions</a></li>
<li class="level2"><a href="#hierarchical_approximation_node">Node oriented and Hierarchical shape functions</a></li>
</ul>
</li>
<li class="level1"><a href="#hierarchical_approximation_ele_stiff">Element stiffness matrix</a></li>
<li class="level1"><a href="#hierarchical_approximation_ele_mass_matrix">Element mass matrix</a></li>
<li class="level1"><a href="#hierarchical_approximation_data_structures">Entity approximation functions</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="hierarchical_approximation_introduction"></a>
Introduction</h1>
<p>The present tutorial is aimed to introduce elementary concepts of the Finite Element Method (FEM) with hierarchical shape functions and their implementation in <a class="el" href="namespaceMoFEM.html" title="implementation of Data Operators for Forces and Sources">MoFEM</a>.</p>
<p>The reader is assumed to be familiar with the FEM approach to solve Partial Differential Equations (PDEs). Here, differences between the node oriented (that most readers are familiar with) and hierarchical shape functions is described. Aspects of <a class="el" href="namespaceMoFEM.html" title="implementation of Data Operators for Forces and Sources">MoFEM</a> implementation of this approach will be described for the user to understand the FEM implementation within the present framework. These concepts are presented as briefly as possible with sole aim to clarify their implementation within <a class="el" href="namespaceMoFEM.html" title="implementation of Data Operators for Forces and Sources">MoFEM</a>.</p>
<h2><a class="anchor" id="hierarchical_approximation_motivation"></a>
Motivation for using Hierarchical shape functions</h2>
<p>Advantages of the Hierarchical shape functions are not going to be described in the present tutorial. The key points for choosing <a class="el" href="namespaceMoFEM.html" title="implementation of Data Operators for Forces and Sources">MoFEM</a> implementation of the FEM method with Hierarchical basis functions instead of the node oriented approach are presented in this section to clearly set the motivation behind this particular choice. Choosing Hierarchical basis functions over node oriented basis is that it results to:</p>
<ul>
<li>Easy implementation of heterogeneous approximation</li>
<li>Use of more efficient solvers</li>
</ul>
<h2><a class="anchor" id="hierarchical_approximation_node"></a>
Node oriented and Hierarchical shape functions</h2>
<p>In the FEM, the unknown field \(u({\mathbf {x}}) \) is approximated as</p>
<p class="formulaDsp">
\[
\begin{equation}
u({\mathbf {x}}) \approx u^h({\mathbf {x}}) = \sum_{i=1}^{n} N_i u_i
\label{eq:Approx}
\end{equation}
\]
</p>
<p>where \({\mathbf{ x}}\) denotes the coordinate vector, \(u\) is the function to be approximated, \(u^h\) is the approximating function and \(N_i\) are the shape functions associated with the \(n\) number of degrees of freedom \(u_i\) of a particular choice.</p>
<p>Node oriented shape functions are always associated with the degrees of freedom corresponding to a node. Node oriented shape functions are presented for a 1D element in <a class="el" href="hierarchical_approximation_1.html#Figure_1">Figure 1</a> a, b and c for first, second and third order, respectively. For simplicity we will be restricted to 1D element for the moment. Each degree of freedom is associated with a node and has a physical meaning. In the case of p- and hp- adaptivity, where the order of approximation is chosen to increase at certain regions of the domain, this kind of shape functions increase the complexity of implementation since new meshes with extra nodes must be generated.</p>
<p><a class="anchor" id="Figure_1"></a></p><div class="image">
<img src="Figure1.png" alt="" width="700px"/>
<div class="caption">
Figure 1: Node oriented shape functions of a 1D element: (a) linear, (b) second order and (c) third order. Each shape functions is equal to unity at the location of its associated node.</div></div>
<p>These complexities can be resolved by using hierarchical shape functions. Examples of hierarchical shape functions in a 1D element are presented in <a class="el" href="hierarchical_approximation_1.html#Figure_2">Figure 2</a> a, b and c for first, second and third order, respectively. By inspection of <a class="el" href="hierarchical_approximation_1.html#Figure_2">Figure 2</a> b and c it can be seen that no extra nodes are added for functions of order higher than the first one. This feature makes the p- and hp- adaptivity implementation much easier since no extra nodes are needed to be introduced into the mesh.</p>
<p><a class="anchor" id="Figure_2"></a></p><div class="image">
<img src="Figure2.png" alt="" width="700px"/>
<div class="caption">
Figure 2: Hierarchical shape functions of a 1D element: (a) linear, (b) second order and (c) third order. Each shape functions is equal to unity at the location of its associated node.</div></div>
<p>Furthermore, all but the first order functions are unique (i.e. there is only one function of each order) and identically zero at the element nodes. For the first order there are two functions, one for each node. Partition of unity is therefore preserved at the nodes but not necessarily in-between. Hence, for order of choice \(p\) the number of degrees of freedom is going to \(p + 1\).</p>
<p>For the 1D case, only the first two degrees of freedom ( \(u_i\)) presented in \( \eqref {eq:Approx}\) are associated with the nodes. The rest of the degrees of freedom are free of any node notion and there is no particular need to be linked to a physical value. These degrees of freedom are purely mathematical.</p>
<p>From now on nodes will be referred as vertices and the entity generated by the 1D space that connects the two vertices will be referred as edge. <br  />
</p>
<p>A practical way of assembling the degrees of freedom associated to a 1D element can be done by separation of the degrees of freedom associated with vertices (first order) to those with edges (higher orders). Therefore, the elemental degrees of freedom \({\mathbf{ n}^e}\) of a 1D element can be presented as</p>
<p class="formulaDsp">
\[
    \begin{equation}
{\mathbf {u}^e} = \left[ 
 \begin{array}{c c}
{\mathbf { n}^e} &amp;{\mathbf { e}^e}
\end{array} \right]
\label{eq:ElementDOF1D}
\end{equation}
\]
</p>
<p>where \({\mathbf { n}^e}\) and \({\mathbf { e}^e}\) are sub-vectors containing degrees of freedom associated with vertices and the edge, respectively. According to \(\eqref {eq:Approx} \), \({\mathbf { n}^e}\) will always be consisted of two degrees of freedom as presented below</p>
<p class="formulaDsp">
\[
    \begin{equation}
{\mathbf { n}^e} = \left[ 
 \begin{array}{cc}
u_0  &amp; u_1 \\
\end{array} \right]
\label{eq:VertexDOF1}
\end{equation}
\]
</p>
<p>However, the length of \({\mathbf { e}^e}\) depends on the order of approximation chosen. For \(p = 1 \) , \({\mathbf { e}^e}\) will have no members. For \(p = 3 \) the vector will have two members and it will have the form</p>
<p class="formulaDsp">
\[
    \begin{equation}
{\mathbf { e}^e} = \left[ 
 \begin{array}{cc}
u_2  &amp; u_3 \\
\end{array} \right]
\label{eq:VertexDOF2}
\end{equation}
\]
</p>
<p>Similar separation can be performed with the corresponding shape functions. Usefulness of the separation will become apparent later and it is intrinsic to the implementations that will be presented in this tutorial.</p>
<p>These concepts can be extended to 2D and 3D elements. In 1D the two entities that were presented were vertex and edge. The extra entities that emerge in the 2D and 3D domains are faces and volumes, respectively.</p>
<p>Shape functions that can be found implemented in <a class="el" href="namespaceMoFEM.html" title="implementation of Data Operators for Forces and Sources">MoFEM</a> now are associated with vertices, edges, triangular faces and tetrahedral volumes. The shape functions for edges that are part of triangular faces and the shape functions of triangular faces are presented in <a class="el" href="hierarchical_approximation_1.html#Figure_4">Figure 4</a> and <a class="el" href="hierarchical_approximation_1.html#Figure_5">Figure 5</a>, respectively. The values of the shape functions along the 2D space of a face can be thought as the varying height or depth of the nonlinear surfaces from the planar triangular face. When the curved surface is below or above the planar face, the shape function takes negative or positive values, respectively. Vertex shape functions are equal to unity at their associated vertices and identically zero along the opposite edge and one the other two vertices. The edge functions are always identically zero at all vertices and along all edges except for the associated edge. The face functions are generally non zero on the face area but are always zero on vertices and along edges.</p>
<p>The volume shape functions are not presented in this tutorial due to the high complexity of their presentation in a 2D fashion. However, the reader can imagine the volume shape functions as smooth grey colour changes in 3D space. When a location is white or black coloured then the shape function takes its minimum or maximum values. Furthermore, volume shape functions are identically zero on vertices and along edges and faces of the associated tetrahedron.</p>
<p><a class="anchor" id="Figure_3"></a></p><div class="image">
<img src="Figure3.png" alt="" width="700px"/>
<div class="caption">
Figure 3: Hierarchical shape functions for vertices on a 2D face for vertices: (a) \f$j_1\f$, (b) \f$j_2\f$ and (c) \f$j_3\f$. Each shape functions is zero on the remaining vertices and on the edge they defined.</div></div>
<p><a class="anchor" id="Figure_4"></a></p><div class="image">
<img src="Figure4.png" alt="" width="700px"/>
<div class="caption">
Figure 4: Hierarchical shape functions for edges on a 2D face: (a) second order, (b) third order and (c) fourth order. Each shape functions is generally non zero on its corresponding edge and zero on all other edges.</div></div>
<p><a class="anchor" id="Figure_5"></a></p><div class="image">
<img src="Figure5.png" alt="" width="700px"/>
<div class="caption">
Figure 5: Hierarchical shape functions for faces on a 2D face: (a) third order, (b) fourth order, (c) fifth order and sixth order. Each shape functions is zero on edges and vertices.</div></div>
<p>Now the concept of decomposition of elemental degrees of freedom described by the equation \(\eqref {eq:ElementDOF1D}\) can be taken further from a 1D element to the 3D tetrahedron element. In fact, it will be evident that this decomposition applies to any type of 3D element under consideration. Now the vector of the degrees of freedom \({\mathbf {u}^e}\) of one element is</p>
<p class="formulaDsp">
\[
    \begin{equation}
{\mathbf { u}^e} = \left[ 
 \begin{array}{cccc}
{\mathbf { n}^e} &amp;
{\mathbf { e}^e} &amp;
{\mathbf { f}^e} &amp;
{\mathbf { v}^e}
\end{array} \right]
\label{eq:ElementDOF3D}
\end{equation}
\]
</p>
<p>where \({\mathbf { f}^e}\) and \({\mathbf { v}^e}\) are the sub-vectors containing the degrees of freedom associated with the face and volume shape functions, respectively. Therefore, the number of degrees of freedom for each sub-vector associated with an entity is equal to the number of shape functions associated with that particular entity. For instance, when the shape functions presented in <a class="el" href="hierarchical_approximation_1.html#Figure_4">Figure 4</a> and <a class="el" href="hierarchical_approximation_1.html#Figure_5">Figure 5</a> are used, \({\mathbf { e}^e}\) and \({\mathbf { f}^e}\) contain nine and ten degrees of freedom, respectively.</p>
<p>Similarly, the vector of shape functions of an element can be decomposed into four sub vectors</p>
<p class="formulaDsp">
\[
    \begin{equation}
{\mathbf {N}^e} = \left[ 
 \begin{array}{cccc}
{\mathbf {N}^e_{\textrm {ver}}} &amp;
{\mathbf {N}^e_{\textrm {edge}}} &amp;
{\mathbf {N}^e_{\textrm {face}}} &amp;
{\mathbf {N}^e_{\textrm {vol}}} \\
\end{array} \right]
\label{eq:ElementShape3D}
\end{equation}
\]
</p>
<p>where \({\mathbf {N}^e}\) is the vector of the element's shape function and \({\mathbf {N}^e_{\textrm {ver}}}\), \({\mathbf {N}^e_{\textrm {edge}}}\), \({\mathbf {N}^e_{\textrm {face}}}\) and \({\mathbf {N}^e_{\textrm {vol}}}\) are the sub-vectors of the shape functions associated with vertices, edges, faces and volume respectively.</p>
<p>Here it should be mentioned that the choice of the entities and their associated degrees of freedom and shape functions under consideration for solutions of boundary value problems are dictated by the particular choice of the shape function space and the order of approximation. The case where all entities' shape functions are taken into account is for the H1 space for \(p\geq4\). Spaces that can be used in <a class="el" href="namespaceMoFEM.html" title="implementation of Data Operators for Forces and Sources">MoFEM</a> are also L2, H-curl and H-Div that are sub-spaces of H1. For the sake of simplicity, this tutorial will proceed assuming an H1 space with \(p\geq4\) in order to have all entities degrees of freedom and shape functions in the examples. Discussion on the particular choice of shape function space will be presented in another tutorial.</p>
<h1><a class="anchor" id="hierarchical_approximation_ele_stiff"></a>
Element stiffness matrix</h1>
<p>One of the most common proccesses encompassed within the Finite Element Method is the evaluation of the stiffness matrix. The evaluation of the element stiffness matrix is going to be presented by making use of the decomposition of degrees of freedom and shape functions presented in \(\eqref {eq:ElementDOF3D}\) and \(\eqref {eq:ElementShape3D}\).</p>
<p>The stiffness matrix of a volume element is evaluated as the integral of</p>
<p class="formulaDsp">
\[
    \begin{equation}
{\mathbf {\textrm K}^e} = 
\int_{\Omega^e}({\mathbf {\nabla^{T}N}^e})^{\textrm T} {\mathbf {\nabla^{\textrm T} N}^e} {\textrm d\Omega^e}
\label{eq:StiffnessIntegral}
\end{equation}
\]
</p>
<p>where \({\mathbf {\textrm K}^e}\) is the element stiffness matrix, \(\Omega^e\) is the element domain and \({\mathbf {\rm \nabla^{\textrm T}}}\) is the vector form of the first order gradient operator taken as</p>
<p class="formulaDsp">
\[
    \begin{equation}
{\mathbf {\rm \nabla}}^{\rm T} = \left[
\begin{array}{c}
\dfrac{\partial}{\partial x}\\
\dfrac{\partial}{\partial y}\\
\dfrac{\partial}{\partial z}\\
\end{array} \right]
\label{eq:Nabla}
\end{equation}
\]
</p>
<p>hence the product \({\mathbf {\nabla^{\textrm T} N}^e}\) can be evaluated as</p>
<p class="formulaDsp">
\[
    \begin{equation}
\begin{split}
{\mathbf {\nabla^{\textrm T} N}^e} = \left[
\begin{array}{c}
\dfrac{\partial}{\partial x}\\
\dfrac{\partial}{\partial y}\\
\dfrac{\partial}{\partial z}\\
\end{array} \right]
\left[ 
 \begin{array}{cccc}
{\mathbf {N}^e_{\textrm ver}} &amp;
{\mathbf {N}^e_{\textrm edge}} &amp;
{\mathbf {N}^e_{\textrm face}} &amp;
{\mathbf {N}^e_{\textrm vol}}
\end{array} \right] = \left[
 \begin{array}{cccc}
\dfrac{\partial {\mathbf {N}^e_{\textrm ver}} }{\partial x} &amp; \dfrac{\partial {\mathbf {N}^e_{\textrm edge}} }{\partial x} 
&amp; \dfrac{\partial {\mathbf {N}^e_{\textrm face}} }{\partial x} &amp; \dfrac{\partial {\mathbf {N}^e_{\textrm vol}} }{\partial x} \\
\dfrac{\partial {\mathbf {N}^e_{\textrm ver}} }{\partial y} &amp; \dfrac{\partial {\mathbf {N}^e_{\textrm edge}} }{\partial y} 
&amp; \dfrac{\partial {\mathbf {N}^e_{\textrm face}} }{\partial y} &amp; \dfrac{\partial {\mathbf {N}^e_{\textrm vol}} }{\partial y}\\
\dfrac{\partial {\mathbf {N}^e_{\textrm ver}} }{\partial z} &amp; \dfrac{\partial {\mathbf {N}^e_{\textrm edge}} }{\partial z} 
&amp; \dfrac{\partial {\mathbf {N}^e_{\textrm face}} }{\partial z} &amp; \dfrac{\partial {\mathbf {N}^e_{\textrm vol}} }{\partial z} \\
\end{array} \right] 
= \left[ 
 \begin{array}{cccc}
{\mathbf {\nabla^{\textrm T} N}^e_{\textrm ver}} &amp; {\mathbf {\nabla^{\textrm T} N}^e_{\textrm edge}} &amp; {\mathbf {\nabla^{\textrm T} N}^e_{\textrm face}} &amp; {\mathbf {\nabla^{\textrm T} N}^e_{\textrm vol}}
\end{array} \right]
\end{split}
\label{eq:NablaShape1}
\end{equation}
\]
</p>
<p>therefore the product \(({\mathbf {\nabla^{\textrm T} N}^e})^{\textrm T} {\mathbf {\nabla^{\textrm T} N}^e}\) is evaluated as</p>
<p class="formulaDsp">
\[
    \begin{equation}
\begin{split}
({\mathbf {\nabla^{\textrm T} N}^e})^{\textrm T} {\mathbf {\nabla^{\textrm T} N}^e} = \left[
\begin{array}{c}
({\mathbf {\nabla^{\textrm T} N}^e_{\textrm {ver}}})^{\rm T}\\
({\mathbf {\nabla^{\textrm T} N}^e_{\textrm {edge}}})^{\rm T}\\
({\mathbf {\nabla^{\textrm T} N}^e_{\textrm {face}}})^{\rm T}\\
({\mathbf {\nabla^{\textrm T} N}^e_{\textrm {vol}}})^{\rm T}
\end{array} \right]
\left[
 \begin{array}{cccc} 
{\mathbf {\nabla^{\textrm T} N}^e_{\textrm {ver}}} &amp; {\mathbf {\nabla^{\textrm T} N}^e_{\textrm {edge}}} &amp; {\mathbf {\nabla^{\textrm T} N}^e_{\textrm {face}}} &amp; {\mathbf {\nabla^{\textrm T} N}^e_{\textrm {vol}}}
\end{array} \right] 
=\\ \\ =
\left[
 \begin{array}{cccc}
({\mathbf {\nabla^{\textrm T} N}^e_{\textrm {ver}}})^{\rm T} {\mathbf {\nabla^{\textrm T} N}^e_{\textrm {ver}}} &amp;  
({\mathbf {\nabla^{\textrm T} N}^e_{\textrm {ver}}})^{\rm T} {\mathbf {\nabla^{\textrm T} N}^e_{\textrm {edge}}} &amp; 
({\mathbf {\nabla^{\textrm T} N}^e_{\textrm {ver}}})^{\rm T} {\mathbf {\nabla^{\textrm T} N}^e_{\textrm {face}}} &amp; 
({\mathbf {\nabla^{\textrm T} N}^e_{\textrm {ver}}})^{\rm T} {\mathbf {\nabla^{\textrm T} N}^e_{\textrm {vol}}}\\ 
({\mathbf {\nabla^{\textrm T} N}^e_{\textrm {edge}}})^{\rm T} {\mathbf {\nabla^{\textrm T} N}^e_{\textrm {ver}}} &amp;
({\mathbf {\nabla^{\textrm T} N}^e_{\textrm {edge}}})^{\rm T} {\mathbf {\nabla^{\textrm T} N}^e_{\textrm {edge}}} &amp;
({\mathbf {\nabla^{\textrm T} N}^e_{\textrm {edge}}})^{\rm T} {\mathbf {\nabla^{\textrm T} N}^e_{\textrm {face}}} &amp;
({\mathbf {\nabla^{\textrm T} N}^e_{\textrm {edge}}})^{\rm T} {\mathbf {\nabla^{\textrm T} N}^e_{\textrm {vol}}} \\
({\mathbf {\nabla^{\textrm T} N}^e_{\textrm {face}}})^{\rm T} {\mathbf {\nabla^{\textrm T} N}^e_{\textrm {ver}}}&amp;
({\mathbf {\nabla^{\textrm T} N}^e_{\textrm {face}}})^{\rm T} {\mathbf {\nabla^{\textrm T} N}^e_{\textrm {edge}}}&amp;
({\mathbf {\nabla^{\textrm T} N}^e_{\textrm {face}}})^{\rm T} {\mathbf {\nabla^{\textrm T} N}^e_{\textrm {face}}}&amp; 
({\mathbf {\nabla^{\textrm T} N}^e_{\textrm {face}}})^{\rm T} {\mathbf {\nabla^{\textrm T} N}^e_{\textrm {vol}}} \\
({\mathbf {\nabla^{\textrm T} N}^e_{\textrm {vol}}})^{\rm T} {\mathbf {\nabla^{\textrm T} N}^e_{\textrm {ver}}}&amp;
({\mathbf {\nabla^{\textrm T} N}^e_{\textrm {vol}}})^{\rm T} {\mathbf {\nabla^{\textrm T} N}^e_{\textrm {edge}}}&amp;
({\mathbf {\nabla^{\textrm T} N}^e_{\textrm {vol}}})^{\rm T} {\mathbf {\nabla^{\textrm T} N}^e_{\textrm {face}}}&amp; 
({\mathbf {\nabla^{\textrm T} N}^e_{\textrm {vol}}})^{\rm T} {\mathbf {\nabla^{\textrm T} N}^e_{\textrm {vol}}} \\
\end{array} \right]
\end{split}
\label{eq:FullStiffness}
\end{equation}
\]
</p>
<h1><a class="anchor" id="hierarchical_approximation_ele_mass_matrix"></a>
Element mass matrix</h1>
<p>In dynamic analyses, mass matrix is an extra component to solve the discrete problem. The stiffness matrix of a volume element is evaluated as the integral of</p>
<p class="formulaDsp">
\[
    \begin{equation}
{\mathbf {\textrm M}^e} = 
\int_{\Omega^e}({\mathbf {N}^e})^{\textrm T} {\mathbf {N}^e} {\textrm d\Omega^e}
\label{eq:MassMatrixIntegral}
\end{equation}
\]
</p>
<p>where \({\mathbf {\textrm M}^e}\) is the element mass matrix. Similar to the element stiffness matrix, the matrix quantity in the integrals is evaluated similar to \(\eqref {eq:FullStiffness}\) as</p>
<p class="formulaDsp">
\[
    \begin{equation}
\begin{split}
({\mathbf {N}^e})^{\textrm T} {\mathbf {N}^e} = \left[
\begin{array}{c}
({\mathbf {N}^e_{\textrm {ver}}})^{\rm T}\\
({\mathbf {N}^e_{\textrm {edge}}})^{\rm T}\\
({\mathbf {N}^e_{\textrm {face}}})^{\rm T}\\
({\mathbf {N}^e_{\textrm {vol}}})^{\rm T}
\end{array} \right]
\left[
 \begin{array}{cccc} 
{\mathbf {N}^e_{\textrm {ver}}} &amp; {\mathbf {N}^e_{\textrm {edge}}} &amp; {\mathbf { N}^e_{\textrm {face}}} &amp; {\mathbf {N}^e_{\textrm {vol}}}
\end{array} \right] 
 = \\
\left[
 \begin{array}{cccc}
({\mathbf {N}^e_{\textrm {ver}}})^{\rm T} {\mathbf {N}^e_{\textrm {ver}}} &amp;  
({\mathbf {N}^e_{\textrm {ver}}})^{\rm T} {\mathbf {N}^e_{\textrm {edge}}} &amp; 
({\mathbf {N}^e_{\textrm {ver}}})^{\rm T} {\mathbf {N}^e_{\textrm {face}}} &amp; 
({\mathbf {N}^e_{\textrm {ver}}})^{\rm T} {\mathbf {N}^e_{\textrm {vol}}}\\ 
({\mathbf {N}^e_{\textrm {edge}}})^{\rm T} {\mathbf {N}^e_{\textrm {ver}}} &amp;
({\mathbf {N}^e_{\textrm {edge}}})^{\rm T} {\mathbf {N}^e_{\textrm {edge}}} &amp;
({\mathbf {N}^e_{\textrm {edge}}})^{\rm T} {\mathbf {N}^e_{\textrm {face}}} &amp;
({\mathbf {N}^e_{\textrm {edge}}})^{\rm T} {\mathbf {N}^e_{\textrm {vol}}} \\ 
({\mathbf {N}^e_{\textrm {face}}})^{\rm T} {\mathbf {N}^e_{\textrm {ver}}}&amp;
({\mathbf {N}^e_{\textrm {face}}})^{\rm T} {\mathbf {N}^e_{\textrm {edge}}}&amp;
({\mathbf {N}^e_{\textrm {face}}})^{\rm T} {\mathbf {N}^e_{\textrm {face}}}&amp; 
({\mathbf {N}^e_{\textrm {face}}})^{\rm T} {\mathbf {N}^e_{\textrm {vol}}} \\
({\mathbf {N}^e_{\textrm {vol}}})^{\rm T} {\mathbf {N}^e_{\textrm {ver}}}&amp;
({\mathbf {N}^e_{\textrm {vol}}})^{\rm T} {\mathbf {N}^e_{\textrm {edge}}}&amp;
({\mathbf {N}^e_{\textrm {vol}}})^{\rm T} {\mathbf {N}^e_{\textrm {face}}}&amp; 
({\mathbf {N}^e_{\textrm {vol}}})^{\rm T} {\mathbf {N}^e_{\textrm {vol}}} \\
\end{array} \right]
\end{split}
\label{eq:FullMass}
\end{equation}
\]
</p>
<h1><a class="anchor" id="hierarchical_approximation_data_structures"></a>
Entity approximation functions</h1>
<p>To assemble the global stiffness matrix to solve the discretised problem, three nested loops are performed. The out most loop operates over the finite elements, the second loop operated over the element entities and the innermost loop operates over the element gauss points.</p>
<p>In a typical implementation, the user can access base functions on the finite element for each sub-entity of finite element. For example, the quadrilateral is made from four nodes, four edges and one quadrilateral face. The tetrahedron is constructed from four nodes, six edges, four faces and one tetrahedron volume. Developer can access base functions on those entities by structure <a class="el" href="structMoFEM_1_1EntitiesFieldData_1_1EntData.html" title="Data on single entity (This is passed as argument to DataOperator::doWork)">MoFEM::EntitiesFieldData::EntData</a>. This structure carries basic on information entity, like approximation order, orientation (sense), number of DOFs, and base functions, etc.. It is accessed from <em>Users</em> <em>Data</em> <em>Operator</em> explained in other tutorials.</p>
<p>In particular, base functions are accessed on entity by <a class="el" href="structMoFEM_1_1EntitiesFieldData_1_1EntData.html#a6803bfc79169740e108bd5e2666de739" title="get base functions this return matrix (nb. of rows is equal to nb. of Gauss pts, nb....">MoFEM::EntitiesFieldData::EntData::getN</a> and derivatives by <a class="el" href="structMoFEM_1_1EntitiesFieldData_1_1EntData.html#a37ce62a0e0398b57b8ed23d01c38d755" title="get derivatives of base functions">MoFEM::EntitiesFieldData::EntData::getDiffN</a>. Here we explain the structure of matrices returned by those two functions. Note that those functions are overloaded and have many variants for developer convenience, and derivatives of them for H-div and H-curl spaces.</p>
<p>Assembling contribution from finite element, for each entity on finite element <a class="el" href="namespaceMoFEM.html" title="implementation of Data Operators for Forces and Sources">MoFEM</a> calls the developer overridden implementation of <em>User</em> <em>Data</em> <em>Operator</em>, i.e. method <a class="el" href="structMoFEM_1_1DataOperator.html#a19219f04bba3938fd893898f128dcfb2" title="Operator for bi-linear form, usually to calculate values on left hand side.">MoFEM::DataOperator::doWork</a>. You can see how such operator is implemented for example in <a class="el" href="simple_elasticity_1.html">COR-6: Solid elasticity</a>.</p>
<p>The goal of the loop over element entities is to assemble the element stiffness matrix presented in \(\eqref {eq:FullStiffness}\). The set of information associated to each entity is <em>row_data</em> and <em>col_data</em> which are instances of <a class="el" href="structMoFEM_1_1EntitiesFieldData_1_1EntData.html" title="Data on single entity (This is passed as argument to DataOperator::doWork)">MoFEM::EntitiesFieldData::EntData</a> and passed as argument in <a class="el" href="structMoFEM_1_1DataOperator.html#a19219f04bba3938fd893898f128dcfb2" title="Operator for bi-linear form, usually to calculate values on left hand side.">MoFEM::DataOperator::doWork</a>. In <em>col_data</em> the matrix \({\mathbf {\nabla^{\textrm T} N}^e_{\textrm {ent}}}\) presented in \(\eqref {eq:FullStiffness}\) is stored. In \(row\_data\), a series of matrices \(({\mathbf {\nabla^{\textrm T} N}^e_{\textrm {ent}}})^{\rm T}\) is stored presented in \(\eqref {eq:FullStiffness}\), where \({\mathbf
{N}}^e_{\textrm {ent}}\) is the shape function of a given entity. Each entity (ent), has two matrices \(({\mathbf {\nabla^{\textrm T}
N}^e_{\textrm {ent}}})^{\rm T}\) and \({\mathbf {\nabla^{\textrm T}
N}^e_{\textrm {ent}}}\) as well as shape functions corresponding to the entities degrees of freedom. These matrices are stored as rows in matrices, where each row corresponds to a gauss point as presented in \(\eqref
{eq:NablaShape1}\)  </p><p class="formulaDsp">
\[ 
\newcommand{\myarray}[1]{{\left\downarrow\vphantom{#1}\right.{#1}}}
\newcommand{\myarraysecond}[1]{{\overset{\xrightarrow[\hphantom{#1}]{\text{$n$ degrees of freedom of element entity}}}{#1}}}
\begin{equation}
\text{element $m$ gauss points}\myarray{
 \begin{array}{c}
\\
{\rm {gg}}_1 \\ 
\\
{\rm {gg}}_2 \\ 
\\
{\rm {gg}}_3 \\ 
\\
\vdots \\
{\rm {gg}}_m
 \end{array}
}
\myarraysecond{
\left[
 \begin{array}{ccccc} 
{\overbrace{\begin{array}{c c c}  \dfrac{\partial {\mathbf {N}^e_{\textrm 1}} }{\partial x} &amp; \dfrac{\partial {\mathbf {N}^e_{\textrm 1}} }{\partial y} &amp; \dfrac{\partial {\mathbf {N}^e_{\textrm 1}} }{\partial z} \end{array} }^{\textrm{1st Element DoF} } } &amp;\dots  &amp; \dfrac{\partial {\mathbf {N}^e_{ n}} }{\partial x}  &amp; \dfrac{\partial {\mathbf {N}^e_{ n}} }{\partial y} &amp; \dfrac{\partial {\mathbf {N}^e_{ n}} }{\partial z}   \\ 
{\begin{array}{c c c} \dfrac{\partial {\mathbf {N}^e_{\textrm 1}} }{\partial x} &amp; \dfrac{\partial {\mathbf {N}^e_{\textrm 1}} }{\partial y} 
&amp; \dfrac{\partial {\mathbf {N}^e_{\textrm 1}} }{\partial z}\end{array}}  &amp; \dots &amp; \dfrac{\partial {\mathbf {N}^e_{ n}} }{\partial x}  &amp; \dfrac{\partial {\mathbf {N}^e_{ n}} }{\partial y} &amp; \dfrac{\partial {\mathbf {N}^e_{n}} }{\partial z} \\ 
{\begin{array}{c c c}\dfrac{\partial {\mathbf {N}^e_{\textrm 1}} }{\partial x} &amp; \dfrac{\partial {\mathbf {N}^e_{\textrm 1}} }{\partial y} 
&amp; \dfrac{\partial {\mathbf {N}^e_{\textrm 1}} }{\partial z}\end{array}} &amp; \dots &amp; \dfrac{\partial {\mathbf {N}^e_{ n}} }{\partial x}  &amp; \dfrac{\partial {\mathbf {N}^e_{ n}} }{\partial y} &amp; \dfrac{\partial {\mathbf {N}^e_{ n}} }{\partial z} \\ 
{\begin{array}{c c c c c}\vdots\,\, &amp; &amp; \vdots &amp; &amp; \,\, \vdots \end{array}} &amp; \ddots &amp; \vdots &amp; \vdots &amp;\vdots \\
{\begin{array}{c c c}\dfrac{\partial {\mathbf {N}^e_{\textrm 1}} }{\partial x} &amp; \dfrac{\partial {\mathbf {N}^e_{\textrm 1}} }{\partial y} 
&amp; \dfrac{\partial {\mathbf {N}^e_{\textrm 1}} }{\partial z}\end{array}} &amp; \dots  &amp; \dfrac{\partial {\mathbf {N}^e_{ n}} }{\partial x}  &amp; \dfrac{\partial {\mathbf {N}^e_{ n}} }{\partial y} &amp; \dfrac{\partial {\mathbf {N}^e_{ n}} }{\partial z}
\end{array}
 \right] }
\hspace{2.cm} 
\label{eq:NablaShape2}
\end{equation}
\]
</p>
<p>For the same gauss point \({\rm {gg}}_m\), row data from matrices \(\eqref
{eq:NablaShape2}\) and \(\eqref {eq:ShapeGG}\) is retrieved and a loop is performed to evaluate all multiplication of degree of freedom combination.</p>
<p>Similarly, the mass matrix presented in \(\eqref {eq:FullMass}\) is evaluated performing the loop over the element entities and gauss points where the shape functions are stored to a matrix data structure as presented below  </p><p class="formulaDsp">
\[
\newcommand{\myarray}[1]{{\left\downarrow\vphantom{#1}\right.{#1}}}
\newcommand{\myarraysecond}[1]{{\overset{\xrightarrow[\hphantom{#1}]{\text{$n$ degrees of freedom of element entity}}}{#1}}}
\begin{equation}
\text{element $m$ gauss points}\myarray{
 \begin{array}{c}
{\rm {gg}}_1 \\ 
{\rm {gg}}_2 \\ 
{\rm {gg}}_3 \\ 
\vdots \\ 
{\rm {gg}}_m
 \end{array}
}
\myarraysecond{
\left[
 \begin{array}{ccccccc} 
\mathbf {N}^e_{\textrm 1} &amp;  {\mathbf {N}^e_{\textrm 2}} &amp; {\mathbf  {N}^e_{\textrm 3}} &amp; \dots &amp; {\mathbf  {N}^e_{n-2}} &amp; {\mathbf {N}^e_{ n-1}}  &amp; {\mathbf {N}^e_{n}} \\ 
 {\mathbf {N}^e_{\textrm 1}}  &amp;  {\mathbf {N}^e_{\textrm 2}} &amp; {\mathbf {N}^e_{\textrm 3}} &amp; \dots &amp; {\mathbf {N}^e_{n-2}}   &amp; {\mathbf{N}^e_{n-1}}  &amp;  {\mathbf {N}^e_{n}} \\ 
 {\mathbf {N}^e_{\textrm 1}}  &amp; {\mathbf {N}^e_{\textrm 2}} &amp; {\mathbf {N}^e_{\textrm 3}} &amp; \dots &amp; {\mathbf {N}^e_{n-2}} &amp; {\mathbf {N}^e_{n-1}} &amp; {\mathbf {N}^e_{n}}\\ 
\vdots &amp; \vdots &amp; \vdots  &amp; \ddots &amp; \vdots &amp; \vdots &amp;\vdots \\
 {\mathbf {N}^e_{\textrm 1}} &amp;  {\mathbf {N}^e_{\textrm 2}} &amp;  {\mathbf {N}^e_{\textrm 3}} &amp; \dots  &amp;  {\mathbf {N}^e_{n-2}}  &amp; {\mathbf {N}^e_{n-1}}  &amp; {\mathbf {N}^e_{n}}
\end{array}
 \right] }
\hspace{2.5cm} 
\label{eq:ShapeGG}
\end{equation}
\]
</p>
<p>Note that there is no notion of the shape of the element since matrices are integrated and assembled entity-by-entity, which in finite element. This implementation approach is completely general. To evaluate the element stiffness matrix one need to list entities, and on them gauss points, degrees of freedom, shape functions and their gradients and perform the aforementioned loop. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr cla ss="footer" />
<style>
  img[src="UoGLogo.png"] {
    height: 20px;
    padding-top: 0px;
    padding-right: 1px;
    padding-bottom: 3px;
    padding-left: 6px;
  }
</style>
<address class="footer">
  <small>
    Generated by
    <a href="http://www.doxygen.org/index.html"> Doxygen </a> 1.9.8
    and hosted at
    <a href="http://www.gla.ac.uk/schools/engineering/">
      <img class="footer" src="UoGLogo.png" alt="University of Glasgow" />
    </a>
  </small>
</address>
</body>
</html>